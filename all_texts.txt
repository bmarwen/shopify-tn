File: ./src/components/authorization/feature-guard.tsx
// src/components/authorization/feature-guard.tsx
"use client";

import { ReactNode } from "react";
import { useSession } from "next-auth/react";
import { Feature, hasFeatureAccess } from "@/lib/feature-authorization";

interface FeatureGuardProps {
  /**
   * The feature(s) to check - can be a single feature or an array of features
   * - If array, requires access to ALL features (AND logic)
   */
  feature: Feature | Feature[];

  /**
   * The content to render if the user has access to the feature
   */
  children: ReactNode;

  /**
   * Optional fallback component to render if user doesn't have access
   * - If not provided, renders nothing when access is denied
   */
  fallback?: ReactNode;
}

/**
 * A component that conditionally renders content based on feature access
 */
export function FeatureGuard({
  feature,
  children,
  fallback,
}: FeatureGuardProps) {
  const { data: session } = useSession();

  // Check if user has access to the required feature(s)
  const hasAccess = Array.isArray(feature)
    ? feature.every((f) => hasFeatureAccess(session?.user, f))
    : hasFeatureAccess(session?.user, feature);

  // Render children if user has access, otherwise render fallback or nothing
  return hasAccess ? <>{children}</> : fallback ? <>{fallback}</> : null;
}

/**
 * A component that conditionally renders based on the user's plan type
 */
export function PlanGuard({
  plan,
  children,
  fallback,
}: {
  plan:
    | "STANDARD"
    | "ADVANCED"
    | "PREMIUM"
    | ("STANDARD" | "ADVANCED" | "PREMIUM")[];
  children: ReactNode;
  fallback?: ReactNode;
}) {
  const { data: session } = useSession();
  const userPlan = session?.user?.planType || "STANDARD";

  const hasAccess = Array.isArray(plan)
    ? plan.includes(userPlan as any)
    : userPlan === plan;

  return hasAccess ? <>{children}</> : fallback ? <>{fallback}</> : null;
}

/**
 * A component that only renders for specific user roles
 */
export function RoleGuard({
  role,
  children,
  fallback,
}: {
  role:
    | "SUPER_ADMIN"
    | "SHOP_ADMIN"
    | "SHOP_STAFF"
    | "CUSTOMER"
    | ("SUPER_ADMIN" | "SHOP_ADMIN" | "SHOP_STAFF" | "CUSTOMER")[];
  children: ReactNode;
  fallback?: ReactNode;
}) {
  const { data: session } = useSession();
  const userRole = session?.user?.role;

  if (!userRole) return fallback ? <>{fallback}</> : null;

  const hasAccess = Array.isArray(role)
    ? role.includes(userRole as any)
    : userRole === role;

  return hasAccess ? <>{children}</> : fallback ? <>{fallback}</> : null;
}

/**
 * Example usage:
 *
 * <FeatureGuard feature={Feature.INVOICE_GENERATION}>
 *   <InvoiceGenerationButton />
 * </FeatureGuard>
 *
 * <PlanGuard plan="PREMIUM">
 *   <PremiumFeature />
 * </PlanGuard>
 *
 * <RoleGuard role={["SHOP_ADMIN", "SUPER_ADMIN"]}>
 *   <AdminControls />
 * </RoleGuard>
 */

File: ./src/components/providers/session-provider.tsx
// src/components/providers/session-provider.tsx
"use client";

import { SessionProvider as NextAuthSessionProvider } from "next-auth/react";

export function SessionProvider({ children }: { children: React.ReactNode }) {
  return <NextAuthSessionProvider>{children}</NextAuthSessionProvider>;
}

File: ./src/components/providers/toast-provider.tsx
// src/components/providers/toast-provider.tsx
"use client";

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function ToastsProvider() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}

File: ./src/components/providers/shop-provider.tsx
// src/components/providers/shop-provider.tsx
"use client";

import React, { createContext, useContext, useEffect, useState } from "react";
import { db } from "@/lib/prisma";

type ShopSettingsType = {
  currency: string;
  language: string;
  timezone: string;
  contactEmail: string | null;
  contactPhone: string | null;
  address: string | null;
};

type ShopContextType = {
  shopName: string;
  shopLogo: string | null;
  settings: ShopSettingsType;
  planType: string;
  isLoading: boolean;
};

const defaultSettings: ShopSettingsType = {
  currency: "USD",
  language: "en",
  timezone: "UTC",
  contactEmail: null,
  contactPhone: null,
  address: null,
};

const defaultState: ShopContextType = {
  shopName: "",
  shopLogo: null,
  settings: defaultSettings,
  planType: "STANDARD",
  isLoading: true,
};

const ShopContext = createContext<ShopContextType>(defaultState);

export const useShop = () => useContext(ShopContext);

export const ShopProvider = ({ children }: { children: React.ReactNode }) => {
  const [shopState, setShopState] = useState<ShopContextType>(defaultState);

  useEffect(() => {
    const loadShopInfo = async () => {
      try {
        const res = await fetch("/api/shop");
        const data = await res.json();

        setShopState({
          shopName: data.name,
          shopLogo: data.logo,
          settings: {
            currency: data.settings?.currency || "USD",
            language: data.settings?.language || "en",
            timezone: data.settings?.timezone || "UTC",
            contactEmail: data.settings?.contactEmail || null,
            contactPhone: data.settings?.contactPhone || null,
            address: data.settings?.address || null,
          },
          planType: data.planType,
          isLoading: false,
        });
      } catch (error) {
        console.error("Failed to load shop information:", error);
        setShopState({
          ...defaultState,
          isLoading: false,
        });
      }
    };

    loadShopInfo();
  }, []);

  return (
    <ShopContext.Provider value={shopState}>{children}</ShopContext.Provider>
  );
};

File: ./src/components/admin/product-list-actions.tsx
// src/components/admin/product-list-actions.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { MoreHorizontal, Edit, Copy, Trash, ExternalLink } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useToast } from "@/components/ui/use-toast";

interface ProductListActionsProps {
  productId: string;
}

export default function ProductListActions({
  productId,
}: ProductListActionsProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleDelete = async () => {
    try {
      setIsDeleting(true);

      const response = await fetch(`/api/products/${productId}`, {
        method: "DELETE",
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.error || "Failed to delete product");
      }

      // Show success toast
      toast({
        title: "Product deleted",
        description: "The product has been successfully deleted",
      });

      // Close the dialog
      setShowDeleteDialog(false);

      // Refresh the page
      router.refresh();
    } catch (error) {
      console.error("Error deleting product:", error);

      // Show error toast
      toast({
        title: "Error",
        description:
          error instanceof Error ? error.message : "Failed to delete product",
        variant: "destructive",
      });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
            <span className="sr-only">Open menu</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem asChild>
            <Link
              href={`/admin/products/${productId}`}
              className="flex items-center"
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit
            </Link>
          </DropdownMenuItem>
          <DropdownMenuItem asChild>
            <Link
              href={`/products/${productId}`}
              target="_blank"
              className="flex items-center"
            >
              <ExternalLink className="mr-2 h-4 w-4" />
              View on site
            </Link>
          </DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            className="text-red-600 focus:text-red-600 cursor-pointer"
            onClick={() => setShowDeleteDialog(true)}
          >
            <Trash className="mr-2 h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              product and all of its data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700"
              disabled={isDeleting}
            >
              {isDeleting ? "Deleting..." : "Delete"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

File: ./src/components/admin/product-categories-select.tsx
// src/components/admin/product-categories-select.tsx
"use client";

import { useState, useEffect } from "react";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Search, ChevronRight, ChevronDown } from "lucide-react";

interface Category {
  id: string;
  name: string;
  level: number;
  parentId?: string | null;
}

interface CategoryTreeItem extends Category {
  children?: CategoryTreeItem[];
  isExpanded?: boolean;
}

interface ProductCategoriesSelectProps {
  categories: Category[];
  selectedCategories: string[];
  onChange: (selected: string[]) => void;
}

export default function ProductCategoriesSelect({
  categories,
  selectedCategories,
  onChange,
}: ProductCategoriesSelectProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [localSelected, setLocalSelected] = useState<string[]>(
    selectedCategories || []
  );
  const [categoryTree, setCategoryTree] = useState<CategoryTreeItem[]>([]);
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set()
  );

  // Sync local state with props
  useEffect(() => {
    setLocalSelected(selectedCategories || []);
  }, [selectedCategories]);

  // Build category tree
  useEffect(() => {
    // First, organize into a tree structure
    const buildCategoryTree = (cats: Category[]): CategoryTreeItem[] => {
      // Map to store categories by ID for quick lookup
      const categoryMap: Record<string, CategoryTreeItem> = {};

      // Initialize the map with all categories
      cats.forEach((cat) => {
        categoryMap[cat.id] = {
          ...cat,
          children: [],
          isExpanded: expandedCategories.has(cat.id),
        };
      });

      // Build the tree by assigning children to their parents
      const rootCategories: CategoryTreeItem[] = [];

      cats.forEach((cat) => {
        if (cat.parentId && categoryMap[cat.parentId]) {
          // This is a child category
          if (!categoryMap[cat.parentId].children) {
            categoryMap[cat.parentId].children = [];
          }
          categoryMap[cat.parentId].children!.push(categoryMap[cat.id]);
        } else {
          // This is a root category (no parent)
          rootCategories.push(categoryMap[cat.id]);
        }
      });

      return rootCategories;
    };

    setCategoryTree(buildCategoryTree(categories));
  }, [categories, expandedCategories]);

  const handleCategoryChange = (categoryId: string, checked: boolean) => {
    let newSelected = [...localSelected];

    if (checked) {
      // Add this category
      newSelected.push(categoryId);

      // When selecting a subcategory, also select all its parent categories
      let currentCategory = categories.find((c) => c.id === categoryId);
      while (currentCategory && currentCategory.parentId) {
        // If the parent isn't already selected, add it
        if (!newSelected.includes(currentCategory.parentId)) {
          newSelected.push(currentCategory.parentId);
        }
        // Move up to the parent
        currentCategory = categories.find(
          (c) => c.id === currentCategory?.parentId
        );
      }
    } else {
      // Remove this category
      newSelected = newSelected.filter((id) => id !== categoryId);

      // When deselecting a category, also deselect all its children
      const getAllChildrenIds = (parentId: string): string[] => {
        const children = categories.filter((c) => c.parentId === parentId);
        if (children.length === 0) return [];

        const childrenIds = children.map((c) => c.id);
        const grandChildrenIds = children.flatMap((c) =>
          getAllChildrenIds(c.id)
        );
        return [...childrenIds, ...grandChildrenIds];
      };

      const childrenIds = getAllChildrenIds(categoryId);
      newSelected = newSelected.filter((id) => !childrenIds.includes(id));
    }

    setLocalSelected(newSelected);
    onChange(newSelected);
  };

  const toggleCategoryExpansion = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  // Filter categories based on search term
  const filterCategories = (
    items: CategoryTreeItem[],
    term: string
  ): CategoryTreeItem[] => {
    if (!term) return items;

    return items
      .filter((item) => {
        const nameMatches = item.name
          .toLowerCase()
          .includes(term.toLowerCase());
        const childMatches = item.children
          ? filterCategories(item.children, term).length > 0
          : false;

        return nameMatches || childMatches;
      })
      .map((item) => {
        if (!item.children) return item;

        return {
          ...item,
          children: filterCategories(item.children, term),
        };
      });
  };

  const filteredCategoryTree = searchTerm
    ? filterCategories(categoryTree, searchTerm)
    : categoryTree;

  // Render a category item with its children recursively
  const renderCategory = (category: CategoryTreeItem, depth = 0) => {
    const hasChildren = category.children && category.children.length > 0;
    const isExpanded = expandedCategories.has(category.id);

    return (
      <div key={category.id} className="category-item">
        <div
          className={`flex items-center px-3 py-2 hover:bg-gray-50 ${
            localSelected.includes(category.id) ? "bg-gray-50" : ""
          }`}
          style={{ paddingLeft: `${16 + depth * 20}px` }}
        >
          {hasChildren && (
            <button
              type="button"
              onClick={() => toggleCategoryExpansion(category.id)}
              className="p-1 mr-1 rounded-sm hover:bg-gray-100 text-gray-500"
            >
              {isExpanded ? (
                <ChevronDown className="h-4 w-4" />
              ) : (
                <ChevronRight className="h-4 w-4" />
              )}
            </button>
          )}
          {!hasChildren && <div className="w-6 mr-1"></div>}

          <Checkbox
            id={`category-${category.id}`}
            checked={localSelected.includes(category.id)}
            onCheckedChange={(checked) =>
              handleCategoryChange(category.id, checked === true)
            }
            className="mr-2"
          />
          <Label
            htmlFor={`category-${category.id}`}
            className="cursor-pointer flex-grow text-sm"
            style={{ color: "#2c3e50" }}
          >
            {category.name}
          </Label>
        </div>

        {hasChildren && isExpanded && (
          <div className="children">
            {category.children!.map((child) =>
              renderCategory(child, depth + 1)
            )}
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="space-y-4">
      {/* Search input */}
      <div className="relative">
        <Search
          className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4"
          style={{ color: "#bdc3c7" }}
        />
        <Input
          type="text"
          placeholder="Search categories..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="pl-10 border-2 text-gray-800 placeholder-gray-400"
          style={{
            borderColor: "#bdc3c7",
            backgroundColor: "white",
          }}
        />
      </div>

      {categories.length === 0 ? (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <p className="text-yellow-800">
            No categories found. Please create categories first.
          </p>
        </div>
      ) : filteredCategoryTree.length === 0 ? (
        <p style={{ color: "#2c3e50" }}>No categories match your search.</p>
      ) : (
        <div
          className="border rounded-lg overflow-auto max-h-[400px]"
          style={{ borderColor: "#bdc3c7" }}
        >
          <div className="category-tree">
            {filteredCategoryTree.map((category) => renderCategory(category))}
          </div>
        </div>
      )}

      {localSelected.length > 0 && (
        <div className="mt-4">
          <p className="text-sm" style={{ color: "#2c3e50" }}>
            Selected categories: {localSelected.length}
          </p>
          <div className="flex flex-wrap gap-2 mt-2">
            {localSelected.map((id) => {
              const category = categories.find((c) => c.id === id);
              if (!category) return null;

              return (
                <div
                  key={id}
                  style={{
                    backgroundColor: "#16a085",
                    color: "white",
                  }}
                  className="px-3 py-1 rounded-full text-sm flex items-center"
                >
                  {category.name}
                  <button
                    onClick={() => handleCategoryChange(id, false)}
                    className="ml-2 hover:text-gray-200"
                  >
                    ×
                  </button>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}

File: ./src/components/admin/custom-fields-table.tsx
// src/components/admin/custom-fields-table.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Pencil, Trash, Info, Filter } from "lucide-react";
import { formatDate } from "@/lib/utils";

interface CustomField {
  id: string;
  name: string;
  type: string;
  required: boolean;
  createdAt: string | Date;
  updatedAt: string | Date;
  usageCount?: number;
}

interface CustomFieldsTableProps {
  customFields: CustomField[];
}

export default function CustomFieldsTable({
  customFields = [],
}: CustomFieldsTableProps) {
  const router = useRouter();
  const [isEditing, setIsEditing] = useState<string | null>(null);
  const [deleteField, setDeleteField] = useState<string | null>(null);
  const [editName, setEditName] = useState("");
  const [editType, setEditType] = useState("");
  const [editRequired, setEditRequired] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [fieldTypeFilter, setFieldTypeFilter] = useState<string>("all");

  // Start editing a field
  const handleEdit = (field: CustomField) => {
    setIsEditing(field.id);
    setEditName(field.name);
    setEditType(field.type);
    setEditRequired(field.required);
  };

  // Cancel editing
  const handleCancelEdit = () => {
    setIsEditing(null);
  };

  // Save edited field
  const handleSaveEdit = async () => {
    if (!isEditing) return;

    setIsSubmitting(true);

    try {
      const response = await fetch(`/api/custom-fields/${isEditing}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: editName,
          type: editType,
          required: editRequired,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to update custom field");
      }

      setIsEditing(null);
      router.refresh();
    } catch (error) {
      console.error("Error updating custom field:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Delete a field
  const handleDelete = async () => {
    if (!deleteField) return;

    try {
      const response = await fetch(`/api/custom-fields/${deleteField}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete custom field");
      }

      setDeleteField(null);
      router.refresh();
    } catch (error) {
      console.error("Error deleting custom field:", error);
    }
  };

  // Filter and search custom fields
  const filteredFields = customFields.filter((field) => {
    const matchesSearch = field.name
      .toLowerCase()
      .includes(searchTerm.toLowerCase());
    const matchesType =
      fieldTypeFilter === "all" || field.type === fieldTypeFilter;
    return matchesSearch && matchesType;
  });

  const fieldTypes = [
    { value: "TEXT", label: "Text" },
    { value: "NUMBER", label: "Number" },
    { value: "BOOLEAN", label: "Yes/No" },
    { value: "DATE", label: "Date" },
    { value: "TEXTAREA", label: "Long Text" },
    { value: "SELECT", label: "Select" },
  ];

  // Get readable field type
  const getFieldTypeLabel = (type: string) => {
    const fieldType = fieldTypes.find((t) => t.value === type);
    return fieldType ? fieldType.label : type;
  };

  return (
    <div>
      {/* Filters */}
      <div className="flex flex-col sm:flex-row gap-3 p-4 border-b border-gray-200">
        <div className="relative flex-1">
          <Input
            placeholder="Search fields..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-8 border-gray-300 text-gray-800 placeholder:text-gray-400"
          />
          <Filter className="absolute left-2.5 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
        </div>
        <div className="w-full sm:w-48">
          <Select value={fieldTypeFilter} onValueChange={setFieldTypeFilter}>
            <SelectTrigger className="border-gray-300 text-gray-800">
              <SelectValue placeholder="Filter by type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Types</SelectItem>
              {fieldTypes.map((type) => (
                <SelectItem key={type.value} value={type.value}>
                  {type.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Table */}
      <div className="overflow-x-auto">
        <Table>
          <TableHeader className="bg-gray-50">
            <TableRow>
              <TableHead className="text-gray-700">Name</TableHead>
              <TableHead className="text-gray-700">Type</TableHead>
              <TableHead className="text-gray-700">Required</TableHead>
              <TableHead className="text-gray-700">Usage</TableHead>
              <TableHead className="text-gray-700">Created</TableHead>
              <TableHead className="text-right text-gray-700">
                Actions
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredFields.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={6}
                  className="h-32 text-center text-gray-500"
                >
                  {customFields.length === 0
                    ? "No custom fields found. Add your first custom field to get started."
                    : "No custom fields match your search criteria."}
                </TableCell>
              </TableRow>
            ) : (
              filteredFields.map((field) => (
                <TableRow key={field.id} className="hover:bg-gray-50">
                  {isEditing === field.id ? (
                    // Editing row
                    <>
                      <TableCell>
                        <Input
                          value={editName}
                          onChange={(e) => setEditName(e.target.value)}
                          className="border-gray-300 text-gray-800 w-full max-w-xs"
                        />
                      </TableCell>
                      <TableCell>
                        <Select value={editType} onValueChange={setEditType}>
                          <SelectTrigger className="border-gray-300 text-gray-800 w-full max-w-[130px]">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            {fieldTypes.map((type) => (
                              <SelectItem key={type.value} value={type.value}>
                                {type.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center">
                          <Switch
                            checked={editRequired}
                            onCheckedChange={setEditRequired}
                            className="data-[state=checked]:bg-indigo-600"
                          />
                        </div>
                      </TableCell>
                      <TableCell>{field.usageCount || 0} products</TableCell>
                      <TableCell>{formatDate(field.createdAt)}</TableCell>
                      <TableCell className="text-right space-x-2">
                        <Button
                          type="button"
                          variant="outline"
                          size="sm"
                          onClick={handleCancelEdit}
                          className="border-gray-300 text-gray-700"
                        >
                          Cancel
                        </Button>
                        <Button
                          type="button"
                          size="sm"
                          onClick={handleSaveEdit}
                          disabled={isSubmitting}
                          className="bg-indigo-600 hover:bg-indigo-700 text-white"
                        >
                          Save
                        </Button>
                      </TableCell>
                    </>
                  ) : (
                    // Normal row
                    <>
                      <TableCell className="font-medium text-gray-800">
                        {field.name}
                      </TableCell>
                      <TableCell>{getFieldTypeLabel(field.type)}</TableCell>
                      <TableCell>
                        {field.required ? (
                          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                            Required
                          </span>
                        ) : (
                          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                            Optional
                          </span>
                        )}
                      </TableCell>
                      <TableCell>
                        <span className="text-gray-700">
                          {field.usageCount || 0} products
                        </span>
                      </TableCell>
                      <TableCell>{formatDate(field.createdAt)}</TableCell>
                      <TableCell className="text-right space-x-1">
                        <Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => handleEdit(field)}
                          className="text-gray-700 hover:text-indigo-600"
                        >
                          <Pencil className="h-4 w-4" />
                        </Button>
                        <Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => setDeleteField(field.id)}
                          className="text-gray-700 hover:text-red-600"
                          disabled={
                            field.usageCount ? field.usageCount > 0 : false
                          }
                          title={
                            field.usageCount && field.usageCount > 0
                              ? "Cannot delete fields in use"
                              : "Delete field"
                          }
                        >
                          <Trash className="h-4 w-4" />
                        </Button>
                      </TableCell>
                    </>
                  )}
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Delete Confirmation Dialog */}
      <AlertDialog
        open={!!deleteField}
        onOpenChange={() => setDeleteField(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              custom field and may affect products using it.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="border-gray-300 text-gray-700">
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700 text-white"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

File: ./src/components/admin/product-form-types.ts
// src/components/admin/product-form-types.ts
import { z } from "zod";

// Custom field value matching your database model
export interface CustomFieldValue {
  id?: string;
  customFieldId: string;
  value: string;
}

// Form schema validation
export const productSchema = z.object({
  name: z
    .string()
    .min(2, { message: "Product name must be at least 2 characters" }),
  description: z.string().optional(),
  price: z.coerce
    .number()
    .min(0, { message: "Price must be a positive number" }),
  // Remove compareAtPrice
  cost: z.coerce.number().optional().nullable(),
  barcode: z.string().optional(),
  inventory: z.coerce.number().int().default(0),
  tva: z.coerce.number().min(0).max(100).default(19), // TVA field with default 19%
  // We'll calculate profit % automatically
  categoryIds: z.array(z.string()).default([]),
  images: z.array(z.string()).default([]),
  variants: z
    .array(
      z.object({
        id: z.string().optional(),
        name: z.string(),
        price: z.coerce.number().min(0),
        inventory: z.coerce.number().int().default(0),
        sku: z.string().optional(),
        barcode: z.string().optional(),
        options: z.record(z.string(), z.string()),
      })
    )
    .default([]),
  expiryDate: z.string().optional().nullable(),
  customFieldValues: z
    .array(
      z.object({
        id: z.string().optional(),
        customFieldId: z.string(),
        value: z.string(),
      })
    )
    .default([]),
});

export type ProductFormValues = z.infer<typeof productSchema>;

// Types for other components
export interface Category {
  id: string;
  name: string;
  level: number;
}

export interface CustomField {
  id: string;
  name: string;
  type: string;
  required: boolean;
}

export interface ProductFormProps {
  product?: any;
  categories: Category[];
  customFields?: CustomField[];
  shopId: string;
  isEditing?: boolean;
}

// New type for discounts
export interface Discount {
  id?: string;
  percentage: number;
  enabled: boolean;
  startDate: Date | string;
  endDate: Date | string;
  productId: string;
}

// New type for discount codes
export interface DiscountCode {
  id?: string;
  code: string;
  percentage: number;
  startDate: Date | string;
  endDate: Date | string;
  shopId: string;
  productId?: string | null;
  userId?: string | null;
  isActive: boolean;
}

File: ./src/components/admin/add-custom-field-form.tsx
// src/components/admin/add-custom-field-form.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { AlertCircle, CheckCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";

// Form schema
const customFieldSchema = z.object({
  name: z.string().min(2, "Field name must be at least 2 characters"),
  type: z.string().min(1, "Field type is required"),
  required: z.boolean().default(false),
});

type CustomFieldFormValues = z.infer<typeof customFieldSchema>;

export default function AddCustomFieldForm() {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const form = useForm<CustomFieldFormValues>({
    resolver: zodResolver(customFieldSchema),
    defaultValues: {
      name: "",
      type: "TEXT",
      required: false,
    },
  });

  const onSubmit = async (values: CustomFieldFormValues) => {
    setIsSubmitting(true);
    setError(null);
    setSuccess(false);

    try {
      const response = await fetch("/api/custom-fields", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Failed to create custom field");
      }

      // Reset form and show success message
      form.reset();
      setSuccess(true);

      // Refresh to update the list
      router.refresh();

      // Clear success message after 3 seconds
      setTimeout(() => {
        setSuccess(false);
      }, 3000);
    } catch (err: any) {
      setError(err.message || "An error occurred");
      console.error("Error creating custom field:", err);
    } finally {
      setIsSubmitting(false);
    }
  };

  const fieldTypes = [
    { value: "TEXT", label: "Text (Single line)" },
    { value: "TEXTAREA", label: "Text (Multiple lines)" },
    { value: "NUMBER", label: "Number" },
    { value: "DATE", label: "Date" },
    { value: "BOOLEAN", label: "Yes/No" },
    { value: "SELECT", label: "Select (Dropdown)" },
  ];

  return (
    <div>
      {error && (
        <Alert variant="destructive" className="mb-4">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {success && (
        <Alert className="mb-4 bg-green-50 border-green-200">
          <CheckCircle className="h-4 w-4 text-green-600" />
          <AlertDescription className="text-green-700">
            Custom field created successfully!
          </AlertDescription>
        </Alert>
      )}

      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-gray-700">Field Name</FormLabel>
                <FormControl>
                  <Input
                    {...field}
                    placeholder="e.g., Material, Color, Dimensions"
                    className="border-gray-300 text-gray-800 placeholder:text-gray-400"
                  />
                </FormControl>
                <FormDescription className="text-gray-600">
                  This name will appear as a label in product forms
                </FormDescription>
                <FormMessage className="text-red-500" />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="type"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-gray-700">Field Type</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger className="border-gray-300 text-gray-800">
                      <SelectValue placeholder="Select field type" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {fieldTypes.map((type) => (
                      <SelectItem key={type.value} value={type.value}>
                        {type.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormDescription className="text-gray-600">
                  This determines how the field will be displayed and what kind
                  of data it accepts
                </FormDescription>
                <FormMessage className="text-red-500" />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="required"
            render={({ field }) => (
              <FormItem className="flex flex-row items-center justify-between rounded-lg border border-gray-200 p-4">
                <div className="space-y-0.5">
                  <FormLabel className="text-gray-700">
                    Required Field
                  </FormLabel>
                  <FormDescription className="text-gray-600">
                    Make this field mandatory when creating or editing products
                  </FormDescription>
                </div>
                <FormControl>
                  <Switch
                    checked={field.value}
                    onCheckedChange={field.onChange}
                    className="data-[state=checked]:bg-indigo-600"
                  />
                </FormControl>
              </FormItem>
            )}
          />

          <Button
            type="submit"
            disabled={isSubmitting}
            className="w-full bg-indigo-600 hover:bg-indigo-700 text-white"
          >
            {isSubmitting ? "Creating..." : "Create Custom Field"}
          </Button>
        </form>
      </Form>
    </div>
  );
}

File: ./src/components/admin/product-variants-form.tsx
// src/components/admin/product-variants-form.tsx
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Trash, Plus, ChevronDown, ChevronUp } from "lucide-react";
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

interface Variant {
  id?: string;
  name: string;
  price: number;
  inventory: number;
  sku?: string;
  barcode?: string;
  options: Record<string, string>;
}

interface ProductVariantsFormProps {
  variants: Variant[];
  onChange: (variants: Variant[]) => void;
}

export default function ProductVariantsForm({
  variants = [],
  onChange,
}: ProductVariantsFormProps) {
  // Local state to ensure we don't lose changes when switching tabs
  const [localVariants, setLocalVariants] = useState<Variant[]>(variants);
  const [expandedVariants, setExpandedVariants] = useState<Set<number>>(
    new Set()
  );
  const [optionTypes, setOptionTypes] = useState<string[]>(
    // Extract unique option types from existing variants or provide defaults
    Array.from(
      new Set(
        localVariants.flatMap((variant) => Object.keys(variant.options || {}))
      )
    ).length > 0
      ? Array.from(
          new Set(
            localVariants.flatMap((variant) =>
              Object.keys(variant.options || {})
            )
          )
        )
      : ["Color", "Size"] // Default option types
  );

  // Sync with parent when props change
  useEffect(() => {
    setLocalVariants(variants);
  }, [variants]);

  // Toggle variant expanded/collapsed state
  const toggleVariant = (index: number) => {
    const newExpandedVariants = new Set(expandedVariants);
    if (expandedVariants.has(index)) {
      newExpandedVariants.delete(index);
    } else {
      newExpandedVariants.add(index);
    }
    setExpandedVariants(newExpandedVariants);
  };

  // Add a new variant
  const addVariant = () => {
    // Create a new variant with empty values for each option type
    const newVariant: Variant = {
      name: "",
      price: 0,
      inventory: 0,
      sku: "",
      options: optionTypes.reduce((acc, type) => {
        acc[type] = "";
        return acc;
      }, {} as Record<string, string>),
    };

    const updatedVariants = [...localVariants, newVariant];
    setLocalVariants(updatedVariants);
    onChange(updatedVariants);

    // Auto-expand the newly added variant
    setExpandedVariants(new Set([...expandedVariants, localVariants.length]));
  };

  // Update a variant
  const updateVariant = (index: number, field: keyof Variant, value: any) => {
    const updatedVariants = [...localVariants];

    if (field === "options") {
      updatedVariants[index].options = {
        ...updatedVariants[index].options,
        ...value,
      };

      // Auto-generate name from options if it hasn't been manually set
      const currentName = updatedVariants[index].name;
      const generatedName = Object.values(updatedVariants[index].options)
        .filter(Boolean)
        .join(" / ");

      // Only update name if it appears to be auto-generated or empty
      if (
        !currentName ||
        currentName ===
          Object.values({ ...updatedVariants[index].options, ...value })
            .filter(Boolean)
            .join(" / ")
      ) {
        updatedVariants[index].name = generatedName;
      }
    } else {
      // @ts-ignore - We know this is a valid field
      updatedVariants[index][field] = value;
    }

    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  // Remove a variant
  const removeVariant = (index: number) => {
    const updatedVariants = [...localVariants];
    updatedVariants.splice(index, 1);

    // Update expanded variants set
    const newExpandedVariants = new Set<number>();
    expandedVariants.forEach((expandedIndex) => {
      if (expandedIndex < index) {
        newExpandedVariants.add(expandedIndex);
      } else if (expandedIndex > index) {
        newExpandedVariants.add(expandedIndex - 1);
      }
    });

    setExpandedVariants(newExpandedVariants);
    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  // Add a new option type (e.g., Color, Size)
  const addOptionType = () => {
    let newOptionName = "New Option";
    let counter = 1;

    // Make sure the name is unique
    while (optionTypes.includes(newOptionName)) {
      newOptionName = `New Option ${counter}`;
      counter++;
    }

    // Add to option types
    const newOptionTypes = [...optionTypes, newOptionName];
    setOptionTypes(newOptionTypes);

    // Add this option to all variants with empty value
    const updatedVariants = localVariants.map((variant) => ({
      ...variant,
      options: {
        ...variant.options,
        [newOptionName]: "",
      },
    }));

    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  // Update option type name
  const updateOptionType = (oldType: string, newType: string) => {
    // Prevent duplicate option types
    if (optionTypes.includes(newType) && oldType !== newType) {
      return;
    }

    // Update option type
    const newOptionTypes = optionTypes.map((type) =>
      type === oldType ? newType : type
    );
    setOptionTypes(newOptionTypes);

    // Update option keys in all variants
    const updatedVariants = localVariants.map((variant) => {
      const updatedOptions = { ...variant.options };
      if (oldType in updatedOptions) {
        updatedOptions[newType] = updatedOptions[oldType];
        delete updatedOptions[oldType];
      }

      return {
        ...variant,
        options: updatedOptions,
      };
    });

    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  // Remove an option type
  const removeOptionType = (typeToRemove: string) => {
    // Remove from option types
    const newOptionTypes = optionTypes.filter((type) => type !== typeToRemove);
    setOptionTypes(newOptionTypes);

    // Remove this option from all variants
    const updatedVariants = localVariants.map((variant) => {
      const updatedOptions = { ...variant.options };
      delete updatedOptions[typeToRemove];

      return {
        ...variant,
        options: updatedOptions,
      };
    });

    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
            Option Types
          </h3>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={addOptionType}
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
            }}
          >
            <Plus className="h-4 w-4 mr-2" />
            Add Option Type
          </Button>
        </div>

        <div
          className="border rounded-lg p-4"
          style={{ borderColor: "#bdc3c7" }}
        >
          <p className="text-sm mb-4" style={{ color: "#7f8c8d" }}>
            Define the option types for your variants (e.g., Color, Size,
            Material). Each variant can have different values for these options.
          </p>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {optionTypes.map((type, index) => (
              <div key={index} className="flex items-center space-x-2">
                <Input
                  value={type}
                  onChange={(e) => updateOptionType(type, e.target.value)}
                  placeholder="e.g., Color, Size, Material"
                  className="border-2"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#2c3e50",
                    backgroundColor: "white",
                  }}
                />
                <Button
                  type="button"
                  variant="ghost"
                  size="icon"
                  onClick={() => removeOptionType(type)}
                  disabled={optionTypes.length <= 1}
                  style={{
                    color: optionTypes.length <= 1 ? "#bdc3c7" : "#e74c3c",
                  }}
                >
                  <Trash className="h-4 w-4" />
                </Button>
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
            Product Variants
          </h3>
          <Button
            type="button"
            onClick={addVariant}
            style={{
              backgroundColor: "#16a085",
              color: "white",
            }}
          >
            <Plus className="h-4 w-4 mr-2" />
            Add Variant
          </Button>
        </div>

        {localVariants.length === 0 ? (
          <div
            className="border rounded-lg p-6 text-center"
            style={{ borderColor: "#bdc3c7" }}
          >
            <p style={{ color: "#2c3e50" }}>
              No variants yet. Add variants to create different versions of your
              product (e.g., different colors, sizes).
            </p>
            <Button
              type="button"
              onClick={addVariant}
              style={{
                backgroundColor: "#16a085",
                color: "white",
                marginTop: "1rem",
              }}
            >
              <Plus className="h-4 w-4 mr-2" />
              Add Your First Variant
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {localVariants.map((variant, index) => (
              <Card
                key={index}
                className="border overflow-hidden"
                style={{ borderColor: "#bdc3c7" }}
              >
                <CardHeader
                  className="flex flex-row items-center justify-between cursor-pointer p-4"
                  style={{
                    backgroundColor: expandedVariants.has(index)
                      ? "#f5f7fa"
                      : "white",
                  }}
                  onClick={() => toggleVariant(index)}
                >
                  <div className="flex items-center">
                    {expandedVariants.has(index) ? (
                      <ChevronUp
                        className="h-4 w-4 mr-2"
                        style={{ color: "#2c3e50" }}
                      />
                    ) : (
                      <ChevronDown
                        className="h-4 w-4 mr-2"
                        style={{ color: "#2c3e50" }}
                      />
                    )}
                    <CardTitle
                      className="text-base font-medium"
                      style={{ color: "#2c3e50" }}
                    >
                      {variant.name || `Variant ${index + 1}`}
                    </CardTitle>
                  </div>
                  <div className="flex items-center">
                    <span style={{ color: "#2c3e50" }}>
                      ${variant.price.toFixed(2)}
                    </span>
                    <span className="mx-2 text-sm" style={{ color: "#7f8c8d" }}>
                      |
                    </span>
                    <span style={{ color: "#2c3e50" }}>
                      {variant.inventory} in stock
                    </span>
                  </div>
                </CardHeader>

                {expandedVariants.has(index) && (
                  <CardContent
                    className="p-4 border-t"
                    style={{ borderColor: "#bdc3c7" }}
                  >
                    <div className="space-y-4">
                      {/* Option values section */}
                      <div>
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "#2c3e50" }}
                        >
                          Options
                        </h4>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                          {optionTypes.map((optionType) => (
                            <div key={optionType} className="space-y-2">
                              <Label style={{ color: "#2c3e50" }}>
                                {optionType}
                              </Label>
                              <Input
                                value={variant.options[optionType] || ""}
                                onChange={(e) =>
                                  updateVariant(index, "options", {
                                    [optionType]: e.target.value,
                                  })
                                }
                                placeholder={`Enter ${optionType.toLowerCase()}`}
                                className="border-2"
                                style={{
                                  borderColor: "#bdc3c7",
                                  color: "#2c3e50",
                                  backgroundColor: "white",
                                }}
                              />
                            </div>
                          ))}
                        </div>
                      </div>

                      {/* Basic info section */}
                      <div>
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "#2c3e50" }}
                        >
                          Variant Details
                        </h4>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>
                              Variant Name
                            </Label>
                            <Input
                              value={variant.name}
                              onChange={(e) =>
                                updateVariant(index, "name", e.target.value)
                              }
                              placeholder="Auto-generated from options if empty"
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>

                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>Price</Label>
                            <Input
                              type="number"
                              step="0.01"
                              value={variant.price}
                              onChange={(e) =>
                                updateVariant(
                                  index,
                                  "price",
                                  parseFloat(e.target.value) || 0
                                )
                              }
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>

                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>
                              Inventory
                            </Label>
                            <Input
                              type="number"
                              value={variant.inventory}
                              onChange={(e) =>
                                updateVariant(
                                  index,
                                  "inventory",
                                  parseInt(e.target.value) || 0
                                )
                              }
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>
                        </div>
                      </div>

                      {/* Extra fields */}
                      <div>
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "#2c3e50" }}
                        >
                          Additional Information
                        </h4>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>SKU</Label>
                            <Input
                              value={variant.sku || ""}
                              onChange={(e) =>
                                updateVariant(index, "sku", e.target.value)
                              }
                              placeholder="Optional"
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>

                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>Barcode</Label>
                            <Input
                              value={variant.barcode || ""}
                              onChange={(e) =>
                                updateVariant(index, "barcode", e.target.value)
                              }
                              placeholder="Optional"
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>
                        </div>
                      </div>
                    </div>

                    <div className="flex justify-end mt-4">
                      <Button
                        type="button"
                        variant="destructive"
                        onClick={() => removeVariant(index)}
                        style={{
                          backgroundColor: "#e74c3c",
                          color: "white",
                        }}
                      >
                        <Trash className="h-4 w-4 mr-2" />
                        Remove Variant
                      </Button>
                    </div>
                  </CardContent>
                )}
              </Card>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

File: ./src/components/admin/discount-form.tsx
// src/components/admin/discount-form.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import * as z from "zod";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

// Form schema
const discountSchema = z.object({
  productId: z.string().min(1, "Product is required"),
  percentage: z
    .number()
    .min(0.01, "Discount must be greater than 0")
    .max(100, "Discount cannot exceed 100%"),
  enabled: z.boolean().default(true),
  startDate: z.string().min(1, "Start date is required"),
  endDate: z.string().min(1, "End date is required"),
});

type DiscountFormValues = z.infer<typeof discountSchema>;

interface Product {
  id: string;
  name: string;
  price: number;
}

interface Discount {
  id: string;
  percentage: number;
  enabled: boolean;
  startDate: string | Date;
  endDate: string | Date;
  productId: string;
  product: {
    id: string;
    name: string;
    price: number;
  };
}

interface DiscountFormProps {
  discount?: Discount;
  products: Product[];
  shopId: string;
  isEditing?: boolean;
}

export default function DiscountForm({
  discount,
  products,
  shopId,
  isEditing = false,
}: DiscountFormProps) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(
    discount?.product || null
  );

  // Default values for the form
  const defaultValues: DiscountFormValues = discount
    ? {
        productId: discount.productId,
        percentage: discount.percentage,
        enabled: discount.enabled,
        startDate: new Date(discount.startDate).toISOString().split("T")[0],
        endDate: new Date(discount.endDate).toISOString().split("T")[0],
      }
    : {
        productId: "",
        percentage: 10,
        enabled: true,
        startDate: new Date().toISOString().split("T")[0],
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
          .toISOString()
          .split("T")[0], // Default to 30 days from now
      };

  // Create form
  const form = useForm<DiscountFormValues>({
    resolver: zodResolver(discountSchema),
    defaultValues,
  });

  // Watch the product ID to update the selected product
  const productId = form.watch("productId");
  const percentage = form.watch("percentage");

  // Update selected product when productId changes
  useEffect(() => {
    if (productId) {
      const product = products.find((p) => p.id === productId);
      if (product) {
        setSelectedProduct(product);
      }
    } else {
      setSelectedProduct(null);
    }
  }, [productId, products]);

  // Calculate discounted price for preview
  const getDiscountedPrice = (price: number, discountPercentage: number) => {
    if (!price || !discountPercentage) return price;
    const discount = (price * discountPercentage) / 100;
    return price - discount;
  };

  // Form submission handler
  const onSubmit = async (values: DiscountFormValues) => {
    setIsSubmitting(true);
    setSubmitError(null);

    try {
      const url = isEditing
        ? `/api/discounts/${discount?.id}`
        : "/api/discounts";
      const method = isEditing ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to save discount");
      }

      // Redirect to the discounts list page
      router.push("/admin/discounts");
      router.refresh();
    } catch (error: any) {
      console.error("Error saving discount:", error);
      setSubmitError(error.message || "An error occurred while saving");
      setIsSubmitting(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        {submitError && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{submitError}</AlertDescription>
          </Alert>
        )}

        <div className="grid gap-6 md:grid-cols-2">
          <Card className="border-0 shadow">
            <CardHeader
              style={{ backgroundColor: "#2c3e50" }}
              className="text-white rounded-t-lg"
            >
              <CardTitle className="text-xl font-medium">
                Discount Details
              </CardTitle>
              <CardDescription
                style={{ color: "#bdc3c7" }}
                className="mt-1 text-base"
              >
                Configure your product discount
              </CardDescription>
            </CardHeader>

            <CardContent className="pt-6 space-y-4 bg-white">
              <FormField
                control={form.control}
                name="productId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel
                      style={{ color: "#2c3e50" }}
                      className="font-medium text-base"
                    >
                      Product *
                    </FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                      disabled={isEditing} // Disable changing product in edit mode
                    >
                      <FormControl>
                        <SelectTrigger
                          className="border-2"
                          style={{
                            borderColor: "#bdc3c7",
                            color: "#2c3e50",
                            backgroundColor: "white",
                          }}
                        >
                          <SelectValue placeholder="Select a product" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {products.map((product) => (
                          <SelectItem key={product.id} value={product.id}>
                            {product.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormDescription style={{ color: "#7f8c8d" }}>
                      Select the product this discount applies to
                    </FormDescription>
                    <FormMessage className="text-red-600" />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="percentage"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel
                      style={{ color: "#2c3e50" }}
                      className="font-medium text-base"
                    >
                      Discount Percentage *
                    </FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.01"
                        min="0"
                        max="100"
                        className="border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                        {...field}
                        onChange={(e) => {
                          const value = parseFloat(e.target.value);
                          field.onChange(isNaN(value) ? 0 : value);
                        }}
                      />
                    </FormControl>
                    <FormDescription style={{ color: "#7f8c8d" }}>
                      Enter a discount percentage (0-100)
                    </FormDescription>
                    <FormMessage className="text-red-600" />
                  </FormItem>
                )}
              />

              <div className="grid grid-cols-2 gap-4">
                <FormField
                  control={form.control}
                  name="startDate"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel
                        style={{ color: "#2c3e50" }}
                        className="font-medium text-base"
                      >
                        Start Date *
                      </FormLabel>
                      <FormControl>
                        <Input
                          type="date"
                          className="border-2"
                          style={{
                            borderColor: "#bdc3c7",
                            color: "#2c3e50",
                            backgroundColor: "white",
                          }}
                          {...field}
                        />
                      </FormControl>
                      <FormMessage className="text-red-600" />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="endDate"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel
                        style={{ color: "#2c3e50" }}
                        className="font-medium text-base"
                      >
                        End Date *
                      </FormLabel>
                      <FormControl>
                        <Input
                          type="date"
                          className="border-2"
                          style={{
                            borderColor: "#bdc3c7",
                            color: "#2c3e50",
                            backgroundColor: "white",
                          }}
                          {...field}
                        />
                      </FormControl>
                      <FormMessage className="text-red-600" />
                    </FormItem>
                  )}
                />
              </div>

              <FormField
                control={form.control}
                name="enabled"
                render={({ field }) => (
                  <FormItem className="flex flex-row items-center justify-between rounded-lg border border-gray-200 p-4 shadow-sm">
                    <div className="space-y-0.5">
                      <FormLabel
                        style={{ color: "#2c3e50" }}
                        className="font-medium text-base"
                      >
                        Active
                      </FormLabel>
                      <FormDescription style={{ color: "#7f8c8d" }}>
                        Enable or disable this discount
                      </FormDescription>
                    </div>
                    <FormControl>
                      <Switch
                        checked={field.value}
                        onCheckedChange={field.onChange}
                      />
                    </FormControl>
                  </FormItem>
                )}
              />
            </CardContent>
          </Card>

          <div className="space-y-6">
            {selectedProduct && (
              <Card className="border border-gray-200 shadow-sm">
                <CardHeader className="bg-gray-50 border-b border-gray-200">
                  <CardTitle className="text-lg text-gray-800">
                    Discount Preview
                  </CardTitle>
                </CardHeader>
                <CardContent className="pt-6 bg-white">
                  <div className="space-y-4">
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Product
                      </h3>
                      <p className="text-lg font-medium text-gray-900">
                        {selectedProduct.name}
                      </p>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Original Price
                      </h3>
                      <p className="text-lg font-medium text-gray-900">
                        ${selectedProduct.price.toFixed(2)}
                      </p>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Discount
                      </h3>
                      <p className="text-lg font-medium text-orange-600">
                        {percentage}%
                      </p>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Discounted Price
                      </h3>
                      <p className="text-xl font-bold text-green-600">
                        $
                        {getDiscountedPrice(
                          selectedProduct.price,
                          percentage
                        ).toFixed(2)}
                      </p>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Savings
                      </h3>
                      <p className="text-lg font-medium text-red-600">
                        $
                        {(
                          selectedProduct.price -
                          getDiscountedPrice(selectedProduct.price, percentage)
                        ).toFixed(2)}
                      </p>
                    </div>
                  </div>
                </CardContent>
              </Card>
            )}

            {/* Help section */}
            <Card className="border border-blue-200 shadow-sm">
              <CardHeader className="bg-blue-50 border-b border-blue-200">
                <CardTitle className="text-lg text-blue-800">
                  About Discounts
                </CardTitle>
              </CardHeader>
              <CardContent className="pt-4 bg-white">
                <ul className="space-y-2 text-sm text-blue-700">
                  <li>• Discounts apply to specific products</li>
                  <li>• Set a percentage discount (e.g., 10% off)</li>
                  <li>• Define a date range for your promotion</li>
                  <li>• Enable/disable discounts without deleting them</li>
                  <li>• Create multiple discounts for different products</li>
                </ul>
              </CardContent>
            </Card>
          </div>
        </div>

        <div className="flex justify-end gap-4">
          <Button
            type="button"
            variant="outline"
            onClick={() => router.push("/admin/discounts")}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          >
            Cancel
          </Button>
          <Button
            type="submit"
            disabled={isSubmitting}
            style={{
              backgroundColor: "#16a085",
              color: "white",
            }}
            className="font-semibold hover:opacity-90"
          >
            {isSubmitting
              ? "Saving..."
              : isEditing
              ? "Update Discount"
              : "Create Discount"}
          </Button>
        </div>
      </form>
    </Form>
  );
}

File: ./src/components/admin/product-images-upload.tsx
// src/components/admin/product-images-upload.tsx
"use client";

import { useState, useEffect } from "react";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import {
  Trash,
  Upload,
  MoveUp,
  MoveDown,
  PlusCircle,
  ImageIcon,
} from "lucide-react";
import { cn } from "@/lib/utils";

interface ProductImagesUploadProps {
  existingImages: string[];
  onImagesChange: (images: string[]) => void;
}

// Use localStorage to persist image previews across tab changes
const LOCAL_STORAGE_KEY = "product_image_previews";

export default function ProductImagesUpload({
  existingImages = [],
  onImagesChange,
}: ProductImagesUploadProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [images, setImages] = useState<string[]>(existingImages || []);
  const [previewImages, setPreviewImages] = useState<Record<string, string>>(
    {}
  );

  // Load previews from localStorage on component mount
  useEffect(() => {
    try {
      const storedPreviews = localStorage.getItem(LOCAL_STORAGE_KEY);
      if (storedPreviews) {
        setPreviewImages(JSON.parse(storedPreviews));
      }
    } catch (error) {
      console.error("Error loading image previews from localStorage:", error);
    }
  }, []);

  // Save previews to localStorage whenever they change
  useEffect(() => {
    if (Object.keys(previewImages).length > 0) {
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(previewImages));
      } catch (error) {
        console.error("Error saving image previews to localStorage:", error);
      }
    }
  }, [previewImages]);

  // Initialize preview images from existing images and sync when props change
  useEffect(() => {
    setImages(existingImages || []);

    // Initialize preview images for existing images
    const initialPreviews: Record<string, string> = {};
    existingImages?.forEach((img: string) => {
      // Only create previews for items that appear to be URLs or paths
      // and aren't already in the preview cache
      if (
        (img.startsWith("http") || img.startsWith("/")) &&
        !previewImages[img]
      ) {
        initialPreviews[img] = img;
      }
    });

    if (Object.keys(initialPreviews).length > 0) {
      setPreviewImages((prev) => ({ ...prev, ...initialPreviews }));
    }
  }, [existingImages]);

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;

    setIsUploading(true);

    try {
      // In a real implementation, you would upload to your storage service
      // For now, we'll just create local object URLs as a placeholder
      const newImages = [...images];
      const newPreviews = { ...previewImages };

      for (let i = 0; i < e.target.files.length; i++) {
        const file = e.target.files[i];

        // Create a unique ID for this image
        const imageId = `image_${Date.now()}_${i}`;

        // Create a preview URL
        const imageUrl = URL.createObjectURL(file);
        newPreviews[imageId] = imageUrl;

        // In production, you would upload the file and get a permanent URL
        // For now, we'll use the imageId as a placeholder for the real URL
        newImages.push(imageId);
      }

      setImages(newImages);
      setPreviewImages(newPreviews);
      onImagesChange(newImages);
    } catch (error) {
      console.error("Error uploading images:", error);
    } finally {
      setIsUploading(false);
    }
  };

  const removeImage = (index: number) => {
    const newImages = [...images];
    const removedImageId = newImages.splice(index, 1)[0];

    // Clean up object URL to prevent memory leaks
    if (previewImages[removedImageId]) {
      // Only revoke URL if it's a blob URL (created by URL.createObjectURL)
      if (previewImages[removedImageId].startsWith("blob:")) {
        URL.revokeObjectURL(previewImages[removedImageId]);
      }

      const newPreviews = { ...previewImages };
      delete newPreviews[removedImageId];
      setPreviewImages(newPreviews);
    }

    setImages(newImages);
    onImagesChange(newImages);
  };

  const moveImage = (index: number, direction: "up" | "down") => {
    if (
      (direction === "up" && index === 0) ||
      (direction === "down" && index === images.length - 1)
    ) {
      return;
    }

    const newImages = [...images];
    const newIndex = direction === "up" ? index - 1 : index + 1;

    [newImages[index], newImages[newIndex]] = [
      newImages[newIndex],
      newImages[index],
    ];

    setImages(newImages);
    onImagesChange(newImages);
  };

  // Helper to get image src (either from preview or from the image URL itself)
  const getImageSrc = (imageId: string): string | null => {
    // Check if it's a preview image first
    if (previewImages[imageId]) {
      return previewImages[imageId];
    }

    // Handle existing images that could be URLs or paths
    if (imageId.startsWith("http") || imageId.startsWith("/")) {
      return imageId;
    }

    // Log for debugging
    console.log("No preview found for:", imageId);
    console.log("Current previews:", previewImages);

    // Fallback to a placeholder for invalid images
    return null;
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col items-center justify-center w-full">
        <label
          htmlFor="image-upload"
          className="flex flex-col items-center justify-center w-full h-40 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100 transition-colors"
        >
          <div className="flex flex-col items-center justify-center pt-5 pb-6">
            <Upload className="w-10 h-10 mb-3 text-gray-400" />
            <p className="mb-2 text-sm text-gray-600">
              <span className="font-semibold">Click to upload</span> or drag and
              drop
            </p>
            <p className="text-xs text-gray-500">PNG, JPG, GIF up to 10MB</p>
          </div>
          <Input
            id="image-upload"
            type="file"
            accept="image/*"
            multiple
            className="hidden"
            onChange={handleImageUpload}
            disabled={isUploading}
          />
        </label>
      </div>

      {isUploading && (
        <div className="flex items-center justify-center py-2">
          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-indigo-600 mr-2"></div>
          <p className="text-gray-600">Uploading images...</p>
        </div>
      )}

      {images.length > 0 && (
        <div>
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-md font-medium text-gray-700">
              Product Images ({images.length})
            </h3>
            {images.length > 1 && (
              <p className="text-sm text-gray-500">
                First image will be the main product image.
              </p>
            )}
          </div>

          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {images.map((image, index) => (
              <Card
                key={index}
                className="relative group border border-gray-200 rounded-lg overflow-hidden"
              >
                <div className="aspect-square relative overflow-hidden">
                  <div
                    className={cn(
                      "w-full h-full flex items-center justify-center bg-gray-100",
                      index === 0 && "border-2 border-indigo-500"
                    )}
                  >
                    {getImageSrc(image) ? (
                      <Image
                        src={getImageSrc(image) || "/placeholder.jpg"}
                        alt={`Product image ${index + 1}`}
                        fill
                        className="object-cover"
                      />
                    ) : (
                      <div className="flex flex-col items-center justify-center text-gray-400">
                        <ImageIcon className="w-12 h-12 mb-2" />
                        <span className="text-xs">Image Preview</span>
                      </div>
                    )}
                  </div>
                </div>

                <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 flex space-x-1 transition-opacity">
                  <Button
                    type="button"
                    variant="destructive"
                    size="icon"
                    className="h-7 w-7 bg-red-600 hover:bg-red-700"
                    onClick={() => removeImage(index)}
                  >
                    <Trash className="h-4 w-4" />
                  </Button>
                </div>

                <div className="absolute bottom-2 right-2 opacity-0 group-hover:opacity-100 flex space-x-1 transition-opacity">
                  <Button
                    type="button"
                    variant="secondary"
                    size="icon"
                    className="h-7 w-7 bg-white text-gray-800"
                    onClick={() => moveImage(index, "up")}
                    disabled={index === 0}
                  >
                    <MoveUp className="h-4 w-4" />
                  </Button>
                  <Button
                    type="button"
                    variant="secondary"
                    size="icon"
                    className="h-7 w-7 bg-white text-gray-800"
                    onClick={() => moveImage(index, "down")}
                    disabled={index === images.length - 1}
                  >
                    <MoveDown className="h-4 w-4" />
                  </Button>
                </div>
                <div className="absolute bottom-2 left-2 bg-black bg-opacity-70 text-white text-xs px-2 py-1 rounded">
                  {index === 0 ? "Main" : `Image ${index + 1}`}
                </div>
              </Card>
            ))}

            {/* Add image placeholder */}
            <Card
              className="border-2 border-dashed border-gray-300 rounded-lg overflow-hidden hover:border-gray-400 transition-colors cursor-pointer"
              onClick={() => document.getElementById("image-upload")?.click()}
            >
              <div className="aspect-square flex flex-col items-center justify-center bg-gray-50 p-4">
                <PlusCircle className="w-10 h-10 mb-2 text-gray-400" />
                <p className="text-sm text-gray-500 text-center">
                  Add more images
                </p>
              </div>
            </Card>
          </div>
        </div>
      )}
    </div>
  );
}

File: ./src/components/admin/discount-list-actions.tsx
// src/components/admin/discount-list-actions.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { MoreHorizontal, Edit, Trash } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface DiscountListActionsProps {
  discountId: string;
}

export default function DiscountListActions({
  discountId,
}: DiscountListActionsProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const router = useRouter();

  const handleDelete = async () => {
    try {
      const response = await fetch(`/api/discounts/${discountId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete discount");
      }

      // Refresh the page
      router.refresh();
    } catch (error) {
      console.error("Error deleting discount:", error);
    }
  };

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
            <span className="sr-only">Open menu</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem asChild>
            <Link
              href={`/admin/discounts/${discountId}`}
              className="flex items-center"
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit
            </Link>
          </DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            className="text-red-600 focus:text-red-600"
            onClick={() => setShowDeleteDialog(true)}
          >
            <Trash className="mr-2 h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              discount.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

File: ./src/components/admin/header.tsx
// src/components/admin/header.tsx
"use client";

import { useState } from "react";
import { useSession, signOut } from "next-auth/react";
import Link from "next/link";
import { Menu, X, Bell, User, LogOut } from "lucide-react";
import { Button } from "@/components/ui/button";

export default function AdminHeader() {
  const { data: session } = useSession();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  return (
    <header className="bg-white shadow-sm">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          <div className="flex">
            <div className="flex-shrink-0 flex items-center md:hidden">
              <button
                type="button"
                className="inline-flex items-center justify-center p-2 rounded-md text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500"
                onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
              >
                <span className="sr-only">Open main menu</span>
                {mobileMenuOpen ? (
                  <X className="block h-6 w-6" aria-hidden="true" />
                ) : (
                  <Menu className="block h-6 w-6" aria-hidden="true" />
                )}
              </button>
            </div>
            <div className="hidden md:ml-6 md:flex md:space-x-8">
              <Link
                href="/admin"
                className="border-transparent text-gray-900 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
              >
                {session?.user?.shopName || "Dashboard"}
              </Link>
              <Link
                href="/"
                className="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
              >
                View Shop
              </Link>
            </div>
          </div>
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <Button variant="outline" size="sm" className="mx-2">
                <Bell className="h-4 w-4 mr-1" />
                <span className="hidden md:inline">Notifications</span>
              </Button>
            </div>
            <div className="ml-3 relative flex items-center gap-2">
              <Button variant="ghost" size="sm" className="flex items-center ">
                <User className="h-4 w-4 mr-1" />
                <span className="text-sm text-gray-700 hover:text-red-600">
                  {session?.user?.name || "Profile"}
                </span>
              </Button>

              <Button
                variant="ghost"
                size="sm"
                className="flex items-center "
                onClick={() => signOut({ callbackUrl: "/login" })}
              >
                <LogOut className="h-4 w-4 mr-1" />
                <span className="text-sm text-gray-700 hover:text-red-600">
                  Logout
                </span>
              </Button>
            </div>
          </div>
        </div>
      </div>
    </header>
  );
}

File: ./src/components/admin/subscription-info.tsx
// src/components/admin/subscription-info.tsx
"use client";

import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { formatCurrency } from "@/lib/utils";
import {
  canViewSubscription,
  formatPlanName,
  formatSubscriptionPeriod,
} from "@/lib/permissions";
import {
  CalendarClock,
  CreditCard,
  AlertCircle,
  CheckCircle2,
} from "lucide-react";

interface SubscriptionData {
  id: string;
  planType: string;
  period: string;
  startDate: string;
  endDate: string;
  status: string;
  totalAmount: number;
  appliedDiscount: number;
  paidAmount: number;
  remainingAmount: number;
  daysRemaining: number;
  isActive: boolean;
}

interface SubscriptionInfoProps {
  subscription: SubscriptionData | null;
  loading?: boolean;
}

export function SubscriptionInfo({
  subscription,
  loading = false,
}: SubscriptionInfoProps) {
  const { data: session } = useSession();

  // Check if user can view subscription
  if (!canViewSubscription(session?.user)) {
    return null;
  }

  if (loading) {
    return (
      <Card className="border-l-4 border-l-blue-500 mb-6">
        <CardContent className="pt-6">
          <div className="h-20 flex items-center justify-center">
            <p className="text-sm text-gray-500">
              Loading subscription information...
            </p>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (!subscription) {
    return (
      <Card className="border-l-4 border-l-yellow-500 mb-6">
        <CardHeader>
          <CardTitle className="text-lg flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-yellow-500" />
            No Active Subscription
          </CardTitle>
          <CardDescription>
            Your shop doesn't have an active subscription plan
          </CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-gray-600">
            Contact platform admin to set up your subscription and unlock all
            features.
          </p>
        </CardContent>
        <CardFooter>
          <Button variant="outline" size="sm">
            Contact Support
          </Button>
        </CardFooter>
      </Card>
    );
  }

  // Get border color based on status
  const getBorderColor = () => {
    switch (subscription.status) {
      case "ACTIVE":
        return "border-l-green-500";
      case "PENDING":
        return "border-l-yellow-500";
      case "EXPIRED":
      case "CANCELED":
        return "border-l-red-500";
      case "TRIAL":
        return "border-l-blue-500";
      default:
        return "border-l-gray-500";
    }
  };

  return (
    <Card className={`border-l-4 ${getBorderColor()} mb-6`}>
      <CardHeader className="pb-2">
        <div className="flex justify-between items-start">
          <div>
            <CardTitle className="text-lg flex items-center gap-2">
              {subscription.isActive ? (
                <CheckCircle2 className="h-5 w-5 text-green-500" />
              ) : (
                <AlertCircle className="h-5 w-5 text-red-500" />
              )}
              {formatPlanName(subscription.planType)}
            </CardTitle>
            <CardDescription>
              {formatSubscriptionPeriod(subscription.period)} subscription
              {!subscription.isActive &&
                ` (${subscription.status.toLowerCase()})`}
            </CardDescription>
          </div>
          <div className="text-right">
            <p className="text-lg font-bold">
              {formatCurrency(subscription.totalAmount)}
            </p>
            {subscription.appliedDiscount > 0 && (
              <p className="text-xs text-green-600">
                {subscription.appliedDiscount}% discount applied
              </p>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
          <div className="space-y-2">
            <div className="flex items-center gap-2 text-sm">
              <CalendarClock className="h-4 w-4 text-gray-500" />
              <span className="text-gray-600">
                Valid from{" "}
                {new Date(subscription.startDate).toLocaleDateString()} to{" "}
                {new Date(subscription.endDate).toLocaleDateString()}
              </span>
            </div>
            <div className="flex items-center gap-2 text-sm">
              <CalendarClock className="h-4 w-4 text-gray-500" />
              <span className="text-gray-600">
                {subscription.daysRemaining} days remaining
              </span>
            </div>
          </div>
          <div className="space-y-2">
            <div className="flex items-center gap-2 text-sm">
              <CreditCard className="h-4 w-4 text-gray-500" />
              <span className="text-gray-600">
                Paid: {formatCurrency(subscription.paidAmount)}
              </span>
            </div>
            {subscription.remainingAmount > 0 && (
              <div className="flex items-center gap-2 text-sm">
                <CreditCard className="h-4 w-4 text-gray-500" />
                <span className="text-red-600">
                  Remaining: {formatCurrency(subscription.remainingAmount)}
                </span>
              </div>
            )}
          </div>
        </div>
      </CardContent>
      {subscription.remainingAmount > 0 && (
        <CardFooter className="pt-0">
          <Button size="sm">Make Payment</Button>
        </CardFooter>
      )}
    </Card>
  );
}

File: ./src/components/admin/pagination.tsx
// src/components/admin/pagination.tsx
"use client";

import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
} from "lucide-react";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
}

export default function Pagination({
  currentPage,
  totalPages,
  totalItems,
}: PaginationProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const navigateToPage = (page: number) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", page.toString());
    router.push(`${pathname}?${params.toString()}`);
  };

  return (
    <div className="flex justify-between items-center mt-4">
      <div className="text-sm text-gray-500">
        Showing {totalItems > 0 ? (currentPage - 1) * 10 + 1 : 0} to{" "}
        {Math.min(currentPage * 10, totalItems)} of {totalItems} items
      </div>
      <div className="flex space-x-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => navigateToPage(1)}
          disabled={currentPage <= 1}
        >
          <ChevronsLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => navigateToPage(currentPage - 1)}
          disabled={currentPage <= 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        <span className="px-3 py-1 text-sm">
          Page {currentPage} of {totalPages || 1}
        </span>

        <Button
          variant="outline"
          size="sm"
          onClick={() => navigateToPage(currentPage + 1)}
          disabled={currentPage >= totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => navigateToPage(totalPages)}
          disabled={currentPage >= totalPages}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

File: ./src/components/admin/product-filters.tsx
// src/components/admin/product-filters.tsx - Add lowStockThreshold prop
"use client";

import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Search, X } from "lucide-react";

interface Category {
  id: string;
  name: string;
}

interface ProductFiltersProps {
  categories: Category[];
  currentFilters: {
    search?: string;
    category?: string;
    inStock?: string;
    lowStock?: string;
    page?: string;
    perPage?: string;
    sort?: string;
    order?: string;
  };
  lowStockThreshold: number;
}

export default function ProductFilters({
  categories,
  currentFilters,
  lowStockThreshold,
}: ProductFiltersProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  // Local state for filters to enable live updates
  const [searchTerm, setSearchTerm] = useState(currentFilters.search || "");
  const [selectedCategory, setSelectedCategory] = useState(
    currentFilters.category || "all"
  );
  const [isInStock, setIsInStock] = useState(currentFilters.inStock === "true");
  const [isLowStock, setIsLowStock] = useState(
    currentFilters.lowStock === "true"
  );

  // Update URL when filters change
  const updateFilters = () => {
    const params = new URLSearchParams(searchParams.toString());

    // Reset to page 1 when filters change
    params.set("page", "1");

    // Update search parameter
    if (searchTerm) {
      params.set("search", searchTerm);
    } else {
      params.delete("search");
    }

    // Update category parameter
    if (selectedCategory && selectedCategory !== "all") {
      params.set("category", selectedCategory);
    } else {
      params.delete("category");
    }

    // Update stock filters
    if (isInStock) {
      params.set("inStock", "true");
    } else {
      params.delete("inStock");
    }

    if (isLowStock) {
      params.set("lowStock", "true");
    } else {
      params.delete("lowStock");
    }

    router.push(`${pathname}?${params.toString()}`);
  };

  // Live search with debounce
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      updateFilters();
    }, 500); // 500ms debounce

    return () => clearTimeout(timeoutId);
  }, [searchTerm, selectedCategory, isInStock, isLowStock]);

  // Clear all filters
  const clearFilters = () => {
    setSearchTerm("");
    setSelectedCategory("all");
    setIsInStock(false);
    setIsLowStock(false);

    router.push(pathname);
  };

  return (
    <div className="bg-gray-50 p-4 rounded-lg shadow-sm mb-6 space-y-4 border border-gray-200">
      <div className="flex flex-col md:flex-row gap-4">
        <div className="flex-1">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <Input
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              placeholder="Search products..."
              className="pl-10 max-w-sm text-gray-800"
            />
            {searchTerm && (
              <button
                onClick={() => setSearchTerm("")}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
        </div>

        <div className="flex gap-4 flex-wrap items-center">
          <div className="w-48">
            <Select
              value={selectedCategory}
              onValueChange={setSelectedCategory}
            >
              <SelectTrigger className="text-gray-800">
                <SelectValue placeholder="All Categories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Categories</SelectItem>
                {categories.map((category) => (
                  <SelectItem key={category.id} value={category.id}>
                    {category.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex items-center gap-2">
            <Checkbox
              id="inStock"
              checked={isInStock}
              onCheckedChange={(checked) => setIsInStock(checked === true)}
            />
            <Label htmlFor="inStock" className="text-gray-800">
              In Stock
            </Label>
          </div>

          <div className="flex items-center gap-2">
            <Checkbox
              id="lowStock"
              checked={isLowStock}
              onCheckedChange={(checked) => setIsLowStock(checked === true)}
            />
            <Label htmlFor="lowStock" className="text-gray-800">
              Low Stock (≤{lowStockThreshold})
            </Label>
          </div>

          {(searchTerm ||
            selectedCategory !== "all" ||
            isInStock ||
            isLowStock) && (
            <Button
              variant="outline"
              size="sm"
              onClick={clearFilters}
              className="text-gray-700"
            >
              <X className="h-4 w-4 mr-2" />
              Clear Filters
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

File: ./src/components/admin/discount-code-list-actions.tsx
// src/components/admin/discount-code-list-actions.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { MoreHorizontal, Edit, Trash, Copy } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useToast } from "@/components/ui/use-toast";

interface DiscountCodeListActionsProps {
  discountCodeId: string;
}

export default function DiscountCodeListActions({
  discountCodeId,
}: DiscountCodeListActionsProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleDelete = async () => {
    try {
      const response = await fetch(`/api/discount-codes/${discountCodeId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete discount code");
      }

      // Refresh the page
      router.refresh();
    } catch (error) {
      console.error("Error deleting discount code:", error);
      toast({
        title: "Error",
        description: "Failed to delete discount code",
        variant: "destructive",
      });
    }
  };

  const handleCopyCode = async () => {
    try {
      // Get the discount code
      const response = await fetch(`/api/discount-codes/${discountCodeId}`);
      if (!response.ok) {
        throw new Error("Failed to fetch discount code");
      }

      const data = await response.json();

      // Copy the code to clipboard
      await navigator.clipboard.writeText(data.code);

      toast({
        title: "Code Copied",
        description: `"${data.code}" copied to clipboard.`,
      });
    } catch (error) {
      console.error("Error copying discount code:", error);
      toast({
        title: "Error",
        description: "Failed to copy code to clipboard",
        variant: "destructive",
      });
    }
  };

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
            <span className="sr-only">Open menu</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem asChild>
            <Link
              href={`/admin/discount-codes/${discountCodeId}`}
              className="flex items-center"
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit
            </Link>
          </DropdownMenuItem>
          <DropdownMenuItem
            className="flex items-center cursor-pointer"
            onClick={handleCopyCode}
          >
            <Copy className="mr-2 h-4 w-4" />
            Copy Code
          </DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            className="text-red-600 focus:text-red-600 cursor-pointer"
            onClick={() => setShowDeleteDialog(true)}
          >
            <Trash className="mr-2 h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              discount code.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

File: ./src/components/admin/sidebar.tsx
// src/components/admin/sidebar.tsx
"use client";

import { usePathname } from "next/navigation";
import Link from "next/link";
import { useSession } from "next-auth/react";
import {
  Home,
  Package,
  List,
  ShoppingCart,
  Users,
  Settings,
  BarChart,
  Bell,
  Tag,
  Ticket,
} from "lucide-react";
import { cn } from "@/lib/utils";

export default function AdminSidebar() {
  const pathname = usePathname();
  const { data: session } = useSession();
  const isPremium = session?.user?.planType === "PREMIUM";
  const isAdvanced = session?.user?.planType === "ADVANCED" || isPremium;

  const navigation = [
    { name: "Dashboard", href: "/admin", icon: Home },
    { name: "Products", href: "/admin/products", icon: Package },
    { name: "Categories", href: "/admin/categories", icon: List },
    { name: "Discounts", href: "/admin/discounts", icon: Tag },
    { name: "Discount Codes", href: "/admin/discount-codes", icon: Ticket },
    { name: "Orders", href: "/admin/orders", icon: ShoppingCart },
    { name: "Customers", href: "/admin/customers", icon: Users },
    { name: "Settings", href: "/admin/settings", icon: Settings },
    // Advanced & Premium features
    {
      name: "Analytics",
      href: "/admin/analytics",
      icon: BarChart,
      requiredPlan: "ADVANCED",
    },
    {
      name: "Notifications",
      href: "/admin/notifications",
      icon: Bell,
      requiredPlan: "ADVANCED",
    },
  ];

  return (
    <div className="hidden md:flex md:flex-shrink-0">
      <div className="flex flex-col w-64">
        <div className="flex flex-col h-0 flex-1 bg-gray-800">
          <div className="flex-1 flex flex-col pt-5 pb-4 overflow-y-auto">
            <div className="flex items-center flex-shrink-0 px-4">
              <span className="text-xl font-bold text-gray-200">
                {session?.user?.shopName || "Shop Admin"}
              </span>
            </div>
            <nav className="mt-5 flex-1 px-2 space-y-1">
              {navigation.map((item) => {
                // Skip if this feature requires a higher plan than the user has
                if (item.requiredPlan === "ADVANCED" && !isAdvanced)
                  return null;
                if (item.requiredPlan === "PREMIUM" && !isPremium) return null;

                return (
                  <Link
                    key={item.name}
                    href={item.href}
                    className={cn(
                      pathname === item.href
                        ? "bg-gray-900 text-white"
                        : "text-gray-300 hover:bg-gray-700 hover:text-white",
                      "group flex items-center px-2 py-2 text-sm font-medium rounded-md"
                    )}
                  >
                    <item.icon
                      className={cn(
                        pathname === item.href
                          ? "text-gray-300"
                          : "text-gray-400 group-hover:text-gray-300",
                        "mr-3 flex-shrink-0 h-6 w-6"
                      )}
                      aria-hidden="true"
                    />
                    {item.name}
                  </Link>
                );
              })}
            </nav>
          </div>
        </div>
      </div>
    </div>
  );
}

File: ./src/components/admin/product-form.tsx
// src/components/admin/product-form.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import { Form } from "@/components/ui/form";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { AlertCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { slugify } from "@/lib/utils";

// Import form types
import {
  ProductFormProps,
  ProductFormValues,
  productSchema,
} from "./product-form-types";

// Import tab components
import BasicInfoTab from "./product-tabs/basic-info-tab";
import ImagesTab from "./product-tabs/images-tab";
import PricingTab from "./product-tabs/pricing-tab";
import CategoriesTab from "./product-tabs/categories-tab";
import VariantsTab from "./product-tabs/variants-tab";
import CustomFieldsTab from "./product-tabs/custom-fields-tab";
import OrderHistoryTab from "./product-tabs/order-history-tab";

export default function ProductForm({
  product,
  categories,
  customFields = [],
  shopId,
  isEditing = false,
}: ProductFormProps) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState("basic");
  const [formState, setFormState] = useState<ProductFormValues | null>(null);

  // Transform custom field values from the product data format to form format
  const transformCustomFieldsForForm = () => {
    if (!product || !product.customFields) return [];

    return product.customFields.map((cf: any) => ({
      id: cf.id,
      customFieldId: cf.customFieldId,
      value: cf.value,
    }));
  };

  // Default values
  const defaultValues: ProductFormValues = product
    ? {
        name: product.name,
        description: product.description || "",
        price: product.price,
        // No compareAtPrice anymore
        cost: product.cost || null,
        barcode: product.barcode || "",
        inventory: product.inventory,
        tva: product.tva || 19,
        categoryIds: product.categories?.map((c: any) => c.id) || [],
        images: product.images || [],
        variants:
          product.variants?.map((v: any) => ({
            id: v.id,
            name: v.name,
            price: v.price,
            inventory: v.inventory,
            barcode: v.barcode || "",
            options: v.options,
          })) || [],
        expiryDate: product.expiryDate
          ? new Date(product.expiryDate).toISOString().split("T")[0]
          : null,
        customFieldValues: transformCustomFieldsForForm(),
      }
    : {
        name: "",
        description: "",
        price: 0,
        cost: null,
        inventory: 0,
        tva: 19,
        categoryIds: [],
        images: [],
        variants: [],
        expiryDate: null,
        customFieldValues: [],
      };

  // Create form with schema validation and default values
  const form = useForm<ProductFormValues>({
    resolver: zodResolver(productSchema),
    defaultValues,
  });

  // Initialize and store the form state with defaults
  useEffect(() => {
    setFormState(defaultValues);
  }, []);

  // Sync form state when switching tabs
  useEffect(() => {
    if (formState) {
      Object.keys(formState).forEach((key) => {
        form.setValue(key as any, formState[key as keyof ProductFormValues]);
      });
    }
  }, [formState]);

  // Handle tab change - preserve form state between tabs
  const handleTabChange = (value: string) => {
    // Get current values
    const currentValues = form.getValues();

    // Merge with existing state to keep all fields
    setFormState((prev) => ({
      ...(prev || defaultValues),
      ...currentValues,
    }));

    // Update the active tab
    setActiveTab(value);
  };

  // Update form state for a specific field
  const updateFormState = (field: string, value: any) => {
    setFormState((prev) => ({
      ...(prev || defaultValues),
      [field]: value,
    }));
  };

  // Handle form submission
  const onSubmit = async (values: ProductFormValues) => {
    setIsSubmitting(true);
    setSubmitError(null);

    try {
      // Auto-generate the slug
      const slug = slugify(values.name);

      const url = isEditing ? `/api/products/${product.id}` : "/api/products";
      const method = isEditing ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          ...values,
          slug,
          shopId,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to save product");
      }

      router.push(`/admin/products`);
      router.refresh();
    } catch (error: any) {
      console.error("Error saving product:", error);
      setSubmitError(
        error.message || "An error occurred while saving the product"
      );
      setIsSubmitting(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        {submitError && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{submitError}</AlertDescription>
          </Alert>
        )}
        {/* Global styles for input fields */}
        <style jsx global>{`
          input,
          textarea,
          select {
            color: #2c3e50 !important;
            background-color: white !important;
          }

          input::placeholder,
          textarea::placeholder {
            color: #bdc3c7 !important;
          }
        `}</style>
        {/* Tabs */}
        <Tabs
          value={activeTab}
          onValueChange={handleTabChange}
          className="w-full"
        >
          <TabsList className="mb-6 bg-gray-100 p-1 rounded-lg">
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "basic" ? "#2c3e50" : "transparent",
                color: activeTab === "basic" ? "white" : "#bdc3c7",
              }}
              value="basic"
            >
              Basic Info
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "images" ? "#2c3e50" : "transparent",
                color: activeTab === "images" ? "white" : "#bdc3c7",
              }}
              value="images"
            >
              Images
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "pricing" ? "#2c3e50" : "transparent",
                color: activeTab === "pricing" ? "white" : "#bdc3c7",
              }}
              value="pricing"
            >
              Pricing & Inventory
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "categories" ? "#2c3e50" : "transparent",
                color: activeTab === "categories" ? "white" : "#bdc3c7",
              }}
              value="categories"
            >
              Categories
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "variants" ? "#2c3e50" : "transparent",
                color: activeTab === "variants" ? "white" : "#bdc3c7",
              }}
              value="variants"
            >
              Variants
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "custom-fields" ? "#2c3e50" : "transparent",
                color: activeTab === "custom-fields" ? "white" : "#bdc3c7",
              }}
              value="custom-fields"
            >
              Custom Fields
            </TabsTrigger>
            {/* Only show order history tab when editing */}
            {isEditing && product?.id && (
              <TabsTrigger
                className="rounded-md"
                style={{
                  backgroundColor:
                    activeTab === "order-history" ? "#2c3e50" : "transparent",
                  color: activeTab === "order-history" ? "white" : "#bdc3c7",
                }}
                value="order-history"
              >
                Order History
              </TabsTrigger>
            )}
          </TabsList>

          {/* Tab Contents */}
          <TabsContent value="basic" className="space-y-4">
            <BasicInfoTab control={form.control} />
          </TabsContent>

          <TabsContent value="images">
            <ImagesTab
              control={form.control}
              onFormStateChange={updateFormState}
            />
          </TabsContent>

          <TabsContent value="pricing" className="space-y-4">
            <PricingTab control={form.control} />
          </TabsContent>

          <TabsContent value="categories">
            <CategoriesTab
              control={form.control}
              categories={categories}
              onFormStateChange={updateFormState}
            />
          </TabsContent>

          <TabsContent value="variants">
            <VariantsTab
              control={form.control}
              onFormStateChange={updateFormState}
            />
          </TabsContent>

          <TabsContent value="custom-fields">
            <CustomFieldsTab
              control={form.control}
              customFields={customFields}
              onFormStateChange={updateFormState}
            />
          </TabsContent>

          {/* Only render order history content when editing */}
          {isEditing && product?.id && (
            <TabsContent value="order-history">
              <OrderHistoryTab productId={product.id} />
            </TabsContent>
          )}
        </Tabs>
        <div className="flex justify-end gap-4">
          <Button
            type="button"
            variant="outline"
            onClick={() => router.push("/admin/products")}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          >
            Cancel
          </Button>
          <Button
            type="submit"
            disabled={isSubmitting}
            style={{
              backgroundColor: "#16a085",
              color: "white",
            }}
            className="font-semibold hover:opacity-90"
          >
            {isSubmitting
              ? "Saving..."
              : isEditing
              ? "Update Product"
              : "Create Product"}
          </Button>
        </div>
      </form>
    </Form>
  );
}

File: ./src/components/admin/product-pagination.tsx
// src/components/admin/product-pagination.tsx
"use client";

import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
} from "lucide-react";

interface ProductPaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
}

export default function ProductPagination({
  currentPage,
  totalPages,
  totalItems,
}: ProductPaginationProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const navigateToPage = (page: number) => {
    const params = new URLSearchParams(searchParams);
    params.set("page", page.toString());
    router.push(`${pathname}?${params.toString()}`);
  };

  const changePerPage = (perPage: string) => {
    const params = new URLSearchParams(searchParams);
    params.set("perPage", perPage);
    params.set("page", "1"); // Reset to page 1 when changing items per page
    router.push(`${pathname}?${params.toString()}`);
  };

  // Calculate start and end item numbers
  const perPage = parseInt(searchParams.get("perPage") || "10");
  const startItem = (currentPage - 1) * perPage + 1;
  const endItem = Math.min(currentPage * perPage, totalItems);

  return (
    <div className="flex flex-col sm:flex-row items-center justify-between gap-4 mt-4">
      <div className="text-sm text-gray-500">
        Showing {totalItems > 0 ? startItem : 0} to {endItem} of {totalItems}{" "}
        products
      </div>

      <div className="flex items-center gap-2">
        <div className="flex items-center">
          <Button
            variant="outline"
            size="icon"
            onClick={() => navigateToPage(1)}
            disabled={currentPage <= 1}
          >
            <ChevronsLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="icon"
            onClick={() => navigateToPage(currentPage - 1)}
            disabled={currentPage <= 1}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>

          <span className="mx-2 text-sm">
            Page {currentPage} of {totalPages || 1}
          </span>

          <Button
            variant="outline"
            size="icon"
            onClick={() => navigateToPage(currentPage + 1)}
            disabled={currentPage >= totalPages}
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="icon"
            onClick={() => navigateToPage(totalPages)}
            disabled={currentPage >= totalPages}
          >
            <ChevronsRight className="h-4 w-4" />
          </Button>
        </div>

        <Select
          value={searchParams.get("perPage") || "10"}
          onValueChange={changePerPage}
        >
          <SelectTrigger className="w-[120px]">
            <SelectValue placeholder="10 per page" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="10">10 per page</SelectItem>
            <SelectItem value="25">25 per page</SelectItem>
            <SelectItem value="50">50 per page</SelectItem>
            <SelectItem value="100">100 per page</SelectItem>
          </SelectContent>
        </Select>
      </div>
    </div>
  );
}

File: ./src/components/admin/product-tabs/variants-tab.tsx
// src/components/admin/product-tabs/variants-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FormControl, FormField, FormItem } from "@/components/ui/form";
import ProductVariantsForm from "../product-variants-form";
import { ProductFormValues } from "../product-form-types";

interface VariantsTabProps {
  control: Control<ProductFormValues>;
  onFormStateChange: (field: string, value: any) => void;
}

export default function VariantsTab({
  control,
  onFormStateChange,
}: VariantsTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Product Variants</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Add variants for different options like size, color, etc.
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        <FormField
          control={control}
          name="variants"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <ProductVariantsForm
                  variants={field.value}
                  onChange={(variants) => {
                    field.onChange(variants);
                    // Update the parent form state
                    onFormStateChange("variants", variants);
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/categories-tab.tsx
// src/components/admin/product-tabs/categories-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FormControl, FormField, FormItem } from "@/components/ui/form";
import ProductCategoriesSelect from "../product-categories-select";
import { ProductFormValues } from "../product-form-types";

interface CategoriesTabProps {
  control: Control<ProductFormValues>;
  categories: {
    id: string;
    name: string;
    level: number;
    parentId?: string | null;
  }[];
  onFormStateChange: (field: string, value: any) => void;
}

export default function CategoriesTab({
  control,
  categories,
  onFormStateChange,
}: CategoriesTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Categories</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Assign this product to categories to help customers find it.
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        <FormField
          control={control}
          name="categoryIds"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <ProductCategoriesSelect
                  categories={categories}
                  selectedCategories={field.value}
                  onChange={(selected) => {
                    field.onChange(selected);
                    // Update the parent form state
                    onFormStateChange("categoryIds", selected);
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/images-tab.tsx
// src/components/admin/product-tabs/images-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FormControl, FormField, FormItem } from "@/components/ui/form";
import ProductImagesUpload from "../product-images-upload";
import { ProductFormValues } from "../product-form-types";

interface ImagesTabProps {
  control: Control<ProductFormValues>;
  onFormStateChange: (field: string, value: any) => void;
}

export default function ImagesTab({
  control,
  onFormStateChange,
}: ImagesTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Product Images</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Upload images for your product. The first image will be used as the
          main image.
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        <FormField
          control={control}
          name="images"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <ProductImagesUpload
                  existingImages={field.value}
                  onImagesChange={(images) => {
                    field.onChange(images);
                    // Update the parent form state to preserve changes between tabs
                    onFormStateChange("images", images);
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/discount-codes-tab.tsx
// src/components/admin/product-tabs/discount-codes-tab.tsx
import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Plus, Trash, Edit, SearchIcon } from "lucide-react";
import { DiscountCode } from "../product-form-types";

interface DiscountCodesTabProps {
  shopId: string;
  productId?: string;
}

interface User {
  id: string;
  name: string;
  email: string;
}

export default function DiscountCodesTab({
  shopId,
  productId,
}: DiscountCodesTabProps) {
  const [discountCodes, setDiscountCodes] = useState<DiscountCode[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [editingCode, setEditingCode] = useState<DiscountCode | null>(null);
  const [users, setUsers] = useState<User[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);
  const [currentCode, setCurrentCode] = useState<Partial<DiscountCode>>({
    code: "",
    percentage: 10,
    shopId,
    productId: productId || null,
    userId: null,
    startDate: new Date().toISOString().split("T")[0],
    endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      .toISOString()
      .split("T")[0],
    isActive: true,
  });

  useEffect(() => {
    fetchDiscountCodes();
  }, [shopId, productId]);

  const fetchDiscountCodes = async () => {
    try {
      setIsLoading(true);
      let url = `/api/discount-codes?shopId=${shopId}`;
      if (productId) {
        url += `&productId=${productId}`;
      }

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        setDiscountCodes(data);
      }
    } catch (error) {
      console.error("Error fetching discount codes:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const searchUsers = async () => {
    if (!searchQuery || searchQuery.length < 2) return;

    try {
      setIsSearching(true);
      const response = await fetch(
        `/api/users/search?q=${searchQuery}&shopId=${shopId}`
      );
      if (response.ok) {
        const data = await response.json();
        setUsers(data);
      }
    } catch (error) {
      console.error("Error searching users:", error);
    } finally {
      setIsSearching(false);
    }
  };

  const handleCreateDiscountCode = async () => {
    try {
      const payload = {
        ...currentCode,
        shopId,
      };

      const url = editingCode
        ? `/api/discount-codes/${editingCode.id}`
        : "/api/discount-codes";
      const method = editingCode ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        await fetchDiscountCodes();
        setIsDialogOpen(false);
        resetCodeForm();
      }
    } catch (error) {
      console.error("Error saving discount code:", error);
    }
  };

  const handleDeleteDiscountCode = async (id: string) => {
    try {
      const response = await fetch(`/api/discount-codes/${id}`, {
        method: "DELETE",
      });

      if (response.ok) {
        await fetchDiscountCodes();
        setDeleteDialogOpen(false);
      }
    } catch (error) {
      console.error("Error deleting discount code:", error);
    }
  };

  const resetCodeForm = () => {
    setEditingCode(null);
    setCurrentCode({
      code: "",
      percentage: 10,
      shopId,
      productId: productId || null,
      userId: null,
      startDate: new Date().toISOString().split("T")[0],
      endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
        .toISOString()
        .split("T")[0],
      isActive: true,
    });
    setUsers([]);
    setSearchQuery("");
  };

  const handleEditDiscountCode = (code: DiscountCode) => {
    setEditingCode(code);
    setCurrentCode({
      ...code,
      startDate: new Date(code.startDate).toISOString().split("T")[0],
      endDate: new Date(code.endDate).toISOString().split("T")[0],
    });
    setIsDialogOpen(true);
  };

  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleDateString();
  };

  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Discount Codes</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Create promotional codes for your customers
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        {isLoading ? (
          <div className="text-center py-4">Loading discount codes...</div>
        ) : (
          <>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
                Available Discount Codes
              </h3>
              <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
                <DialogTrigger asChild>
                  <Button
                    style={{
                      backgroundColor: "#16a085",
                      color: "white",
                    }}
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Add Discount Code
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>
                      {editingCode
                        ? "Edit Discount Code"
                        : "Add New Discount Code"}
                    </DialogTitle>
                    <DialogDescription>
                      Create a discount code for customers to use at checkout.
                    </DialogDescription>
                  </DialogHeader>

                  <div className="grid gap-4 py-4">
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="code"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Code
                      </Label>
                      <Input
                        id="code"
                        value={currentCode.code}
                        onChange={(e) =>
                          setCurrentCode({
                            ...currentCode,
                            code: e.target.value.toUpperCase(),
                          })
                        }
                        placeholder="e.g., SUMMER10"
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="percentage"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Discount %
                      </Label>
                      <Input
                        id="percentage"
                        type="number"
                        min="1"
                        max="100"
                        value={currentCode.percentage}
                        onChange={(e) =>
                          setCurrentCode({
                            ...currentCode,
                            percentage: Number(e.target.value),
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>

                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="productSelection"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        For Product
                      </Label>
                      <div className="col-span-3">
                        <Select
                          value={currentCode.productId ? "specific" : "all"}
                          onValueChange={(value) =>
                            setCurrentCode({
                              ...currentCode,
                              productId:
                                value === "specific" ? productId : null,
                            })
                          }
                        >
                          <SelectTrigger
                            className="border-2"
                            style={{
                              borderColor: "#bdc3c7",
                              color: "#2c3e50",
                            }}
                          >
                            <SelectValue placeholder="Select product scope" />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="all">All Products</SelectItem>
                            {productId && (
                              <SelectItem value="specific">
                                This Product Only
                              </SelectItem>
                            )}
                          </SelectContent>
                        </Select>
                      </div>
                    </div>

                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="userSearch"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        For User
                      </Label>
                      <div className="col-span-3 space-y-2">
                        <div className="flex gap-2">
                          <Input
                            id="userSearch"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="Search by name or email"
                            className="flex-1 border-2"
                            style={{
                              borderColor: "#bdc3c7",
                              color: "#2c3e50",
                              backgroundColor: "white",
                            }}
                          />
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={searchUsers}
                            disabled={isSearching}
                            className="border-2"
                            style={{
                              borderColor: "#bdc3c7",
                              color: "#2c3e50",
                            }}
                          >
                            <SearchIcon className="h-4 w-4" />
                          </Button>
                        </div>

                        {users.length > 0 && (
                          <Select
                            value={currentCode.userId || ""}
                            onValueChange={(value) =>
                              setCurrentCode({
                                ...currentCode,
                                userId: value === "" ? null : value,
                              })
                            }
                          >
                            <SelectTrigger
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                              }}
                            >
                              <SelectValue placeholder="Select user" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="">All Users</SelectItem>
                              {users.map((user) => (
                                <SelectItem key={user.id} value={user.id}>
                                  {user.name} ({user.email})
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                        )}

                        {!users.length && !isSearching && (
                          <p className="text-xs text-gray-500">
                            Search for a user or leave blank for all users
                          </p>
                        )}

                        {isSearching && (
                          <p className="text-xs text-gray-500">Searching...</p>
                        )}
                      </div>
                    </div>

                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="startDate"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Start Date
                      </Label>
                      <Input
                        id="startDate"
                        type="date"
                        value={currentCode.startDate}
                        onChange={(e) =>
                          setCurrentCode({
                            ...currentCode,
                            startDate: e.target.value,
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="endDate"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        End Date
                      </Label>
                      <Input
                        id="endDate"
                        type="date"
                        value={currentCode.endDate}
                        onChange={(e) =>
                          setCurrentCode({
                            ...currentCode,
                            endDate: e.target.value,
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="isActive"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Active
                      </Label>
                      <div className="flex items-center space-x-2 col-span-3">
                        <Switch
                          id="isActive"
                          checked={currentCode.isActive}
                          onCheckedChange={(checked) =>
                            setCurrentCode({
                              ...currentCode,
                              isActive: checked,
                            })
                          }
                        />
                        <Label htmlFor="isActive" style={{ color: "#2c3e50" }}>
                          {currentCode.isActive ? "Active" : "Inactive"}
                        </Label>
                      </div>
                    </div>
                  </div>

                  <DialogFooter>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => {
                        setIsDialogOpen(false);
                        resetCodeForm();
                      }}
                      style={{
                        borderColor: "#bdc3c7",
                        color: "#2c3e50",
                      }}
                    >
                      Cancel
                    </Button>
                    <Button
                      type="button"
                      onClick={handleCreateDiscountCode}
                      style={{
                        backgroundColor: "#16a085",
                        color: "white",
                      }}
                    >
                      {editingCode ? "Update" : "Create"}
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            </div>

            {discountCodes.length === 0 ? (
              <div className="bg-gray-50 border border-gray-200 rounded-lg p-6 text-center">
                <p style={{ color: "#2c3e50" }}>
                  No discount codes have been created yet.
                </p>
                <Button
                  onClick={() => setIsDialogOpen(true)}
                  type="button"
                  className="mt-4"
                  style={{
                    backgroundColor: "#16a085",
                    color: "white",
                  }}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Create Your First Discount Code
                </Button>
              </div>
            ) : (
              <div className="border border-gray-200 rounded-lg overflow-auto">
                <Table>
                  <TableHeader className="bg-gray-50">
                    <TableRow>
                      <TableHead>Code</TableHead>
                      <TableHead>Discount</TableHead>
                      <TableHead>Valid Period</TableHead>
                      <TableHead>Applied To</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead className="text-right">Actions</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {discountCodes.map((code) => (
                      <TableRow key={code.id}>
                        <TableCell className="font-medium uppercase">
                          {code.code}
                        </TableCell>
                        <TableCell>{code.percentage}% OFF</TableCell>
                        <TableCell>
                          {formatDate(code.startDate)} -{" "}
                          {formatDate(code.endDate)}
                        </TableCell>
                        <TableCell>
                          {code.productId ? "Specific Product" : "All Products"}
                          <br />
                          {code.userId ? "Specific User" : "All Users"}
                        </TableCell>
                        <TableCell>
                          <span
                            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                              code.isActive
                                ? "bg-green-100 text-green-800"
                                : "bg-gray-100 text-gray-800"
                            }`}
                          >
                            {code.isActive ? "Active" : "Inactive"}
                          </span>
                        </TableCell>
                        <TableCell className="text-right">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleEditDiscountCode(code)}
                            className="text-gray-500 hover:text-indigo-600"
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                          <AlertDialog
                            open={deleteDialogOpen}
                            onOpenChange={setDeleteDialogOpen}
                          >
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                setEditingCode(code);
                                setDeleteDialogOpen(true);
                              }}
                              className="text-gray-500 hover:text-red-600"
                            >
                              <Trash className="h-4 w-4" />
                            </Button>
                            <AlertDialogContent>
                              <AlertDialogHeader>
                                <AlertDialogTitle>
                                  Delete Discount Code
                                </AlertDialogTitle>
                                <AlertDialogDescription>
                                  Are you sure you want to delete this discount
                                  code? This action cannot be undone.
                                </AlertDialogDescription>
                              </AlertDialogHeader>
                              <AlertDialogFooter>
                                <AlertDialogCancel>Cancel</AlertDialogCancel>
                                <AlertDialogAction
                                  onClick={() => {
                                    if (editingCode?.id) {
                                      handleDeleteDiscountCode(editingCode.id);
                                    }
                                  }}
                                  className="bg-red-600 hover:bg-red-700"
                                >
                                  Delete
                                </AlertDialogAction>
                              </AlertDialogFooter>
                            </AlertDialogContent>
                          </AlertDialog>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/pricing-tab.tsx
// src/components/admin/product-tabs/pricing-tab.tsx
import { Control, useWatch } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { ProductFormValues } from "../product-form-types";
import { useMemo } from "react";

interface PricingTabProps {
  control: Control<ProductFormValues>;
}

export default function PricingTab({ control }: PricingTabProps) {
  // Watch values to calculate profit in real-time
  const price = useWatch({ control, name: "price" }) || 0;
  const cost = useWatch({ control, name: "cost" }) || 0;
  const tva = useWatch({ control, name: "tva" }) || 19;

  // Calculate profit and profit percentage
  const profitDetails = useMemo(() => {
    if (!cost || cost <= 0) {
      return { profit: price, profitPercentage: 0 };
    }

    // Calculate cost with TVA
    const costWithTVA = cost * (1 + tva / 100);

    // Calculate profit (price - (cost + TVA))
    const profit = price - costWithTVA;

    // Calculate profit percentage
    const profitPercentage = (profit / costWithTVA) * 100;

    return {
      profit: profit.toFixed(2),
      profitPercentage: profitPercentage.toFixed(2),
    };
  }, [price, cost, tva]);

  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">
          Pricing & Inventory
        </CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Set prices and manage inventory for this product.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6 pt-6 bg-white">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <FormField
            control={control}
            name="price"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  Selling Price *
                </FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    step="0.01"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    {...field}
                    value={field.value || ""}
                  />
                </FormControl>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />

          <FormField
            control={control}
            name="cost"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  Cost Price
                </FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    step="0.01"
                    placeholder="Product cost price"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    value={field.value === null ? "" : field.value}
                    onChange={(e) =>
                      field.onChange(
                        e.target.value ? Number(e.target.value) : null
                      )
                    }
                  />
                </FormControl>
                <FormDescription style={{ color: "#7f8c8d" }}>
                  Product cost (not visible to customers)
                </FormDescription>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />

          <FormField
            control={control}
            name="tva"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  TVA (%)
                </FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    min="0"
                    max="100"
                    step="0.1"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    {...field}
                    value={field.value || ""}
                  />
                </FormControl>
                <FormDescription style={{ color: "#7f8c8d" }}>
                  Tax percentage (default: 19%)
                </FormDescription>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />
        </div>

        {/* Profit Information */}
        {cost > 0 && (
          <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
            <h3
              className="text-md font-medium mb-2"
              style={{ color: "#2c3e50" }}
            >
              Profit Calculation
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <p className="text-sm text-gray-600">Profit per unit:</p>
                <p
                  className="text-lg font-semibold"
                  style={{
                    color:
                      Number(profitDetails.profit) > 0 ? "#16a085" : "#e74c3c",
                  }}
                >
                  ${profitDetails.profit}
                </p>
              </div>
              <div>
                <p className="text-sm text-gray-600">Profit margin:</p>
                <p
                  className="text-lg font-semibold"
                  style={{
                    color:
                      Number(profitDetails.profitPercentage) > 0
                        ? "#16a085"
                        : "#e74c3c",
                  }}
                >
                  {profitDetails.profitPercentage}%
                </p>
              </div>
            </div>
          </div>
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <FormField
            control={control}
            name="inventory"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  Inventory Quantity
                </FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    {...field}
                    value={field.value || ""}
                  />
                </FormControl>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />

          <FormField
            control={control}
            name="barcode"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  Barcode
                </FormLabel>
                <FormControl>
                  <Input
                    placeholder="Optional"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    {...field}
                    value={field.value || ""}
                  />
                </FormControl>
                <FormDescription style={{ color: "#7f8c8d" }}>
                  UPC, EAN, ISBN, etc.
                </FormDescription>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />
        </div>

        <FormField
          control={control}
          name="expiryDate"
          render={({ field }) => (
            <FormItem>
              <FormLabel
                style={{ color: "#2c3e50" }}
                className="font-medium text-base"
              >
                Expiry Date
              </FormLabel>
              <FormControl>
                <Input
                  type="date"
                  className="border-2"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#2c3e50",
                    backgroundColor: "white",
                  }}
                  value={field.value || ""}
                  onChange={field.onChange}
                />
              </FormControl>
              <FormDescription style={{ color: "#7f8c8d" }}>
                Set if product has an expiration date
              </FormDescription>
              <FormMessage className="text-red-600" />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/custom-fields-tab.tsx
// src/components/admin/product-tabs/custom-fields-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FormControl, FormField, FormItem } from "@/components/ui/form";
import ProductCustomFields from "../product-custom-fields";
import { ProductFormValues } from "../product-form-types";

interface CustomField {
  id: string;
  name: string;
  type: string;
  required: boolean;
}

interface CustomFieldsTabProps {
  control: Control<ProductFormValues>;
  customFields: CustomField[];
  onFormStateChange: (field: string, value: any) => void;
}

export default function CustomFieldsTab({
  control,
  customFields,
  onFormStateChange,
}: CustomFieldsTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Custom Fields</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Add additional information specific to this product.
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        <FormField
          control={control}
          name="customFieldValues"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <ProductCustomFields
                  customFieldValues={field.value}
                  availableCustomFields={customFields}
                  onChange={(fields) => {
                    field.onChange(fields);
                    // Update the parent form state
                    onFormStateChange("customFieldValues", fields);
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/basic-info-tab.tsx
// src/components/admin/product-tabs/basic-info-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { ProductFormValues } from "../product-form-types";

interface BasicInfoTabProps {
  control: Control<ProductFormValues>;
}

export default function BasicInfoTab({ control }: BasicInfoTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Basic Information</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Enter the basic details about your product.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6 pt-6 bg-white">
        <FormField
          control={control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel
                style={{ color: "#2c3e50" }}
                className="font-medium text-base"
              >
                Product Name *
              </FormLabel>
              <FormControl>
                <Input
                  placeholder="Enter product name"
                  className="border-2"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#2c3e50",
                    backgroundColor: "white",
                  }}
                  {...field}
                />
              </FormControl>
              <FormDescription style={{ color: "#7f8c8d" }}>
                A slug will be automatically generated from the name.
              </FormDescription>
              <FormMessage className="text-red-600" />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel
                style={{ color: "#2c3e50" }}
                className="font-medium text-base"
              >
                Description
              </FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Enter product description"
                  className="min-h-[150px] border-2"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#2c3e50",
                    backgroundColor: "white",
                  }}
                  {...field}
                />
              </FormControl>
              <FormMessage className="text-red-600" />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/discounts-tab.tsx
// src/components/admin/product-tabs/discounts-tab.tsx
import { useState, useEffect } from "react";
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Plus, Trash, Edit } from "lucide-react";
import { ProductFormValues, Discount } from "../product-form-types";

interface DiscountsTabProps {
  control: Control<ProductFormValues>;
  productId?: string;
  shopId: string;
}

export default function DiscountsTab({
  control,
  productId,
  shopId,
}: DiscountsTabProps) {
  const [discounts, setDiscounts] = useState<Discount[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [editingDiscount, setEditingDiscount] = useState<Discount | null>(null);
  const [currentDiscount, setCurrentDiscount] = useState<Discount>({
    percentage: 0,
    enabled: true,
    startDate: new Date().toISOString().split("T")[0],
    endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      .toISOString()
      .split("T")[0],
    productId: productId || "",
  });

  // Fetch discounts for this product when component mounts
  useEffect(() => {
    if (productId) {
      fetchDiscounts();
    } else {
      setIsLoading(false);
    }
  }, [productId]);

  const fetchDiscounts = async () => {
    try {
      setIsLoading(true);
      const response = await fetch(`/api/discounts?productId=${productId}`);
      if (response.ok) {
        const data = await response.json();
        setDiscounts(data);
      }
    } catch (error) {
      console.error("Error fetching discounts:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleCreateDiscount = async () => {
    try {
      const payload = {
        ...currentDiscount,
        productId,
      };

      const url = editingDiscount
        ? `/api/discounts/${editingDiscount.id}`
        : "/api/discounts";
      const method = editingDiscount ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        await fetchDiscounts();
        setIsDialogOpen(false);
        resetDiscountForm();
      }
    } catch (error) {
      console.error("Error saving discount:", error);
    }
  };

  const handleDeleteDiscount = async (id: string) => {
    try {
      const response = await fetch(`/api/discounts/${id}`, {
        method: "DELETE",
      });

      if (response.ok) {
        await fetchDiscounts();
        setDeleteDialogOpen(false);
      }
    } catch (error) {
      console.error("Error deleting discount:", error);
    }
  };

  const resetDiscountForm = () => {
    setEditingDiscount(null);
    setCurrentDiscount({
      percentage: 0,
      enabled: true,
      startDate: new Date().toISOString().split("T")[0],
      endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
        .toISOString()
        .split("T")[0],
      productId: productId || "",
    });
  };

  const handleEditDiscount = (discount: Discount) => {
    setEditingDiscount(discount);
    setCurrentDiscount({
      ...discount,
      startDate: new Date(discount.startDate).toISOString().split("T")[0],
      endDate: new Date(discount.endDate).toISOString().split("T")[0],
    });
    setIsDialogOpen(true);
  };

  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleDateString();
  };

  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Product Discounts</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Manage price discounts for this product
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        {isLoading ? (
          <div className="text-center py-4">Loading discounts...</div>
        ) : (
          <>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
                Active Discounts
              </h3>
              <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
                <DialogTrigger asChild>
                  <Button
                    style={{
                      backgroundColor: "#16a085",
                      color: "white",
                    }}
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Add Discount
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>
                      {editingDiscount ? "Edit Discount" : "Add New Discount"}
                    </DialogTitle>
                    <DialogDescription>
                      Create a discount for this product.
                    </DialogDescription>
                  </DialogHeader>

                  <div className="grid gap-4 py-4">
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="percentage"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Discount %
                      </Label>
                      <Input
                        id="percentage"
                        type="number"
                        step="0.01"
                        min="0"
                        max="100"
                        value={currentDiscount.percentage}
                        onChange={(e) =>
                          setCurrentDiscount({
                            ...currentDiscount,
                            percentage: Number(e.target.value),
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="startDate"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Start Date
                      </Label>
                      <Input
                        id="startDate"
                        type="date"
                        value={currentDiscount.startDate}
                        onChange={(e) =>
                          setCurrentDiscount({
                            ...currentDiscount,
                            startDate: e.target.value,
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="endDate"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        End Date
                      </Label>
                      <Input
                        id="endDate"
                        type="date"
                        value={currentDiscount.endDate}
                        onChange={(e) =>
                          setCurrentDiscount({
                            ...currentDiscount,
                            endDate: e.target.value,
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="enabled"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Enabled
                      </Label>
                      <div className="flex items-center space-x-2 col-span-3">
                        <Switch
                          id="enabled"
                          checked={currentDiscount.enabled}
                          onCheckedChange={(checked) =>
                            setCurrentDiscount({
                              ...currentDiscount,
                              enabled: checked,
                            })
                          }
                        />
                        <Label htmlFor="enabled" style={{ color: "#2c3e50" }}>
                          {currentDiscount.enabled ? "Active" : "Inactive"}
                        </Label>
                      </div>
                    </div>
                  </div>

                  <DialogFooter>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => {
                        setIsDialogOpen(false);
                        resetDiscountForm();
                      }}
                      style={{
                        borderColor: "#bdc3c7",
                        color: "#2c3e50",
                      }}
                    >
                      Cancel
                    </Button>
                    <Button
                      type="button"
                      onClick={handleCreateDiscount}
                      style={{
                        backgroundColor: "#16a085",
                        color: "white",
                      }}
                    >
                      {editingDiscount ? "Update" : "Create"}
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            </div>

            {discounts.length === 0 ? (
              <div className="bg-gray-50 border border-gray-200 rounded-lg p-6 text-center">
                <p style={{ color: "#2c3e50" }}>
                  No discounts have been created for this product yet.
                </p>
                <Button
                  onClick={() => setIsDialogOpen(true)}
                  type="button"
                  className="mt-4"
                  style={{
                    backgroundColor: "#16a085",
                    color: "white",
                  }}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Add Your First Discount
                </Button>
              </div>
            ) : (
              <div className="border border-gray-200 rounded-lg overflow-auto">
                <Table>
                  <TableHeader className="bg-gray-50">
                    <TableRow>
                      <TableHead>Percentage</TableHead>
                      <TableHead>Start Date</TableHead>
                      <TableHead>End Date</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead className="text-right">Actions</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {discounts.map((discount) => (
                      <TableRow key={discount.id}>
                        <TableCell className="font-medium">
                          {discount.percentage}%
                        </TableCell>
                        <TableCell>{formatDate(discount.startDate)}</TableCell>
                        <TableCell>{formatDate(discount.endDate)}</TableCell>
                        <TableCell>
                          <span
                            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                              discount.enabled
                                ? "bg-green-100 text-green-800"
                                : "bg-gray-100 text-gray-800"
                            }`}
                          >
                            {discount.enabled ? "Active" : "Inactive"}
                          </span>
                        </TableCell>
                        <TableCell className="text-right">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleEditDiscount(discount)}
                            className="text-gray-500 hover:text-indigo-600"
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                          <AlertDialog
                            open={deleteDialogOpen}
                            onOpenChange={setDeleteDialogOpen}
                          >
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                setEditingDiscount(discount);
                                setDeleteDialogOpen(true);
                              }}
                              className="text-gray-500 hover:text-red-600"
                            >
                              <Trash className="h-4 w-4" />
                            </Button>
                            <AlertDialogContent>
                              <AlertDialogHeader>
                                <AlertDialogTitle>
                                  Delete Discount
                                </AlertDialogTitle>
                                <AlertDialogDescription>
                                  Are you sure you want to delete this discount?
                                  This action cannot be undone.
                                </AlertDialogDescription>
                              </AlertDialogHeader>
                              <AlertDialogFooter>
                                <AlertDialogCancel>Cancel</AlertDialogCancel>
                                <AlertDialogAction
                                  onClick={() => {
                                    if (editingDiscount?.id) {
                                      handleDeleteDiscount(editingDiscount.id);
                                    }
                                  }}
                                  className="bg-red-600 hover:bg-red-700"
                                >
                                  Delete
                                </AlertDialogAction>
                              </AlertDialogFooter>
                            </AlertDialogContent>
                          </AlertDialog>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/order-history-tab.tsx
// src/components/admin/product-tabs/order-history-tab.tsx
import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { formatCurrency, formatDate } from "@/lib/utils";
import {
  ShoppingBag,
  AlertCircle,
  Clock,
  ChevronRight,
  Info,
} from "lucide-react";
import Link from "next/link";
import Image from "next/image";

interface OrderHistoryTabProps {
  productId: string;
}

interface OrderItem {
  id: string;
  orderId: string;
  quantity: number;
  unitPrice: number;
  total: number;
  productName: string;
  productSku: string | null;
  productBarcode: string | null;
  productDescription: string | null;
  productOptions: any | null;
  productImage: string | null;
  productTva: number;
  discountPercentage: number | null;
  discountAmount: number | null;
  discountCode: string | null;
  originalPrice: number | null;
  createdAt: string;
  order: {
    orderNumber: string;
    status: string;
    createdAt: string;
    user: {
      name: string;
      email: string;
    };
  };
}

export default function OrderHistoryTab({ productId }: OrderHistoryTabProps) {
  const [orderItems, setOrderItems] = useState<OrderItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedOrderItem, setSelectedOrderItem] = useState<OrderItem | null>(
    null
  );

  useEffect(() => {
    const fetchOrderHistory = async () => {
      try {
        setIsLoading(true);
        const response = await fetch(`/api/products/${productId}/orders`);

        if (!response.ok) {
          throw new Error("Failed to fetch order history");
        }

        const data = await response.json();
        setOrderItems(data);
      } catch (error) {
        console.error("Error fetching order history:", error);
        setError("Failed to load order history");
      } finally {
        setIsLoading(false);
      }
    };

    if (productId) {
      fetchOrderHistory();
    }
  }, [productId]);

  const renderOrderStatus = (status: string) => {
    switch (status) {
      case "PENDING":
        return (
          <Badge
            variant="outline"
            className="bg-blue-50 text-blue-700 border-blue-200"
          >
            Pending
          </Badge>
        );
      case "PROCESSING":
        return (
          <Badge
            variant="outline"
            className="bg-amber-50 text-amber-700 border-amber-200"
          >
            Processing
          </Badge>
        );
      case "SHIPPED":
        return (
          <Badge
            variant="outline"
            className="bg-purple-50 text-purple-700 border-purple-200"
          >
            Shipped
          </Badge>
        );
      case "DELIVERED":
        return <Badge variant="success">Delivered</Badge>;
      case "CANCELLED":
        return <Badge variant="destructive">Cancelled</Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  if (isLoading) {
    return (
      <Card>
        <CardContent className="pt-6">
          <div className="flex items-center justify-center py-6">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-indigo-600"></div>
            <span className="ml-2 text-gray-600">Loading order history...</span>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardContent className="pt-6">
          <div className="bg-red-50 border border-red-200 rounded-lg p-4 flex items-start">
            <AlertCircle className="text-red-500 mt-0.5 mr-2 h-5 w-5" />
            <div>
              <h3 className="text-red-800 font-medium">Error</h3>
              <p className="text-red-700 text-sm">{error}</p>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (orderItems.length === 0) {
    return (
      <Card>
        <CardContent className="pt-6">
          <div className="bg-gray-50 border border-gray-200 rounded-lg p-6 text-center">
            <ShoppingBag className="h-8 w-8 text-gray-400 mb-2 mx-auto" />
            <h3 className="text-gray-700 font-medium mb-1">No Order History</h3>
            <p className="text-gray-500 text-sm">
              This product hasn't been purchased yet.
            </p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader className="bg-gray-50 border-b border-gray-200">
        <div className="flex items-center justify-between">
          <div>
            <CardTitle className="text-gray-800">Order History</CardTitle>
            <CardDescription>
              Displaying how this product appeared in orders
            </CardDescription>
          </div>
          <Badge variant="info" className="text-sm">
            {orderItems.length} Orders
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="pt-4">
        <div className="space-y-4">
          {/* Order selection list */}
          <div className="border border-gray-200 rounded-lg divide-y divide-gray-200">
            {orderItems.slice(0, 5).map((item) => (
              <div
                key={item.id}
                className={`p-4 hover:bg-gray-50 cursor-pointer ${
                  selectedOrderItem?.id === item.id
                    ? "bg-indigo-50 border-l-4 border-indigo-500"
                    : ""
                }`}
                onClick={() => setSelectedOrderItem(item)}
              >
                <div className="flex justify-between items-start">
                  <div>
                    <div className="flex items-center">
                      <Link
                        href={`/admin/orders/${item.orderId}`}
                        className="text-indigo-600 hover:underline font-medium"
                      >
                        {item.order.orderNumber}
                      </Link>
                      <span className="mx-2 text-gray-400">•</span>
                      {renderOrderStatus(item.order.status)}
                    </div>
                    <div className="text-sm text-gray-500 mt-1 flex items-center">
                      <Clock className="h-3 w-3 mr-1" />
                      {formatDate(item.order.createdAt)}
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="font-medium text-gray-800">
                      {item.quantity} × {formatCurrency(item.unitPrice)}
                    </div>
                    <div className="text-sm text-gray-500">
                      Total: {formatCurrency(item.total)}
                    </div>
                  </div>
                </div>
              </div>
            ))}
            {orderItems.length > 5 && (
              <div className="p-4 text-center">
                <Link
                  href={`/admin/products/${productId}/orders`}
                  className="text-indigo-600 hover:underline text-sm flex items-center justify-center"
                >
                  View all {orderItems.length} orders
                  <ChevronRight className="h-4 w-4 ml-1" />
                </Link>
              </div>
            )}
          </div>

          {/* Selected order item details */}
          {selectedOrderItem && (
            <div className="bg-gray-50 border border-gray-200 rounded-lg p-4 mt-4">
              <h3 className="text-gray-800 font-medium mb-3">
                Order Item Details (as captured at order time)
              </h3>

              <div className="grid md:grid-cols-2 gap-4">
                <div>
                  <h4 className="text-sm font-medium text-gray-500 mb-2">
                    Product Information
                  </h4>
                  <div className="bg-white p-4 rounded border border-gray-200">
                    <div className="flex items-start mb-3">
                      {selectedOrderItem.productImage ? (
                        <div className="w-16 h-16 rounded bg-gray-200 mr-3 overflow-hidden">
                          <Image
                            src={selectedOrderItem.productImage}
                            alt={selectedOrderItem.productName}
                            width={64}
                            height={64}
                            className="object-cover"
                          />
                        </div>
                      ) : (
                        <div className="w-16 h-16 rounded bg-gray-200 mr-3 flex items-center justify-center text-gray-400 text-xs">
                          No image
                        </div>
                      )}
                      <div>
                        <div className="font-medium text-gray-800">
                          {selectedOrderItem.productName}
                        </div>
                        {selectedOrderItem.productDescription && (
                          <div className="text-sm text-gray-600 mt-1">
                            {selectedOrderItem.productDescription}
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="grid grid-cols-2 gap-2 text-sm">
                      {selectedOrderItem.productSku && (
                        <div>
                          <span className="text-gray-500">SKU:</span>{" "}
                          {selectedOrderItem.productSku}
                        </div>
                      )}
                      {selectedOrderItem.productBarcode && (
                        <div>
                          <span className="text-gray-500">Barcode:</span>{" "}
                          {selectedOrderItem.productBarcode}
                        </div>
                      )}
                      {selectedOrderItem.productOptions &&
                        Object.keys(selectedOrderItem.productOptions).length >
                          0 && (
                          <div className="col-span-2 mt-2">
                            <span className="text-gray-500">Options:</span>
                            <div className="flex flex-wrap gap-1 mt-1">
                              {Object.entries(
                                selectedOrderItem.productOptions
                              ).map(([key, value]) => (
                                <Badge
                                  key={key}
                                  variant="outline"
                                  className="bg-gray-50"
                                >
                                  {key}: {String(value)}
                                </Badge>
                              ))}
                            </div>
                          </div>
                        )}
                    </div>
                  </div>
                </div>

                <div>
                  <h4 className="text-sm font-medium text-gray-500 mb-2">
                    Pricing Information
                  </h4>
                  <div className="bg-white p-4 rounded border border-gray-200">
                    <div className="space-y-2">
                      <div className="flex justify-between">
                        <span className="text-gray-600">Unit Price:</span>
                        <span className="font-medium">
                          {formatCurrency(selectedOrderItem.unitPrice)}
                        </span>
                      </div>

                      {selectedOrderItem.originalPrice &&
                        selectedOrderItem.originalPrice >
                          selectedOrderItem.unitPrice && (
                          <div className="flex justify-between">
                            <span className="text-gray-600">
                              Original Price:
                            </span>
                            <span className="line-through text-gray-500">
                              {formatCurrency(selectedOrderItem.originalPrice)}
                            </span>
                          </div>
                        )}

                      {selectedOrderItem.discountPercentage && (
                        <div className="flex justify-between">
                          <span className="text-gray-600">Discount:</span>
                          <span className="text-green-600">
                            {selectedOrderItem.discountPercentage}%
                            {selectedOrderItem.discountCode &&
                              ` (${selectedOrderItem.discountCode})`}
                          </span>
                        </div>
                      )}

                      <div className="flex justify-between">
                        <span className="text-gray-600">Quantity:</span>
                        <span>{selectedOrderItem.quantity}</span>
                      </div>

                      <div className="flex justify-between">
                        <span className="text-gray-600">
                          TVA ({selectedOrderItem.productTva}%):
                        </span>
                        <span>
                          {formatCurrency(
                            (selectedOrderItem.total *
                              selectedOrderItem.productTva) /
                              100
                          )}
                        </span>
                      </div>

                      <div className="border-t border-gray-200 pt-2 mt-2">
                        <div className="flex justify-between font-medium">
                          <span className="text-gray-800">Total:</span>
                          <span className="text-gray-800">
                            {formatCurrency(selectedOrderItem.total)}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="flex items-center mt-3 p-2 bg-blue-50 border border-blue-200 rounded text-sm text-blue-700">
                    <Info className="h-4 w-4 mr-2 text-blue-500 flex-shrink-0" />
                    <span>
                      This information is preserved exactly as it was when the
                      order was placed, even if the product details were later
                      changed or the product was deleted.
                    </span>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-custom-fields.tsx
// src/components/admin/product-custom-fields.tsx
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Trash, Plus, ChevronDown, ChevronUp, Calendar } from "lucide-react";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";

// Structure matching the database model
interface CustomFieldValue {
  id?: string;
  customFieldId: string; // This links to the custom field definition
  value: string;
}

// This represents the available custom fields from the database
interface AvailableCustomField {
  id: string;
  name: string;
  type: string;
  required: boolean;
}

interface ProductCustomFieldsProps {
  customFieldValues: CustomFieldValue[];
  availableCustomFields: AvailableCustomField[];
  onChange: (fields: CustomFieldValue[]) => void;
}

export default function ProductCustomFields({
  customFieldValues = [],
  availableCustomFields = [],
  onChange,
}: ProductCustomFieldsProps) {
  const [localFieldValues, setLocalFieldValues] =
    useState<CustomFieldValue[]>(customFieldValues);
  const [selectedCustomFieldId, setSelectedCustomFieldId] =
    useState<string>("");
  const [isOpen, setIsOpen] = useState<boolean>(true); // Open by default

  // Sync with parent component when props change
  useEffect(() => {
    setLocalFieldValues(customFieldValues);
  }, [customFieldValues]);

  // Add a custom field value
  const handleAddCustomField = () => {
    if (!selectedCustomFieldId) return;

    // Check if field already exists for this product
    if (
      localFieldValues.some(
        (field) => field.customFieldId === selectedCustomFieldId
      )
    ) {
      // Could show an error "This field has already been added"
      return;
    }

    const newFieldValues = [
      ...localFieldValues,
      {
        customFieldId: selectedCustomFieldId,
        value: "",
      },
    ];

    setLocalFieldValues(newFieldValues);
    onChange(newFieldValues);
    setSelectedCustomFieldId("");
  };

  // Update a custom field value
  const handleUpdateField = (index: number, value: string) => {
    const updatedFields = [...localFieldValues];
    updatedFields[index].value = value;
    setLocalFieldValues(updatedFields);
    onChange(updatedFields);
  };

  // Remove a custom field value
  const handleRemoveField = (index: number) => {
    const updatedFields = [...localFieldValues];
    updatedFields.splice(index, 1);
    setLocalFieldValues(updatedFields);
    onChange(updatedFields);
  };

  // Filter out already added custom fields
  const availableFieldsToAdd = availableCustomFields.filter(
    (field) =>
      !localFieldValues.some((value) => value.customFieldId === field.id)
  );

  // Get field name from ID
  const getFieldNameById = (fieldId: string): string => {
    const field = availableCustomFields.find((f) => f.id === fieldId);
    return field ? field.name : "Unknown Field";
  };

  // Get field type from ID
  const getFieldTypeById = (fieldId: string): string => {
    const field = availableCustomFields.find((f) => f.id === fieldId);
    return field ? field.type : "TEXT";
  };

  // Is field required
  const isFieldRequired = (fieldId: string): boolean => {
    const field = availableCustomFields.find((f) => f.id === fieldId);
    return field ? field.required : false;
  };

  // Render custom field input based on type
  const renderFieldInput = (
    fieldType: string,
    value: string,
    onChange: (value: string) => void
  ) => {
    switch (fieldType) {
      case "TEXT":
        return (
          <Input
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          />
        );

      case "TEXTAREA":
        return (
          <Textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="border-2 min-h-[100px]"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          />
        );

      case "NUMBER":
        return (
          <Input
            type="number"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          />
        );

      case "DATE":
        return (
          <div className="relative">
            <Input
              type="date"
              value={value}
              onChange={(e) => onChange(e.target.value)}
              className="border-2"
              style={{
                borderColor: "#bdc3c7",
                color: "#2c3e50",
                backgroundColor: "white",
              }}
            />
            <Calendar className="absolute right-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400 pointer-events-none" />
          </div>
        );

      case "BOOLEAN":
        return (
          <div className="flex items-center space-x-2">
            <Switch
              checked={value === "true"}
              onCheckedChange={(checked) =>
                onChange(checked ? "true" : "false")
              }
            />
            <span className="text-sm text-gray-500">
              {value === "true" ? "Yes" : "No"}
            </span>
          </div>
        );

      case "SELECT":
        // In a real app, you'd get options from somewhere
        const options = ["Option 1", "Option 2", "Option 3"];
        return (
          <Select value={value} onValueChange={onChange}>
            <SelectTrigger
              className="border-2"
              style={{ borderColor: "#bdc3c7", color: "#2c3e50" }}
            >
              <SelectValue placeholder="Select an option" />
            </SelectTrigger>
            <SelectContent>
              {options.map((option) => (
                <SelectItem key={option} value={option}>
                  {option}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      default:
        return (
          <Input
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          />
        );
    }
  };

  return (
    <div className="space-y-6">
      {/* Custom field values list */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
          Product Custom Fields
        </h3>

        {localFieldValues.length === 0 ? (
          <div className="bg-gray-50 border border-gray-200 rounded-lg p-6 text-center">
            <p style={{ color: "#2c3e50" }}>
              No custom fields added yet. Add fields below to provide additional
              product information.
            </p>
            <Button
              onClick={() => setIsOpen(true)}
              type="button"
              className="mt-4"
              style={{
                backgroundColor: "#16a085",
                color: "white",
              }}
            >
              <Plus className="h-4 w-4 mr-2" />
              Add Custom Field
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {localFieldValues.map((fieldValue, index) => (
              <Card
                key={index}
                className="border rounded-lg overflow-hidden"
                style={{ borderColor: "#bdc3c7" }}
              >
                <CardHeader className="p-4 pb-2 flex flex-row items-center justify-between">
                  <div>
                    <CardTitle
                      className="text-base font-medium"
                      style={{ color: "#2c3e50" }}
                    >
                      {getFieldNameById(fieldValue.customFieldId)}
                      {isFieldRequired(fieldValue.customFieldId) && (
                        <span className="text-red-500 ml-1">*</span>
                      )}
                    </CardTitle>
                    <CardDescription>
                      <span
                        className="text-xs px-2 py-0.5 rounded-full"
                        style={{
                          backgroundColor: "#f5f7fa",
                          color: "#2c3e50",
                        }}
                      >
                        {getFieldTypeById(fieldValue.customFieldId)}
                      </span>
                    </CardDescription>
                  </div>
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={() => handleRemoveField(index)}
                    className="text-gray-500 hover:text-red-600"
                  >
                    <Trash className="h-4 w-4" />
                  </Button>
                </CardHeader>
                <CardContent className="p-4 pt-2">
                  {renderFieldInput(
                    getFieldTypeById(fieldValue.customFieldId),
                    fieldValue.value,
                    (value) => handleUpdateField(index, value)
                  )}
                </CardContent>
              </Card>
            ))}
          </div>
        )}
      </div>

      {/* Add custom fields section */}
      <Collapsible
        open={isOpen || localFieldValues.length === 0}
        onOpenChange={setIsOpen}
        className="border rounded-lg overflow-hidden"
        style={{ borderColor: "#bdc3c7" }}
      >
        <CollapsibleTrigger asChild>
          <div className="p-4 flex items-center justify-between cursor-pointer bg-gray-50">
            <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
              Add Custom Field
            </h3>
            {isOpen ? (
              <ChevronUp className="h-5 w-5 text-gray-500" />
            ) : (
              <ChevronDown className="h-5 w-5 text-gray-500" />
            )}
          </div>
        </CollapsibleTrigger>
        <CollapsibleContent
          className="p-4 border-t"
          style={{ borderColor: "#bdc3c7" }}
        >
          {availableFieldsToAdd.length === 0 ? (
            <div className="text-center p-4 bg-gray-50 rounded-lg">
              <p className="text-sm" style={{ color: "#7f8c8d" }}>
                All available custom fields have been added to this product.
                Create more custom fields in the Custom Fields section.
              </p>
              <Button
                type="button"
                className="mt-3"
                variant="outline"
                onClick={() => window.open("/admin/custom-fields", "_blank")}
                style={{
                  borderColor: "#16a085",
                  color: "#16a085",
                }}
              >
                <Plus className="h-4 w-4 mr-2" />
                Manage Custom Fields
              </Button>
            </div>
          ) : (
            <div className="space-y-4">
              <p className="text-sm" style={{ color: "#7f8c8d" }}>
                Select a custom field to add additional information to this
                product.
              </p>
              <div className="flex gap-2">
                <div className="flex-1">
                  <Select
                    value={selectedCustomFieldId}
                    onValueChange={setSelectedCustomFieldId}
                  >
                    <SelectTrigger
                      className="border-2"
                      style={{
                        borderColor: "#bdc3c7",
                        color: "#2c3e50",
                        backgroundColor: "white",
                      }}
                    >
                      <SelectValue placeholder="Select a custom field to add" />
                    </SelectTrigger>
                    <SelectContent>
                      {availableFieldsToAdd.map((field) => (
                        <SelectItem
                          key={field.id}
                          value={field.id}
                          style={{ color: "#2c3e50" }}
                        >
                          {field.name}
                          {field.required && " (Required)"}
                          <span className="ml-2 text-xs text-gray-500">
                            ({field.type})
                          </span>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <Button
                  type="button"
                  onClick={handleAddCustomField}
                  disabled={!selectedCustomFieldId}
                  style={{
                    backgroundColor: selectedCustomFieldId
                      ? "#16a085"
                      : "#f5f7fa",
                    color: selectedCustomFieldId ? "white" : "#bdc3c7",
                  }}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Add Field
                </Button>
              </div>

              <div className="mt-4">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => window.open("/admin/custom-fields", "_blank")}
                  size="sm"
                  className="text-sm"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#7f8c8d",
                  }}
                >
                  <Plus className="h-3 w-3 mr-1" />
                  Create New Custom Field
                </Button>
              </div>
            </div>
          )}
        </CollapsibleContent>
      </Collapsible>
    </div>
  );
}

File: ./src/components/ui/label.tsx
// src/components/ui/label.tsx
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cn } from "@/lib/utils";

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(
      "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
      className
    )}
    {...props}
  />
));

Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

File: ./src/components/ui/select.tsx
// src/components/ui/select.tsx
import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown } from "lucide-react";
import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;
const SelectGroup = SelectPrimitive.Group;
const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-white placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:border-gray-700 dark:bg-gray-950 dark:ring-offset-gray-950 dark:placeholder:text-gray-400 dark:focus:ring-indigo-400",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 min-w-[8rem] overflow-hidden rounded-md border border-gray-200 bg-white text-gray-900 shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-gray-800 dark:bg-gray-950 dark:text-gray-50",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-gray-100 focus:text-gray-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-gray-800 dark:focus:text-gray-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-gray-100 dark:bg-gray-800", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
};

File: ./src/components/ui/dropdown-menu.tsx
// src/components/ui/dropdown-menu.tsx
import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  HTMLButtonElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-gray-100 data-[state=open]:bg-gray-100 dark:focus:bg-gray-800 dark:data-[state=open]:bg-gray-800",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border border-gray-200 bg-white p-1 text-gray-900 shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-gray-800 dark:bg-gray-950 dark:text-gray-50",
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border border-gray-200 bg-white p-1 text-gray-900 shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-gray-800 dark:bg-gray-950 dark:text-gray-50",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-gray-100 focus:text-gray-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-gray-800 dark:focus:text-gray-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-gray-100 focus:text-gray-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-gray-800 dark:focus:text-gray-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-gray-100 focus:text-gray-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-gray-800 dark:focus:text-gray-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  HTMLLabelElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-gray-900 dark:text-gray-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  HTMLHRElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-gray-200 dark:bg-gray-800", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-gray-500 dark:text-gray-400",
        className
      )}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

File: ./src/components/ui/form.tsx
// src/components/ui/form.tsx
import * as React from "react";
import {
  Controller,
  FormProvider,
  useFormContext,
  type UseFormReturn,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form";
import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = <TFormValues extends FieldValues>({
  children,
  ...props
}: React.PropsWithChildren<
  { className?: string } & React.ComponentProps<
    typeof FormProvider<TFormValues>
  >
>) => <FormProvider {...props}>{children}</FormProvider>;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof Label>,
  React.ComponentPropsWithoutRef<typeof Label>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && "text-red-500 dark:text-red-400", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <div
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-gray-500 dark:text-gray-400", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn(
        "text-sm font-medium text-red-500 dark:text-red-400",
        className
      )}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};

File: ./src/components/ui/collapsible.tsx
"use client";

import * as React from "react";
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";
import { cn } from "@/lib/utils";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.Trigger;

const CollapsibleContent = React.forwardRef<
  React.ElementRef<typeof CollapsiblePrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof CollapsiblePrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <CollapsiblePrimitive.Content
    ref={ref}
    className={cn(
      "data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down overflow-hidden transition-all",
      className
    )}
    {...props}
  >
    {children}
  </CollapsiblePrimitive.Content>
));
CollapsibleContent.displayName = "CollapsibleContent";

export { Collapsible, CollapsibleTrigger, CollapsibleContent };

File: ./src/components/ui/button.tsx
// src/components/ui/button.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-indigo-600 text-white hover:bg-indigo-700 dark:bg-indigo-600 dark:hover:bg-indigo-700",
        destructive:
          "bg-red-600 text-white hover:bg-red-700 dark:bg-red-600 dark:hover:bg-red-700",
        outline:
          "border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-950 dark:text-gray-300 dark:hover:bg-gray-900",
        secondary:
          "bg-gray-100 text-gray-900 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-100 dark:hover:bg-gray-700",
        ghost:
          "text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-800",
        link: "text-indigo-600 underline-offset-4 hover:underline dark:text-indigo-400",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-8 px-3 text-xs",
        lg: "h-12 px-6 text-base",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  isLoading?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, isLoading = false, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        disabled={isLoading || props.disabled}
        {...props}
      >
        {isLoading && (
          <svg
            className="mr-2 h-4 w-4 animate-spin"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            ></circle>
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
        )}
        {props.children}
      </button>
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };

File: ./src/components/ui/use-toast.ts
// src/components/ui/use-toast.ts
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 5;
const TOAST_REMOVE_DELAY = 5000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_VALUE;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: string;
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: string;
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case actionTypes.ADD_TOAST:
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case actionTypes.UPDATE_TOAST:
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case actionTypes.DISMISS_TOAST: {
      const { toastId } = action;

      // Dismiss all toasts
      if (toastId === undefined) {
        return {
          ...state,
          toasts: state.toasts.map((t) => ({
            ...t,
            open: false,
          })),
        };
      }

      // Dismiss specific toast
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }

    case actionTypes.REMOVE_TOAST: {
      const { toastId } = action;

      // Remove all toasts
      if (toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }

      // Remove specific toast
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== toastId),
      };
    }
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => listener(memoryState));
}

interface Toast extends Omit<ToasterToast, "id"> {}

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: Toast) =>
    dispatch({
      type: actionTypes.UPDATE_TOAST,
      toast: { ...props, id },
    });

  const dismiss = () =>
    dispatch({ type: actionTypes.DISMISS_TOAST, toastId: id });

  dispatch({
    type: actionTypes.ADD_TOAST,
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) {
          dismiss();
        }
      },
    },
  });

  return {
    id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) =>
      dispatch({ type: actionTypes.DISMISS_TOAST, toastId }),
  };
}

export { useToast, toast };

File: ./src/components/ui/dialog.tsx
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-200 bg-white p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-white transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-gray-100 data-[state=open]:text-gray-500">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-500", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

File: ./src/components/ui/tabs.tsx
// src/components/ui/tabs.tsx
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-gray-100 p-1 text-gray-600 dark:bg-gray-800 dark:text-gray-400",
      className
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  HTMLButtonElement,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium ring-offset-white transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-white data-[state=active]:text-indigo-600 data-[state=active]:shadow-sm dark:ring-offset-gray-950 dark:focus-visible:ring-indigo-400 dark:data-[state=active]:bg-gray-950 dark:data-[state=active]:text-indigo-400",
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 dark:ring-offset-gray-950 dark:focus-visible:ring-indigo-400",
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

File: ./src/components/ui/card.tsx
// src/components/ui/card.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border border-gray-200 bg-white shadow-sm dark:border-gray-800 dark:bg-gray-950",
      className
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight text-gray-900 dark:text-gray-50",
      className
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-gray-600 dark:text-gray-400", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};

File: ./src/components/ui/badge.tsx
// src/components/ui/badge.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "bg-red-500 text-white hover:bg-red-600",
        outline: "border border-gray-200 text-gray-700 hover:bg-gray-100",
        success: "bg-green-500 text-white hover:bg-green-600",
        warning: "bg-amber-500 text-white hover:bg-amber-600",
        info: "bg-blue-500 text-white hover:bg-blue-600",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

File: ./src/components/ui/textarea.tsx
// src/components/ui/textarea.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-white placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:border-gray-700 dark:bg-gray-950 dark:ring-offset-gray-950 dark:placeholder:text-gray-400 dark:focus-visible:ring-indigo-400",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = "Textarea";

export { Textarea };

File: ./src/components/ui/table.tsx
// src/components/ui/table.tsx - Update colors for better visibility
import * as React from "react";
import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="w-full overflow-auto">
    <table
      ref={ref}
      className={cn(
        "w-full caption-bottom text-sm text-gray-900 dark:text-gray-100",
        className
      )}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead
    ref={ref}
    className={cn("[&_tr]:border-b bg-gray-200 dark:bg-gray-800", className)}
    {...props}
  />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn(
      "[&_tr:last-child]:border-0 bg-white dark:bg-gray-900",
      className
    )}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "bg-gray-100 font-medium text-gray-900 dark:bg-gray-700 dark:text-gray-200",
      className
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-gray-100 dark:border-gray-700 dark:hover:bg-gray-800",
      className
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-gray-800 dark:text-gray-300 bg-gray-100 dark:bg-gray-700",
      className
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-4 align-middle text-gray-800 dark:text-gray-200",
      className
    )}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-gray-700 dark:text-gray-400", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};

File: ./src/components/ui/toast.tsx
// src/components/ui/toast.tsx
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-white text-gray-900",
        destructive: "destructive group border-red-500 bg-red-50 text-red-900",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border border-gray-200 bg-transparent px-3 text-sm font-medium ring-offset-white transition-colors hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-red-100 group-[.destructive]:hover:border-red-200 group-[.destructive]:hover:bg-red-100 group-[.destructive]:hover:text-red-900 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-50",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-gray-500 opacity-0 transition-opacity hover:text-gray-900 focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-500 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-50",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

File: ./src/components/ui/switch.tsx
// src/components/ui/switch.tsx
"use client";

import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";
import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-gray-400 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-green-500 data-[state=unchecked]:bg-gray-200",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-white shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

File: ./src/components/ui/alert-dialog.tsx
import * as React from "react";
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-200 bg-white p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg md:w-full dark:border-gray-800 dark:bg-gray-950",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold text-gray-900 dark:text-gray-50",
      className
    )}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-500 dark:text-gray-400", className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  HTMLButtonElement,
  React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ className, ...props }, ref) => (
  <button ref={ref} className={cn(buttonVariants(), className)} {...props} />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};

File: ./src/components/ui/input.tsx
// src/components/ui/input.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  error?: string;
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, error, ...props }, ref) => {
    return (
      <div className="relative">
        <input
          type={type}
          className={cn(
            "flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-white file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:border-gray-700 dark:bg-gray-950 dark:ring-offset-gray-950 dark:placeholder:text-gray-400 dark:focus-visible:ring-indigo-400",
            error && "border-red-500 focus-visible:ring-red-500",
            className
          )}
          ref={ref}
          {...props}
        />
        {error && <p className="mt-1 text-xs text-red-500">{error}</p>}
      </div>
    );
  }
);
Input.displayName = "Input";

export { Input };

File: ./src/components/ui/checkbox.tsx
// src/components/ui/checkbox.tsx
import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";
import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-gray-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-indigo-600 data-[state=checked]:text-white dark:border-gray-700 dark:data-[state=checked]:bg-indigo-500",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className="flex items-center justify-center">
      <Check className="h-3 w-3" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));

Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

File: ./src/components/ui/alert.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-red-500/50 text-red-700 dark:border-red-500 [&>svg]:text-red-500 bg-red-50",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface AlertProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof alertVariants> {}

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(
  ({ className, variant, ...props }, ref) => (
    <div
      ref={ref}
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
);
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };

File: ./src/lib/feature-authorization.ts
// src/lib/feature-authorization.ts
import { PlanType, Role } from "@prisma/client";

// Define all available features
export enum Feature {
  // Standard features - available to all plans
  PRODUCTS_MANAGEMENT = "products_management",
  CATEGORIES_MANAGEMENT = "categories_management",
  ORDERS_VIEW = "orders_view",
  CUSTOMERS_VIEW = "customers_view",
  SHOP_SETTINGS = "shop_settings",

  // Advanced features - available to ADVANCED and PREMIUM plans
  INVOICE_GENERATION = "invoice_generation",
  ADVANCED_ANALYTICS = "advanced_analytics",
  INVENTORY_ALERTS = "inventory_alerts",
  NOTIFICATIONS = "notifications",
  CUSTOM_DOMAIN = "custom_domain",

  // Premium features - available only to PREMIUM plan
  AI_PREDICTIONS = "ai_predictions",
  API_ACCESS = "api_access",
  CUSTOM_BRANDING = "custom_branding",
  PRIORITY_SUPPORT = "priority_support",
  BULK_OPERATIONS = "bulk_operations",
}

// Define feature availability by plan
const PLAN_FEATURES: Record<string, Set<Feature>> = {
  STANDARD: new Set([
    Feature.PRODUCTS_MANAGEMENT,
    Feature.CATEGORIES_MANAGEMENT,
    Feature.ORDERS_VIEW,
    Feature.CUSTOMERS_VIEW,
    Feature.SHOP_SETTINGS,
  ]),

  ADVANCED: new Set([
    // Include all STANDARD features
    Feature.PRODUCTS_MANAGEMENT,
    Feature.CATEGORIES_MANAGEMENT,
    Feature.ORDERS_VIEW,
    Feature.CUSTOMERS_VIEW,
    Feature.SHOP_SETTINGS,

    // Add ADVANCED features
    Feature.INVOICE_GENERATION,
    Feature.ADVANCED_ANALYTICS,
    Feature.INVENTORY_ALERTS,
    Feature.NOTIFICATIONS,
    Feature.CUSTOM_DOMAIN,
  ]),

  PREMIUM: new Set([
    // Include all STANDARD and ADVANCED features
    Feature.PRODUCTS_MANAGEMENT,
    Feature.CATEGORIES_MANAGEMENT,
    Feature.ORDERS_VIEW,
    Feature.CUSTOMERS_VIEW,
    Feature.SHOP_SETTINGS,
    Feature.INVOICE_GENERATION,
    Feature.ADVANCED_ANALYTICS,
    Feature.INVENTORY_ALERTS,
    Feature.NOTIFICATIONS,
    Feature.CUSTOM_DOMAIN,

    // Add PREMIUM features
    Feature.AI_PREDICTIONS,
    Feature.API_ACCESS,
    Feature.CUSTOM_BRANDING,
    Feature.PRIORITY_SUPPORT,
    Feature.BULK_OPERATIONS,
  ]),
};

// Define feature limits by plan
export const PLAN_LIMITS = {
  STANDARD: {
    maxProducts: 100,
    maxCategories: 20,
    maxVariantsPerProduct: 10,
  },
  ADVANCED: {
    maxProducts: 1000,
    maxCategories: 100,
    maxVariantsPerProduct: 30,
  },
  PREMIUM: {
    maxProducts: -1, // Unlimited
    maxCategories: -1, // Unlimited
    maxVariantsPerProduct: -1, // Unlimited
  },
};

// Define role features
const ROLE_ACCESS: Record<string, Record<Feature, boolean>> = {
  SHOP_ADMIN: {
    // Shop admins can access all features available to their plan
    [Feature.PRODUCTS_MANAGEMENT]: true,
    [Feature.CATEGORIES_MANAGEMENT]: true,
    [Feature.ORDERS_VIEW]: true,
    [Feature.CUSTOMERS_VIEW]: true,
    [Feature.SHOP_SETTINGS]: true,
    [Feature.INVOICE_GENERATION]: true,
    [Feature.ADVANCED_ANALYTICS]: true,
    [Feature.INVENTORY_ALERTS]: true,
    [Feature.NOTIFICATIONS]: true,
    [Feature.CUSTOM_DOMAIN]: true,
    [Feature.AI_PREDICTIONS]: true,
    [Feature.API_ACCESS]: true,
    [Feature.CUSTOM_BRANDING]: true,
    [Feature.PRIORITY_SUPPORT]: true,
    [Feature.BULK_OPERATIONS]: true,
  },
  SHOP_STAFF: {
    // Staff have limited access
    [Feature.PRODUCTS_MANAGEMENT]: true,
    [Feature.CATEGORIES_MANAGEMENT]: true,
    [Feature.ORDERS_VIEW]: true,
    [Feature.CUSTOMERS_VIEW]: true,
    [Feature.SHOP_SETTINGS]: false, // Cannot modify shop settings
    [Feature.INVOICE_GENERATION]: true,
    [Feature.ADVANCED_ANALYTICS]: true,
    [Feature.INVENTORY_ALERTS]: true,
    [Feature.NOTIFICATIONS]: true,
    [Feature.CUSTOM_DOMAIN]: false, // Cannot modify domain settings
    [Feature.AI_PREDICTIONS]: true,
    [Feature.API_ACCESS]: false, // Cannot access API
    [Feature.CUSTOM_BRANDING]: false, // Cannot modify branding
    [Feature.PRIORITY_SUPPORT]: true,
    [Feature.BULK_OPERATIONS]: true,
  },
  CUSTOMER: {
    // Customers have no access to these features
    [Feature.PRODUCTS_MANAGEMENT]: false,
    [Feature.CATEGORIES_MANAGEMENT]: false,
    [Feature.ORDERS_VIEW]: false,
    [Feature.CUSTOMERS_VIEW]: false,
    [Feature.SHOP_SETTINGS]: false,
    [Feature.INVOICE_GENERATION]: false,
    [Feature.ADVANCED_ANALYTICS]: false,
    [Feature.INVENTORY_ALERTS]: false,
    [Feature.NOTIFICATIONS]: false,
    [Feature.CUSTOM_DOMAIN]: false,
    [Feature.AI_PREDICTIONS]: false,
    [Feature.API_ACCESS]: false,
    [Feature.CUSTOM_BRANDING]: false,
    [Feature.PRIORITY_SUPPORT]: false,
    [Feature.BULK_OPERATIONS]: false,
  },
  SUPER_ADMIN: {
    // Super admins have access to everything
    [Feature.PRODUCTS_MANAGEMENT]: true,
    [Feature.CATEGORIES_MANAGEMENT]: true,
    [Feature.ORDERS_VIEW]: true,
    [Feature.CUSTOMERS_VIEW]: true,
    [Feature.SHOP_SETTINGS]: true,
    [Feature.INVOICE_GENERATION]: true,
    [Feature.ADVANCED_ANALYTICS]: true,
    [Feature.INVENTORY_ALERTS]: true,
    [Feature.NOTIFICATIONS]: true,
    [Feature.CUSTOM_DOMAIN]: true,
    [Feature.AI_PREDICTIONS]: true,
    [Feature.API_ACCESS]: true,
    [Feature.CUSTOM_BRANDING]: true,
    [Feature.PRIORITY_SUPPORT]: true,
    [Feature.BULK_OPERATIONS]: true,
  },
};

interface User {
  role: string;
  planType?: string | null;
  shopId?: string | null;
}

/**
 * Check if a user has access to a specific feature
 */
export function hasFeatureAccess(
  user: User | null | undefined,
  feature: Feature
): boolean {
  if (!user) return false;

  // Super admins always have access to every feature
  if (user.role === "SUPER_ADMIN") {
    return true;
  }

  // Check if user has a shop, except for SUPER_ADMIN
  if (!user.shopId && user.role !== "SUPER_ADMIN") {
    return false;
  }

  // Check if the user's role has access to the feature
  const roleAccess = ROLE_ACCESS[user.role]?.[feature] || false;

  // If role doesn't have access, deny immediately
  if (!roleAccess) {
    return false;
  }

  // Check if the feature is included in the user's plan
  const planType = user.planType || "STANDARD"; // Default to STANDARD if not specified
  const planFeatures = PLAN_FEATURES[planType];

  // Return whether the feature is available in the user's plan
  return planFeatures?.has(feature) || false;
}

/**
 * Check if user is within plan limits
 */
export function isWithinPlanLimits(
  user: User | null | undefined,
  limit: keyof typeof PLAN_LIMITS.STANDARD,
  currentCount: number
): boolean {
  if (!user || !user.planType) return false;

  const planLimits =
    PLAN_LIMITS[user.planType as keyof typeof PLAN_LIMITS] ||
    PLAN_LIMITS.STANDARD;
  const maxLimit = planLimits[limit];

  // -1 means unlimited
  if (maxLimit === -1) return true;

  return currentCount < maxLimit;
}

/**
 * Get features available to a user
 */
export function getAvailableFeatures(user: User | null | undefined): Feature[] {
  if (!user) return [];

  // Super admins have access to all features
  if (user.role === "SUPER_ADMIN") {
    return Object.values(Feature);
  }

  // Get features based on plan and filter by role access
  const planType = user.planType || "STANDARD";
  const planFeatures = Array.from(
    PLAN_FEATURES[planType] || PLAN_FEATURES.STANDARD
  );

  // Filter by role access
  return planFeatures.filter(
    (feature) => ROLE_ACCESS[user.role]?.[feature] || false
  );
}

/**
 * Get plan limit for a specific limit type
 */
export function getPlanLimit(
  user: User | null | undefined,
  limit: keyof typeof PLAN_LIMITS.STANDARD
): number {
  if (!user || !user.planType) return PLAN_LIMITS.STANDARD[limit];

  const planLimits =
    PLAN_LIMITS[user.planType as keyof typeof PLAN_LIMITS] ||
    PLAN_LIMITS.STANDARD;
  return planLimits[limit];
}

File: ./src/lib/authorization.ts
// src/lib/authorization.ts
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { PlanType } from "@prisma/client";
import { authOptions } from "./auth";
import { hasFeature } from "./plan-features";
import { db } from "./prisma";

export async function requireAuth(redirectTo = "/login") {
  const session = await getServerSession(authOptions);

  if (!session?.user) {
    redirect(
      `${redirectTo}?callbackUrl=${encodeURIComponent(
        window.location.pathname
      )}`
    );
  }

  return session;
}

export async function requireShopAdmin(redirectTo = "/login") {
  const session = await getServerSession(authOptions);

  if (!session?.user) {
    redirect(
      `${redirectTo}?callbackUrl=${encodeURIComponent(
        window.location.pathname
      )}`
    );
  }

  if (
    !session.user.shopId ||
    (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
  ) {
    redirect("/");
  }

  return session;
}

export async function requireFeature(feature: string, redirectTo = "/admin") {
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login");
  }

  // Get shop to check plan type
  const shop = await db.shop.findUnique({
    where: { id: session.user.shopId },
  });

  if (!shop) {
    redirect("/login");
  }

  // Check if the plan includes this feature
  if (!hasFeature(shop.planType as PlanType, feature as any)) {
    redirect(redirectTo);
  }

  return session;
}

File: ./src/lib/utils.ts
// src/lib/utils.ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatCurrency(amount: number, currency = "USD"): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(amount);
}

export function formatDate(date: Date | string): string {
  const d = typeof date === "string" ? new Date(date) : date;
  return new Intl.DateTimeFormat("en-US", {
    year: "numeric",
    month: "short",
    day: "numeric",
  }).format(d);
}

export function slugify(text: string): string {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .replace(/\s+/g, "-")
    .replace(/&/g, "-and-")
    .replace(/[^\w\-]+/g, "")
    .replace(/\-\-+/g, "-");
}

export function generateOrderNumber(): string {
  const date = new Date();
  const year = date.getFullYear().toString().slice(-2);
  const month = (date.getMonth() + 1).toString().padStart(2, "0");
  const day = date.getDate().toString().padStart(2, "0");
  const random = Math.floor(Math.random() * 10000)
    .toString()
    .padStart(4, "0");

  return `ORD-${year}${month}${day}-${random}`;
}

export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + "...";
}

export function capitalizeFirstLetter(string: string): string {
  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
}

export function getInitials(name: string): string {
  if (!name) return "";

  return name
    .split(" ")
    .map((part) => part.charAt(0).toUpperCase())
    .slice(0, 2)
    .join("");
}

File: ./src/lib/plan-features.ts
import { PlanType } from "@prisma/client";

export interface PlanFeatures {
  maxProducts: number;
  maxCategories: number;
  analytics: boolean;
  advancedReporting: boolean;
  invoiceGeneration: boolean;
  inventoryAlerts: boolean;
  aiPredictions: boolean;
  customDomain: boolean;
  apiAccess: boolean;
  customBranding: boolean;
  prioritySupport: boolean;
}

export const PLAN_FEATURES: Record<PlanType, PlanFeatures> = {
  STANDARD: {
    maxProducts: 100,
    maxCategories: 20,
    analytics: false,
    advancedReporting: false,
    invoiceGeneration: false,
    inventoryAlerts: false,
    aiPredictions: false,
    customDomain: false,
    apiAccess: false,
    customBranding: false,
    prioritySupport: false,
  },
  ADVANCED: {
    maxProducts: 1000,
    maxCategories: 100,
    analytics: true,
    advancedReporting: true,
    invoiceGeneration: true,
    inventoryAlerts: true,
    aiPredictions: false,
    customDomain: true,
    apiAccess: false,
    customBranding: false,
    prioritySupport: false,
  },
  PREMIUM: {
    maxProducts: -1, // Unlimited
    maxCategories: -1, // Unlimited
    analytics: true,
    advancedReporting: true,
    invoiceGeneration: true,
    inventoryAlerts: true,
    aiPredictions: true,
    customDomain: true,
    apiAccess: true,
    customBranding: true,
    prioritySupport: true,
  },
};

export function hasFeature(
  planType: PlanType,
  feature: keyof PlanFeatures
): boolean {
  return PLAN_FEATURES[planType][feature];
}

export function getMaxLimit(
  planType: PlanType,
  limit: "maxProducts" | "maxCategories"
): number {
  return PLAN_FEATURES[planType][limit];
}

export function isWithinLimits(
  planType: PlanType,
  feature: "maxProducts" | "maxCategories",
  currentCount: number
): boolean {
  const limit = getMaxLimit(planType, feature);

  // -1 means unlimited
  if (limit === -1) return true;

  return currentCount < limit;
}

File: ./src/lib/prisma.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const db =
  globalForPrisma.prisma ||
  new PrismaClient({
    log:
      process.env.NODE_ENV === "development"
        ? ["query", "error", "warn"]
        : ["error"],
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = db;

File: ./src/lib/services/categories.service.ts
// src/lib/services/categories.service.ts
import { db } from "@/lib/prisma";

export const categoriesService = {
  /**
   * Get all categories for a shop with hierarchy information
   */
  async getCategoriesWithHierarchy(shopId: string) {
    // Get all categories for the shop
    const allCategories = await db.category.findMany({
      where: { shopId },
      select: {
        id: true,
        name: true,
        parentId: true,
      },
    });

    // Function to add level information to categories
    const addLevelToCategories = (
      categories: any[],
      parentId: string | null = null,
      level = 0
    ) => {
      return categories
        .filter((category) => category.parentId === parentId)
        .map((category) => ({
          id: category.id,
          name: category.name,
          level,
          parentId: category.parentId,
        }));
    };

    // Function to create flat array with correct level
    const createFlatCategoriesWithLevels = (categories: any[]) => {
      // First get all root categories (those with no parent)
      let result = addLevelToCategories(categories);

      // For each root category, recursively add its children
      for (let i = 0; i < result.length; i++) {
        const category = result[i];
        const children = addLevelToCategories(
          categories,
          category.id,
          category.level + 1
        );

        // Insert children after their parent
        if (children.length > 0) {
          result.splice(i + 1, 0, ...children);
          // Skip the children we just added
          i += children.length;
        }
      }

      return result;
    };

    return createFlatCategoriesWithLevels(allCategories);
  },

  /**
   * Get simple list of categories for a shop (for filtering)
   */
  async getCategories(shopId: string) {
    return await db.category.findMany({
      where: { shopId },
      select: { id: true, name: true },
    });
  },
};

File: ./src/lib/services/index.ts
export * from "./categories.service";
export * from "./products.service";
export * from "./shop.service";

File: ./src/lib/services/shop.service.ts
// src/lib/services/shop.service.ts
import { db } from "@/lib/prisma";

export const shopService = {
  /**
   * Get shop by subdomain
   */
  async getShopBySubdomain(subdomain: string) {
    return await db.shop.findUnique({
      where: { subdomain },
      include: {
        settings: true,
      },
    });
  },

  /**
   * Get shop by ID
   */
  async getShopById(shopId: string) {
    return await db.shop.findUnique({
      where: { id: shopId },
      include: {
        settings: true,
      },
    });
  },

  /**
   * Get shop settings
   */
  async getShopSettings(shopId: string) {
    return await db.shopSettings.findUnique({
      where: { shopId },
    });
  },

  /**
   * Check if shop exists
   */
  async shopExists(shopId: string): Promise<boolean> {
    const count = await db.shop.count({
      where: { id: shopId },
    });
    return count > 0;
  },
};

File: ./src/lib/services/products.service.ts
// src/lib/services/products.service.ts
import { db } from "@/lib/prisma";

export interface ProductsFilter {
  shopId: string;
  search?: string;
  categoryId?: string;
  inStock?: boolean;
  lowStock?: boolean;
  expiringSoon?: boolean;
  lowStockThreshold?: number;
}

export interface ProductsSortOptions {
  sortField: string;
  sortOrder: "asc" | "desc";
}

export interface ProductsPagination {
  page: number;
  perPage: number;
}

export const productsService = {
  /**
   * Get total products count based on filters
   */
  async getTotalProducts(filters: ProductsFilter): Promise<number> {
    const where: any = { shopId: filters.shopId };

    if (filters.search) {
      where.OR = [
        { name: { contains: filters.search, mode: "insensitive" } },
        { description: { contains: filters.search, mode: "insensitive" } },
        { sku: { contains: filters.search, mode: "insensitive" } },
        { barcode: { contains: filters.search, mode: "insensitive" } },
      ];
    }

    if (filters.categoryId) {
      where.categories = {
        some: { id: filters.categoryId },
      };
    }

    if (filters.inStock) {
      where.inventory = { gt: 0 };
    }

    if (filters.lowStock) {
      where.inventory = { lte: filters.lowStockThreshold || 5 };
    }

    if (filters.expiringSoon) {
      // Products expiring in the next 30 days
      const today = new Date();
      const thirtyDaysLater = new Date();
      thirtyDaysLater.setDate(today.getDate() + 30);

      where.expiryDate = {
        gte: today,
        lte: thirtyDaysLater,
      };
    }

    return await db.product.count({ where });
  },

  /**
   * Get products with pagination, filtering and sorting
   */
  async getProducts(
    filters: ProductsFilter,
    pagination: ProductsPagination,
    sort: ProductsSortOptions
  ) {
    const where: any = { shopId: filters.shopId };

    if (filters.search) {
      where.OR = [
        { name: { contains: filters.search, mode: "insensitive" } },
        { description: { contains: filters.search, mode: "insensitive" } },
        { sku: { contains: filters.search, mode: "insensitive" } },
        { barcode: { contains: filters.search, mode: "insensitive" } },
      ];
    }

    if (filters.categoryId) {
      where.categories = {
        some: { id: filters.categoryId },
      };
    }

    if (filters.inStock) {
      where.inventory = { gt: 0 };
    }

    if (filters.lowStock) {
      where.inventory = { lte: filters.lowStockThreshold || 5 };
    }

    if (filters.expiringSoon) {
      // Products expiring in the next 30 days
      const today = new Date();
      const thirtyDaysLater = new Date();
      thirtyDaysLater.setDate(today.getDate() + 30);

      where.expiryDate = {
        gte: today,
        lte: thirtyDaysLater,
      };
    }

    return await db.product.findMany({
      where,
      include: {
        categories: {
          select: { id: true, name: true, slug: true },
        },
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
        _count: {
          select: {
            variants: true,
            orderItems: true,
          },
        },
        discounts: {
          where: {
            enabled: true,
            startDate: { lte: new Date() },
            endDate: { gte: new Date() },
          },
          select: {
            id: true,
            percentage: true,
          },
          take: 1, // Just get the first active discount
        },
      },
      orderBy: { [sort.sortField]: sort.sortOrder },
      skip: (pagination.page - 1) * pagination.perPage,
      take: pagination.perPage,
    });
  },

  /**
   * Get categories for a shop
   */
  async getCategories(shopId: string) {
    return await db.category.findMany({
      where: { shopId },
      select: { id: true, name: true },
    });
  },

  /**
   * Get shop settings including low stock threshold
   */
  async getShopSettings(shopId: string) {
    return await db.shopSettings.findUnique({
      where: { shopId },
      select: { lowStockThreshold: true },
    });
  },

  /**
   * Get product statistics
   */
  async getProductStats(shopId: string, lowStockThreshold: number) {
    try {
      // Use a safer approach that doesn't return BigInt directly
      const products = await db.product.findMany({
        where: { shopId },
        select: { inventory: true },
      });

      // Calculate statistics manually
      let totalInventory = 0;
      let lowStockCount = 0;
      let outOfStockCount = 0;

      products.forEach((product) => {
        totalInventory += product.inventory;
        if (product.inventory <= lowStockThreshold) lowStockCount++;
        if (product.inventory === 0) outOfStockCount++;
      });

      return {
        totalInventory,
        lowStockCount,
        outOfStockCount,
      };
    } catch (error) {
      console.error("Error getting product stats:", error);
      // Return safe default values
      return {
        totalInventory: 0,
        lowStockCount: 0,
        outOfStockCount: 0,
      };
    }
  },
};

File: ./src/lib/subdomain.ts
import { NextRequest } from "next/server";

export function getSubdomain(req: NextRequest): string | null {
  // For local development, always use the environment variable
  if (process.env.NODE_ENV === "development") {
    return process.env.SHOP_SUBDOMAIN || null;
  }

  // Get host from request headers
  const host = req.headers.get("host");
  if (!host) return null;

  // Extract subdomain from host
  const parts = host.split(".");
  if (parts.length > 2) {
    return parts[0];
  }

  return null;
}

File: ./src/lib/auth.ts
// src/lib/auth.ts
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import { compare } from "bcrypt";
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { db } from "@/lib/prisma";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(db),
  session: {
    strategy: "jwt",
  },
  pages: {
    signIn: "/login",
  },
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
        shopSubdomain: { label: "Shop Subdomain", type: "text" }, // Hidden field for subdomain
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        // Determine which shop to check based on subdomain (if provided)
        const shopQuery = credentials.shopSubdomain
          ? { subdomain: credentials.shopSubdomain }
          : undefined;

        // Find the user with optional shop filtering
        const user = await db.user.findUnique({
          where: {
            email: credentials.email,
          },
          include: {
            shop: {
              select: {
                id: true,
                name: true,
                subdomain: true,
                planType: true,
                active: true,
              },
            },
          },
        });

        if (!user) {
          return null;
        }

        // If a specific shop subdomain was requested, verify the user belongs to that shop
        if (
          credentials.shopSubdomain &&
          user.shop?.subdomain !== credentials.shopSubdomain
        ) {
          return null;
        }

        // Verify password
        const isPasswordValid = await compare(
          credentials.password,
          user.password
        );

        if (!isPasswordValid) {
          return null;
        }

        // Check if the shop is active
        if (user.shop && !user.shop.active) {
          return null; // Shop is inactive, don't allow login
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          shopId: user.shopId,
          shopName: user.shop?.name || null,
          shopSubdomain: user.shop?.subdomain || null,
          planType: user.shop?.planType || null,
        };
      },
    }),
  ],
  callbacks: {
    async session({ session, token }) {
      if (token) {
        session.user.id = token.id as string;
        session.user.name = token.name as string;
        session.user.email = token.email as string;
        session.user.role = token.role as string;
        session.user.shopId = token.shopId as string | null;
        session.user.shopName = token.shopName as string | null;
        session.user.shopSubdomain = token.shopSubdomain as string | null;
        session.user.planType = token.planType as string | null;
      }
      return session;
    },
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
        token.shopId = user.shopId;
        token.shopName = user.shopName;
        token.shopSubdomain = user.shopSubdomain;
        token.planType = user.planType;
      }

      return token;
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};

// Extend next-auth types
declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      name: string;
      email: string;
      role: string;
      shopId: string | null;
      shopName: string | null;
      shopSubdomain: string | null;
      planType: string | null;
    };
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string;
    role: string;
    shopId: string | null;
    shopName: string | null;
    shopSubdomain: string | null;
    planType: string | null;
  }
}

File: ./src/lib/api-client.ts
// src/lib/api-client.ts
/**
 * API Client for making API calls to the backend
 */
export const apiClient = {
  /**
   * Make a GET request to the API
   */
  async get(endpoint: string, params: Record<string, any> = {}) {
    // Build URL with query parameters
    const url = new URL(`/api${endpoint}`, window.location.origin);

    // Add query parameters to URL
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== "") {
        url.searchParams.append(key, String(value));
      }
    });

    // Make request
    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "An error occurred");
    }

    return response.json();
  },

  /**
   * Make a POST request to the API
   */
  async post(endpoint: string, data: any) {
    const response = await fetch(`/api${endpoint}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "An error occurred");
    }

    return response.json();
  },

  /**
   * Make a PUT request to the API
   */
  async put(endpoint: string, data: any) {
    const response = await fetch(`/api${endpoint}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "An error occurred");
    }

    return response.json();
  },

  /**
   * Make a DELETE request to the API
   */
  async delete(endpoint: string) {
    const response = await fetch(`/api${endpoint}`, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "An error occurred");
    }

    return response.json();
  },

  products: {
    /**
     * Get products with filtering, sorting, and pagination
     */
    async getProducts(params: any = {}) {
      return apiClient.get("/products", params);
    },

    /**
     * Create a new product
     */
    async createProduct(data: any) {
      return apiClient.post("/products", data);
    },

    /**
     * Get a product by ID
     */
    async getProduct(id: string) {
      return apiClient.get(`/products/${id}`);
    },

    /**
     * Update a product
     */
    async updateProduct(id: string, data: any) {
      return apiClient.put(`/products/${id}`, data);
    },

    /**
     * Delete a product
     */
    async deleteProduct(id: string) {
      return apiClient.delete(`/products/${id}`);
    },
  },

  // Categories API
  categories: {
    /**
     * Get all categories
     */
    async getCategories() {
      return apiClient.get("/categories");
    },
  },

  // Shop API
  shop: {
    /**
     * Get shop information
     */
    async getShopInfo() {
      return apiClient.get("/shop");
    },
  },
};

File: ./src/lib/permissions.ts
import { PlanType, Role } from "@prisma/client";

interface User {
  id: string;
  role: string;
  planType?: string | null;
}

export function canViewSubscription(user: User | null | undefined): boolean {
  // Only SHOP_ADMIN can view subscription details
  return user?.role === "SHOP_ADMIN";
}

export function canViewAdvancedStats(user: User | null | undefined): boolean {
  // Advanced stats are available to SHOP_ADMIN and SHOP_STAFF with ADVANCED or PREMIUM plans
  if (!user) return false;

  const hasPremiumPlan =
    user.planType === "ADVANCED" || user.planType === "PREMIUM";
  return (
    (user.role === "SHOP_ADMIN" || user.role === "SHOP_STAFF") && hasPremiumPlan
  );
}

export function formatPlanName(planType: string): string {
  // Format plan type for display
  switch (planType) {
    case "STANDARD":
      return "Standard Plan";
    case "ADVANCED":
      return "Advanced Plan";
    case "PREMIUM":
      return "Premium Plan";
    default:
      return planType;
  }
}

export function formatSubscriptionPeriod(period: string): string {
  // Format subscription period for display
  switch (period) {
    case "SIX_MONTHS":
      return "6 Months";
    case "ONE_YEAR":
      return "1 Year";
    case "THREE_YEARS":
      return "3 Years";
    default:
      return period;
  }
}

export function getDiscountByPeriod(period: string): number {
  // Return discount percentage based on period
  switch (period) {
    case "SIX_MONTHS":
      return 0;
    case "ONE_YEAR":
      return 12;
    case "THREE_YEARS":
      return 20;
    default:
      return 0;
  }
}

File: ./src/lib/serializer.ts
// src/lib/serializer.ts

/**
 * Recursively transforms BigInt values to strings or numbers in an object
 * to make it safe for JSON serialization
 *
 * @param obj The object to transform
 * @returns A new object with BigInt values converted to strings or numbers
 */
export function serializeBigInt(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  // Handle BigInt
  if (typeof obj === "bigint") {
    // Convert to number if it's within safe integer range, otherwise to string
    return Number.isSafeInteger(Number(obj)) ? Number(obj) : obj.toString();
  }

  // Handle Date
  if (obj instanceof Date) {
    return obj.toISOString();
  }

  // Handle arrays
  if (Array.isArray(obj)) {
    return obj.map(serializeBigInt);
  }

  // Handle objects
  if (typeof obj === "object") {
    const result: Record<string, any> = {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        result[key] = serializeBigInt(obj[key]);
      }
    }
    return result;
  }

  // Return primitive values as is
  return obj;
}

File: ./src/middleware.ts
// src/middleware.ts
import { NextRequest, NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const hostname = request.headers.get("host") || "";

  // For development environment, use the environment variable
  const subdomain =
    process.env.NODE_ENV === "development"
      ? process.env.SHOP_SUBDOMAIN || "para"
      : getSubdomainFromHostname(hostname);

  // Add the current subdomain to headers for backend use
  const requestHeaders = new Headers(request.headers);
  if (subdomain) {
    requestHeaders.set("x-shop-subdomain", subdomain);
  }

  // Main store.tn domain handling
  if (!subdomain || subdomain === "www") {
    // This is for the main store.tn site
    if (pathname.startsWith("/admin") && !isAuthenticated(request)) {
      return redirectToLogin(request);
    }

    // Continue to the main store application
    return NextResponse.next({
      request: { headers: requestHeaders },
    });
  }

  // Subdomain handling (e.g., para.store.tn)
  // Admin routes for shop owners
  if (pathname.startsWith("/admin")) {
    const token = await getToken({ req: request });

    // If not authenticated, redirect to login
    if (!token) {
      return redirectToLogin(request, subdomain);
    }

    // Check if user belongs to this shop
    if (token.shopSubdomain !== subdomain) {
      // User is authenticated but trying to access another shop's admin
      return NextResponse.redirect(new URL("/unauthorized", request.url));
    }

    // User is authenticated and authorized for this shop's admin
    return NextResponse.next({
      request: { headers: requestHeaders },
    });
  }

  // API routes
  if (pathname.startsWith("/api/")) {
    return NextResponse.next({
      request: { headers: requestHeaders },
    });
  }

  // All other routes are for the storefront
  return NextResponse.next({
    request: { headers: requestHeaders },
  });
}

// Helper function to extract subdomain from hostname
function getSubdomainFromHostname(hostname: string): string | null {
  // Handle localhost for development
  if (hostname.includes("localhost")) {
    return process.env.SHOP_SUBDOMAIN || null;
  }

  // Extract subdomain from hostname
  const parts = hostname.split(".");
  if (parts.length > 2) {
    return parts[0];
  }

  return null;
}

// Helper function to redirect to login
function redirectToLogin(
  request: NextRequest,
  subdomain?: string | null
): NextResponse {
  const url = new URL("/login", request.url);
  url.searchParams.set("callbackUrl", request.nextUrl.pathname);

  // If we have a subdomain, ensure we're redirecting to that shop's login page
  if (subdomain) {
    // In production, this would be something like `https://${subdomain}.store.tn/login`
    // For development, we use the same URL but keep track of the subdomain
    url.searchParams.set("shop", subdomain);
  }

  return NextResponse.redirect(url);
}

// Check if the request is authenticated (simplified, actual implementation would use getToken)
async function isAuthenticated(request: NextRequest): Promise<boolean> {
  const token = await getToken({ req: request });
  return !!token;
}

// Match all pathnames except for assets, public routes, etc.
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    "/((?!_next/static|_next/image|favicon.ico|public|assets).*)",
    "/api/:path*",
    "/admin/:path*",
  ],
};

File: ./src/app/globals.css
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

File: ./src/app/register/page.tsx
// src/app/register/page.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ExclamationTriangleIcon } from "@heroicons/react/24/outline";

export default function RegisterPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    password: "",
    confirmPassword: "",
  });
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);

    // Validate password match
    if (formData.password !== formData.confirmPassword) {
      setError("Passwords don't match");
      setIsLoading(false);
      return;
    }

    try {
      // Register the user
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: formData.name,
          email: formData.email,
          password: formData.password,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Registration failed");
      }

      // Automatically sign in after successful registration
      const signInResult = await signIn("credentials", {
        redirect: false,
        email: formData.email,
        password: formData.password,
      });

      if (signInResult?.error) {
        throw new Error("Failed to sign in after registration");
      }

      // Redirect to dashboard
      router.push("/admin");
    } catch (error: any) {
      setError(error.message || "Something went wrong");
      setIsLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold">
            Create an account
          </CardTitle>
          <CardDescription>
            Enter your information to register for an account
          </CardDescription>
        </CardHeader>
        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <ExclamationTriangleIcon className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="name">Full Name</Label>
              <Input
                id="name"
                name="name"
                placeholder="John Doe"
                value={formData.name}
                onChange={handleChange}
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="you@example.com"
                value={formData.email}
                onChange={handleChange}
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                name="password"
                type="password"
                placeholder="••••••••"
                value={formData.password}
                onChange={handleChange}
                required
                minLength={8}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="confirmPassword">Confirm Password</Label>
              <Input
                id="confirmPassword"
                name="confirmPassword"
                type="password"
                placeholder="••••••••"
                value={formData.confirmPassword}
                onChange={handleChange}
                required
              />
            </div>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? "Creating account..." : "Create account"}
            </Button>
          </form>
        </CardContent>
        <CardFooter className="flex flex-col space-y-4">
          <div className="text-sm text-center">
            Already have an account?{" "}
            <Link
              href="/login"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              Sign in
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}

File: ./src/app/login/page.tsx
// src/app/login/page.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ExclamationTriangleIcon } from "@heroicons/react/24/outline";

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get("callbackUrl") || "/admin";
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");

    try {
      const result = await signIn("credentials", {
        redirect: false,
        email,
        password,
      });

      if (result?.error) {
        setError("Invalid email or password");
        setIsLoading(false);
        return;
      }

      router.push(callbackUrl);
    } catch (error) {
      setError("An error occurred during login");
      setIsLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold">Login</CardTitle>
          <CardDescription>
            Enter your credentials to access your shop dashboard
          </CardDescription>
        </CardHeader>
        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <ExclamationTriangleIcon className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="you@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="password">Password</Label>
                <Link
                  href="/forgot-password"
                  className="text-sm font-medium text-indigo-600 hover:text-indigo-500"
                >
                  Forgot password?
                </Link>
              </div>
              <Input
                id="password"
                type="password"
                placeholder="••••••••"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
              />
            </div>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? "Signing in..." : "Sign in"}
            </Button>
          </form>
        </CardContent>
        <CardFooter className="flex flex-col space-y-4">
          <div className="text-sm text-center">
            Don't have an account?{" "}
            <Link
              href="/register"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              Sign up
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}

File: ./src/app/page.tsx
// src/app/page.tsx
import { Metadata } from "next";
import Link from "next/link";
import Image from "next/image";
import { db } from "@/lib/prisma";

export const metadata: Metadata = {
  title: "Welcome to Para Shop",
  description: "The best online shopping experience",
};

async function getFeaturedProducts() {
  const subdomain = process.env.SHOP_SUBDOMAIN || "para";

  // Get shop ID first
  const shop = await db.shop.findUnique({
    where: {
      subdomain: subdomain,
    },
    select: {
      id: true,
    },
  });

  if (!shop) return [];

  // Get featured products
  const products = await db.product.findMany({
    where: {
      shopId: shop.id,
      inventory: {
        gt: 0,
      },
    },
    select: {
      id: true,
      name: true,
      slug: true,
      price: true,
      images: true,
    },
    orderBy: {
      createdAt: "desc",
    },
    take: 8,
  });

  return products;
}

async function getCategories() {
  const subdomain = process.env.SHOP_SUBDOMAIN || "para";

  // Get shop ID first
  const shop = await db.shop.findUnique({
    where: {
      subdomain: subdomain,
    },
    select: {
      id: true,
    },
  });

  if (!shop) return [];

  // Get top level categories
  const categories = await db.category.findMany({
    where: {
      shopId: shop.id,
      parentId: null,
    },
    select: {
      id: true,
      name: true,
      slug: true,
      image: true,
    },
  });

  return categories;
}

export default async function HomePage() {
  const products = await getFeaturedProducts();
  const categories = await getCategories();

  return (
    <div className="bg-white">
      {/* Hero section */}
      <div className="relative">
        <div className="mx-auto max-w-7xl">
          <div className="relative z-10 pt-14 lg:w-full lg:max-w-2xl">
            <div className="relative px-6 py-32 sm:py-40 lg:px-8 lg:py-56 lg:pr-0">
              <div className="mx-auto max-w-2xl lg:mx-0 lg:max-w-xl">
                <h1 className="text-4xl font-bold tracking-tight text-gray-900 sm:text-6xl">
                  Welcome to Para Shop
                </h1>
                <p className="mt-6 text-lg leading-8 text-gray-600">
                  Discover amazing products at great prices. Shop with
                  confidence and enjoy our fast delivery and customer service.
                </p>
                <div className="mt-10 flex items-center gap-x-6">
                  <Link
                    href="/products"
                    className="rounded-md bg-indigo-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600"
                  >
                    Shop Now
                  </Link>
                  <Link
                    href="/categories"
                    className="text-sm font-semibold leading-6 text-gray-900"
                  >
                    Browse Categories <span aria-hidden="true">→</span>
                  </Link>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Categories section */}
      <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
        <div className="mx-auto max-w-2xl py-16 sm:py-24 lg:max-w-none lg:py-12">
          <h2 className="text-2xl font-bold text-gray-900">Categories</h2>

          <div className="mt-6 space-y-12 lg:grid lg:grid-cols-3 lg:gap-x-6 lg:space-y-0">
            {categories.map((category) => (
              <div key={category.id} className="group relative">
                <div className="relative h-80 w-full overflow-hidden rounded-lg bg-white sm:aspect-h-1 sm:aspect-w-2 lg:aspect-h-1 lg:aspect-w-1 group-hover:opacity-75 sm:h-64">
                  {category.image ? (
                    <Image
                      src={category.image}
                      alt={category.name}
                      className="h-full w-full object-cover object-center"
                      width={500}
                      height={500}
                    />
                  ) : (
                    <div className="h-full w-full bg-gray-200 flex items-center justify-center">
                      <span className="text-gray-500">{category.name}</span>
                    </div>
                  )}
                </div>
                <h3 className="mt-6 text-sm text-gray-500">
                  <Link href={`/categories/${category.slug}`}>
                    <span className="absolute inset-0" />
                    {category.name}
                  </Link>
                </h3>
                <p className="text-base font-semibold text-gray-900">
                  Browse collection
                </p>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Featured products section */}
      <div className="bg-white">
        <div className="mx-auto max-w-2xl px-4 py-16 sm:px-6 sm:py-24 lg:max-w-7xl lg:px-8">
          <h2 className="text-2xl font-bold tracking-tight text-gray-900">
            Featured Products
          </h2>

          <div className="mt-6 grid grid-cols-1 gap-x-6 gap-y-10 sm:grid-cols-2 lg:grid-cols-4 xl:gap-x-8">
            {products.map((product) => (
              <div key={product.id} className="group relative">
                <div className="aspect-h-1 aspect-w-1 w-full overflow-hidden rounded-md bg-gray-200 lg:aspect-none group-hover:opacity-75 lg:h-80">
                  {product.images?.[0] ? (
                    <Image
                      src={product.images[0]}
                      alt={product.name}
                      className="h-full w-full object-cover object-center lg:h-full lg:w-full"
                      width={300}
                      height={300}
                    />
                  ) : (
                    <div className="h-full w-full bg-gray-200 flex items-center justify-center">
                      <span className="text-gray-500">No image</span>
                    </div>
                  )}
                </div>
                <div className="mt-4 flex justify-between">
                  <div>
                    <h3 className="text-sm text-gray-700">
                      <Link href={`/products/${product.slug}`}>
                        <span aria-hidden="true" className="absolute inset-0" />
                        {product.name}
                      </Link>
                    </h3>
                  </div>
                  <p className="text-sm font-medium text-gray-900">
                    ${product.price.toFixed(2)}
                  </p>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

File: ./src/app/layout.tsx
// src/app/layout.tsx
import "./globals.css";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { cn } from "@/lib/utils";
import { ShopProvider } from "@/components/providers/shop-provider";
import { SessionProvider } from "@/components/providers/session-provider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Para Shop",
  description: "Your online store",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body
        className={cn(
          "min-h-screen bg-white font-sans antialiased",
          inter.className
        )}
      >
        <SessionProvider>
          <ShopProvider>{children}</ShopProvider>
        </SessionProvider>
      </body>
    </html>
  );
}

File: ./src/app/admin/page.tsx
// src/app/admin/page.tsx
import { getServerSession } from "next-auth/next";
import { db } from "@/lib/prisma";
import { authOptions } from "@/lib/auth";
import { formatCurrency } from "@/lib/utils";
import { canViewAdvancedStats } from "@/lib/permissions";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  ArrowUp,
  ArrowDown,
  ShoppingCart,
  Users,
  DollarSign,
  Package,
} from "lucide-react";
import { SubscriptionInfo } from "@/components/admin/subscription-info";

export default async function AdminDashboardPage() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    return <div>Shop not found</div>;
  }

  const shopId = session.user.shopId;

  // Get shop data with subscription
  const shop = await db.shop.findUnique({
    where: { id: shopId },
    include: {
      settings: true,
      subscription: {
        include: {
          payments: true,
        },
      },
    },
  });

  if (!shop) {
    return <div>Shop not found</div>;
  }

  // Get count of products
  const productCount = await db.product.count({
    where: { shopId },
  });

  // Get count of customers
  const customerCount = await db.user.count({
    where: {
      shopId,
      role: "CUSTOMER",
    },
  });

  // Get count of orders
  const orderCount = await db.order.count({
    where: { shopId },
  });

  // Get total revenue
  const ordersWithTotal = await db.order.findMany({
    where: {
      shopId,
      status: { notIn: ["CANCELLED", "REFUNDED"] },
    },
    select: { total: true },
  });

  const totalRevenue = ordersWithTotal.reduce(
    (sum, order) => sum + order.total,
    0
  );

  // Get recent orders
  const recentOrders = await db.order.findMany({
    where: { shopId },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
    orderBy: { createdAt: "desc" },
    take: 5,
  });

  // Get low stock products
  const lowStockProducts = await db.product.findMany({
    where: {
      shopId,
      lowStockAlert: true,
    },
    take: 5,
  });

  // Prepare subscription data for the component
  let subscriptionData = null;
  if (shop.subscription) {
    const sub = shop.subscription;

    // Calculate total paid amount
    const paidAmount = sub.payments
      .filter((payment) => payment.status === "COMPLETED")
      .reduce((sum, payment) => sum + payment.amount, 0);

    // Calculate days remaining
    const now = new Date();
    const endDate = new Date(sub.endDate);
    const daysRemaining = Math.max(
      0,
      Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
    );

    subscriptionData = {
      id: sub.id,
      planType: shop.planType,
      period: sub.period,
      startDate: sub.startDate.toISOString(),
      endDate: sub.endDate.toISOString(),
      status: sub.status,
      totalAmount: sub.totalAmount,
      appliedDiscount: sub.appliedDiscount,
      paidAmount,
      remainingAmount: Math.max(0, sub.totalAmount - paidAmount),
      daysRemaining,
      isActive: sub.status === "ACTIVE" && endDate > now,
    };
  }

  // Check if the user can view advanced stats
  const showAdvancedStats = canViewAdvancedStats(session.user);

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold tracking-tight text-gray-700">
        Dashboard
      </h1>

      {/* Subscription Information (only for SHOP_ADMIN) */}
      <SubscriptionInfo subscription={subscriptionData} />

      {/* Basic Stats - available to all */}
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Products</CardTitle>
            <Package className="h-4 w-4 text-gray-500" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{productCount}</div>
            <p className="text-xs text-gray-500">
              {lowStockProducts.length} with low stock
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Customers</CardTitle>
            <Users className="h-4 w-4 text-gray-500" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{customerCount}</div>
            <p className="text-xs text-gray-500">Active customers</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Orders</CardTitle>
            <ShoppingCart className="h-4 w-4 text-gray-500" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{orderCount}</div>
            <p className="text-xs text-gray-500">Total orders</p>
          </CardContent>
        </Card>

        {/* Revenue - Only shown for ADVANCED/PREMIUM */}
        {showAdvancedStats && (
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">
                Total Revenue
              </CardTitle>
              <DollarSign className="h-4 w-4 text-gray-500" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">
                {formatCurrency(totalRevenue)}
              </div>
              <p className="text-xs text-gray-500">
                Total from {orderCount} orders
              </p>
            </CardContent>
          </Card>
        )}
      </div>

      {/* Advanced stats - Only shown for ADVANCED/PREMIUM */}
      {showAdvancedStats && (
        <div className="grid gap-6 md:grid-cols-2">
          <Card>
            <CardHeader>
              <CardTitle>Recent Orders</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {recentOrders.length > 0 ? (
                  recentOrders.map((order) => (
                    <div key={order.id} className="flex items-center">
                      <div className="ml-4 space-y-1">
                        <p className="text-sm font-medium leading-none">
                          {order.orderNumber}
                        </p>
                        <p className="text-sm text-gray-500">
                          {order.user.name || order.user.email}
                        </p>
                      </div>
                      <div className="ml-auto font-medium">
                        {formatCurrency(order.total)}
                      </div>
                    </div>
                  ))
                ) : (
                  <p className="text-sm text-gray-500">No orders yet</p>
                )}
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Low Stock Products</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {lowStockProducts.length > 0 ? (
                  lowStockProducts.map((product) => (
                    <div key={product.id} className="flex items-center">
                      <div className="ml-4 space-y-1">
                        <p className="text-sm font-medium leading-none">
                          {product.name}
                        </p>
                        <p className="text-sm text-gray-500">
                          {product.inventory} units left
                        </p>
                      </div>
                      <div className="ml-auto font-medium">
                        {formatCurrency(product.price)}
                      </div>
                    </div>
                  ))
                ) : (
                  <p className="text-sm text-gray-500">No low stock products</p>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      )}
    </div>
  );
}

File: ./src/app/admin/discount-codes/page.tsx
// src/app/admin/discount-codes/page.tsx
import { getServerSession } from "next-auth/next";
import Link from "next/link";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Plus } from "lucide-react";
import DiscountCodeListActions from "@/components/admin/discount-code-list-actions";
import Pagination from "@/components/admin/pagination";

export default async function DiscountCodesPage({
  searchParams,
}: {
  searchParams: {
    page?: string;
    perPage?: string;
    product?: string;
    user?: string;
  };
}) {
  // Check authentication
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/discount-codes");
  }

  const shopId = session.user.shopId;

  // Parse pagination params
  const page = parseInt(searchParams.page || "1");
  const perPage = parseInt(searchParams.perPage || "10");
  const productId = searchParams.product;
  const userId = searchParams.user;

  // Build where clause for filtering
  const where: any = { shopId };

  // Filter by specific product if requested
  if (productId) {
    where.productId = productId;
  }

  // Filter by specific user if requested
  if (userId) {
    where.userId = userId;
  }

  // Count total discount codes for pagination
  const totalDiscountCodes = await db.discountCode.count({
    where,
  });

  // Calculate total pages
  const totalPages = Math.ceil(totalDiscountCodes / perPage);

  // Get discount codes with pagination
  const discountCodes = await db.discountCode.findMany({
    where,
    include: {
      product: {
        select: {
          id: true,
          name: true,
        },
      },
      user: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: {
      createdAt: "desc",
    },
    skip: (page - 1) * perPage,
    take: perPage,
  });

  // Format dates for display
  const formatDate = (date: Date | string) => {
    return new Date(date).toLocaleDateString();
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            Discount Codes
          </h1>
          <p className="text-gray-500 mt-1">
            Manage promotional codes for your customers
          </p>
        </div>
        <Link href="/admin/discount-codes/new">
          <Button>
            <Plus className="mr-2 h-4 w-4" />
            Add Discount Code
          </Button>
        </Link>
      </div>

      <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
        <Table>
          <TableHeader className="bg-gray-50">
            <TableRow>
              <TableHead className="text-gray-700">Code</TableHead>
              <TableHead className="text-gray-700">Discount</TableHead>
              <TableHead className="text-gray-700">Valid Period</TableHead>
              <TableHead className="text-gray-700">Applied To</TableHead>
              <TableHead className="text-gray-700">Status</TableHead>
              <TableHead className="text-right text-gray-700">
                Actions
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {discountCodes.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={6}
                  className="text-center py-8 text-gray-600"
                >
                  No discount codes found.{" "}
                  <Link
                    href="/admin/discount-codes/new"
                    className="text-indigo-600 hover:underline"
                  >
                    Add your first discount code
                  </Link>
                  .
                </TableCell>
              </TableRow>
            ) : (
              discountCodes.map((code) => (
                <TableRow key={code.id}>
                  <TableCell className="font-medium uppercase">
                    {code.code}
                  </TableCell>
                  <TableCell>{code.percentage}% OFF</TableCell>
                  <TableCell>
                    {formatDate(code.startDate)} to {formatDate(code.endDate)}
                  </TableCell>
                  <TableCell>
                    {code.product ? (
                      <Link
                        href={`/admin/products/${code.product.id}`}
                        className="text-indigo-600 hover:underline"
                      >
                        {code.product.name}
                      </Link>
                    ) : (
                      <span>All Products</span>
                    )}
                    <br />
                    {code.user ? (
                      <Link
                        href={`/admin/customers/${code.user.id}`}
                        className="text-indigo-600 hover:underline"
                      >
                        {code.user.name || code.user.email}
                      </Link>
                    ) : (
                      <span>All Users</span>
                    )}
                  </TableCell>
                  <TableCell>
                    <span
                      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                        code.isActive
                          ? "bg-green-100 text-green-800"
                          : "bg-gray-100 text-gray-800"
                      }`}
                    >
                      {code.isActive ? "Active" : "Inactive"}
                    </span>
                  </TableCell>
                  <TableCell className="text-right">
                    <DiscountCodeListActions discountCodeId={code.id} />
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination using client component */}
      <Pagination
        currentPage={page}
        totalPages={totalPages}
        totalItems={totalDiscountCodes}
      />
    </div>
  );
}

File: ./src/app/admin/layout.tsx
// src/app/admin/layout.tsx
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import AdminSidebar from "@/components/admin/sidebar";
import AdminHeader from "@/components/admin/header";
import { ToastsProvider } from "@/components/providers/toast-provider";

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);

  // Check if user is authenticated and has proper role
  if (
    !session ||
    (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
  ) {
    redirect("/login?callbackUrl=/admin");
  }

  return (
    <div className="flex h-screen bg-gray-100">
      <AdminSidebar />
      <div className="flex-1 flex flex-col overflow-hidden">
        <AdminHeader />
        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100 p-6">
          {children}
        </main>
        <ToastsProvider />
      </div>
    </div>
  );
}

File: ./src/app/admin/products/[id]/page.tsx
// src/app/admin/products/[id]/page.tsx
import { getServerSession } from "next-auth/next";
import { redirect, notFound } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import ProductForm from "@/components/admin/product-form";

interface EditProductPageProps {
  params: {
    id: string;
  };
}

export default async function EditProductPage({
  params,
}: EditProductPageProps) {
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/products");
  }

  const shopId = session.user.shopId;

  // Get the product
  const product = await db.product.findUnique({
    where: {
      id: params.id,
      shopId, // Ensure it belongs to this shop
    },
    include: {
      categories: true,
      variants: true,
      customFields: {
        include: {
          customField: true,
        },
      },
    },
  });

  if (!product) {
    notFound();
  }

  // Get all categories for the shop with hierarchy information
  const allCategories = await db.category.findMany({
    where: { shopId },
    select: {
      id: true,
      name: true,
      parentId: true,
    },
  });

  // Map categories with level information
  // This recursive function determines the depth level of each category
  const addLevelToCategories = (
    categories: any[],
    parentId: string | null = null,
    level = 0
  ) => {
    return categories
      .filter((category) => category.parentId === parentId)
      .map((category) => ({
        id: category.id,
        name: category.name,
        level,
        parentId: category.parentId,
      }));
  };

  // Function to create flat array with correct level
  const createFlatCategoriesWithLevels = (categories: any[]) => {
    // First get all root categories (those with no parent)
    let result = addLevelToCategories(categories);

    // For each root category, recursively add its children
    for (let i = 0; i < result.length; i++) {
      const category = result[i];
      const children = addLevelToCategories(
        categories,
        category.id,
        category.level + 1
      );

      // Insert children after their parent
      if (children.length > 0) {
        result.splice(i + 1, 0, ...children);
        // Skip the children we just added
        i += children.length;
      }
    }

    return result;
  };

  const flatCategories = createFlatCategoriesWithLevels(allCategories);

  // Get all custom fields for the shop
  const customFields = await db.customField.findMany({
    where: { shopId },
    orderBy: { name: "asc" },
  });

  return (
    <div>
      <div className="text-2xl font-bold tracking-tight text-gray-800 mb-6">
        Edit Product: {product.name}
      </div>

      <ProductForm
        product={product}
        categories={flatCategories}
        customFields={customFields}
        shopId={shopId}
        isEditing
      />
    </div>
  );
}

File: ./src/app/admin/products/new/page.tsx
// src/app/admin/products/new/page.tsx
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import ProductForm from "@/components/admin/product-form";

export default async function NewProductPage() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/products/new");
  }

  const shopId = session.user.shopId;

  // Get all categories for the shop with hierarchy information
  const allCategories = await db.category.findMany({
    where: { shopId },
    select: {
      id: true,
      name: true,
      parentId: true,
    },
  });

  // Map categories with level information
  // This recursive function determines the depth level of each category
  const addLevelToCategories = (
    categories: any[],
    parentId: string | null = null,
    level = 0
  ) => {
    return categories
      .filter((category) => category.parentId === parentId)
      .map((category) => ({
        id: category.id,
        name: category.name,
        level,
        parentId: category.parentId,
      }));
  };

  // Function to create flat array with correct level
  const createFlatCategoriesWithLevels = (categories: any[]) => {
    // First get all root categories (those with no parent)
    let result = addLevelToCategories(categories);

    // For each root category, recursively add its children
    for (let i = 0; i < result.length; i++) {
      const category = result[i];
      const children = addLevelToCategories(
        categories,
        category.id,
        category.level + 1
      );

      // Insert children after their parent
      if (children.length > 0) {
        result.splice(i + 1, 0, ...children);
        // Skip the children we just added
        i += children.length;
      }
    }

    return result;
  };

  const flatCategories = createFlatCategoriesWithLevels(allCategories);

  // Get all custom fields for the shop
  const customFields = await db.customField.findMany({
    where: { shopId },
    orderBy: { name: "asc" },
  });

  return (
    <div>
      <div className="text-2xl font-bold tracking-tight text-gray-800 mb-6">
        Add New Product
      </div>

      <ProductForm
        categories={flatCategories}
        customFields={customFields}
        shopId={shopId}
      />
    </div>
  );
}

File: ./src/app/admin/products/page.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import Link from "next/link";
import Image from "next/image";
import { useSession } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";
import { formatCurrency } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Card, CardContent } from "@/components/ui/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Plus,
  LayoutGrid,
  List,
  SlidersHorizontal,
  FileDown,
  FilePlus,
  Tag,
  ShoppingBag,
  Loader2,
} from "lucide-react";
import ProductListActions from "@/components/admin/product-list-actions";
import ProductPagination from "@/components/admin/product-pagination";
import ProductFilters from "@/components/admin/product-filters";
import { Badge } from "@/components/ui/badge";
import { apiClient } from "@/lib/api-client";
import { useToast } from "@/components/ui/use-toast";

// Define type for Product and category
interface Category {
  id: string;
  name: string;
  slug?: string;
  level?: number;
  parentId?: string | null;
}

interface ProductCounts {
  variants: number;
  orderItems: number;
}

interface Product {
  id: string;
  name: string;
  description?: string;
  price: number;
  sku?: string;
  barcode?: string;
  inventory: number;
  images: string[];
  categories: Category[];
  _count: ProductCounts;
  discounts: Array<{
    id: string;
    percentage: number;
  }>;
}

export default function ProductsPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const searchParams = useSearchParams();
  const { toast } = useToast();

  // Store the previous search params to prevent unnecessary refetching
  const prevSearchParamsRef = useRef<string>("");

  // State variables
  const [isLoading, setIsLoading] = useState(true);
  const [products, setProducts] = useState<Product[]>([]);
  const [categories, setCategories] = useState<Category[]>([]);
  const [totalProducts, setTotalProducts] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [lowStockThreshold, setLowStockThreshold] = useState(5);
  const [productStats, setProductStats] = useState({
    totalInventory: 0,
    lowStockCount: 0,
    outOfStockCount: 0,
  });
  const [fetchAttempted, setFetchAttempted] = useState(false);

  // Parse query parameters
  const page = parseInt(searchParams.get("page") || "1");
  const perPage = parseInt(searchParams.get("perPage") || "10");
  const sort = searchParams.get("sort") || "createdAt";
  const order = searchParams.get("order") || "desc";
  const search = searchParams.get("search") || "";
  const categoryId = searchParams.get("category") || "";
  const inStock = searchParams.get("inStock") === "true";
  const lowStock = searchParams.get("lowStock") === "true";
  const viewMode = searchParams.get("view") || "list";

  // Create a serialized string of the current search params
  const currentSearchParams = JSON.stringify({
    page,
    perPage,
    sort,
    order,
    search,
    categoryId,
    inStock,
    lowStock,
    viewMode,
  });

  // Fetch data effect
  useEffect(() => {
    // Only run if we have an active session and search params have changed
    if (status === "loading" || !session?.user?.shopId || fetchAttempted) {
      return;
    }

    // Compare with previous search params
    if (prevSearchParamsRef.current === currentSearchParams) {
      return;
    }

    setFetchAttempted(true);

    const fetchData = async () => {
      setIsLoading(true);

      try {
        // Fetch categories only once
        if (categories.length === 0) {
          try {
            const categoriesResponse = await fetch("/api/categories");
            if (categoriesResponse.ok) {
              const categoriesData = await categoriesResponse.json();
              setCategories(categoriesData);
            } else {
              console.error(
                "Failed to fetch categories:",
                categoriesResponse.statusText
              );
              setCategories([]);
            }
          } catch (error) {
            console.error("Error fetching categories:", error);
            setCategories([]);
          }
        }

        // Fetch products
        const productsResponse = await apiClient.products.getProducts({
          page,
          perPage,
          sort,
          order,
          search,
          category: categoryId,
          inStock: inStock ? "true" : undefined,
          lowStock: lowStock ? "true" : undefined,
          view: viewMode,
        });

        setProducts(productsResponse.products);
        setTotalProducts(productsResponse.pagination.total);
        setTotalPages(productsResponse.pagination.totalPages);
        setLowStockThreshold(productsResponse.filter.lowStockThreshold);
        setProductStats(productsResponse.stats);

        // Update previous search params
        prevSearchParamsRef.current = currentSearchParams;
      } catch (error) {
        console.error("Error fetching products:", error);
        toast({
          title: "Error",
          description: "Failed to load products",
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
        setFetchAttempted(false);
      }
    };

    fetchData();
  }, [
    session,
    status,
    currentSearchParams,
    categories.length,
    fetchAttempted,
    toast,
  ]);

  // If loading or not authenticated
  if (status === "loading" || !session) {
    return (
      <div className="flex items-center justify-center h-96">
        <Loader2 className="h-8 w-8 animate-spin text-indigo-500" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            Products
          </h1>
          <p className="text-sm text-gray-500 mt-1">
            Manage your products, inventory, and categories
          </p>
        </div>
        <div className="flex gap-2">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline">
                <SlidersHorizontal className="h-4 w-4 mr-2" />
                Actions
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Product Management</DropdownMenuLabel>
              <DropdownMenuItem asChild>
                <Link
                  href="/admin/products/import"
                  className="flex items-center cursor-pointer"
                >
                  <FileDown className="h-4 w-4 mr-2" />
                  Import Products
                </Link>
              </DropdownMenuItem>
              <DropdownMenuItem asChild>
                <Link
                  href="/admin/products/export"
                  className="flex items-center cursor-pointer"
                >
                  <FilePlus className="h-4 w-4 mr-2" />
                  Export Products
                </Link>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuLabel>View</DropdownMenuLabel>
              <DropdownMenuItem asChild>
                <Link
                  href={`/admin/products?view=list${searchParams
                    .toString()
                    .replace(/^\?/, "&")
                    .replace(/view=[^&]*&?/, "")}`}
                  className="flex items-center cursor-pointer"
                >
                  <List className="h-4 w-4 mr-2" />
                  List View
                </Link>
              </DropdownMenuItem>
              <DropdownMenuItem asChild>
                <Link
                  href={`/admin/products?view=grid${searchParams
                    .toString()
                    .replace(/^\?/, "&")
                    .replace(/view=[^&]*&?/, "")}`}
                  className="flex items-center cursor-pointer"
                >
                  <LayoutGrid className="h-4 w-4 mr-2" />
                  Grid View
                </Link>
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <Link href="/admin/products/new">
            <Button>
              <Plus className="h-4 w-4 mr-2" />
              Add Product
            </Button>
          </Link>
        </div>
      </div>

      {/* Statistics summary */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
          <div className="text-sm text-gray-500">Total Products</div>
          <div className="text-2xl font-bold text-gray-800 mt-1">
            {totalProducts}
          </div>
        </div>

        <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
          <div className="text-sm text-gray-500">Total Inventory</div>
          <div className="text-2xl font-bold text-gray-800 mt-1">
            {productStats.totalInventory || 0} units
          </div>
        </div>

        <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
          <div className="text-sm text-gray-500">Inventory Status</div>
          <div className="flex gap-2 mt-1">
            <Badge
              variant="outline"
              className="bg-amber-50 text-amber-700 border-amber-200"
            >
              {productStats.lowStockCount || 0} Low Stock
            </Badge>
            <Badge
              variant="outline"
              className="bg-red-50 text-red-700 border-red-200"
            >
              {productStats.outOfStockCount || 0} Out of Stock
            </Badge>
          </div>
        </div>
      </div>

      <ProductFilters
        categories={categories}
        currentFilters={{
          search,
          category: categoryId,
          inStock: inStock ? "true" : undefined,
          lowStock: lowStock ? "true" : undefined,
          page: page.toString(),
          perPage: perPage.toString(),
          sort,
          order,
        }}
        lowStockThreshold={lowStockThreshold}
      />

      {isLoading ? (
        <div className="flex items-center justify-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-indigo-500" />
        </div>
      ) : (
        <>
          {/* List View */}
          {viewMode === "list" && (
            <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
              <Table>
                <TableHeader className="bg-gray-50">
                  <TableRow>
                    <TableHead className="text-gray-700">Product</TableHead>
                    <TableHead className="text-gray-700">Price</TableHead>
                    <TableHead className="text-gray-700">Inventory</TableHead>
                    <TableHead className="text-gray-700">Categories</TableHead>
                    <TableHead className="text-gray-700">Variants</TableHead>
                    <TableHead className="text-gray-700">Barcode/SKU</TableHead>
                    <TableHead className="text-gray-700">Discount</TableHead>
                    <TableHead className="text-gray-700">Orders</TableHead>
                    <TableHead className="text-right text-gray-700">
                      Actions
                    </TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {products.length === 0 ? (
                    <TableRow>
                      <TableCell
                        colSpan={9}
                        className="text-center py-8 text-gray-600"
                      >
                        No products found.{" "}
                        <Link
                          href="/admin/products/new"
                          className="text-indigo-600 hover:underline"
                        >
                          Create your first product
                        </Link>
                        .
                      </TableCell>
                    </TableRow>
                  ) : (
                    products.map((product) => (
                      <TableRow key={product.id} className="hover:bg-gray-50">
                        <TableCell>
                          <div className="flex items-center space-x-3">
                            <div className="flex-shrink-0 h-10 w-10 rounded bg-gray-100 flex items-center justify-center overflow-hidden">
                              {product.images && product.images[0] ? (
                                <Image
                                  src={product.images[0]}
                                  alt={product.name}
                                  width={40}
                                  height={40}
                                  className="object-cover"
                                />
                              ) : (
                                <div className="text-gray-400 text-xs">
                                  No image
                                </div>
                              )}
                            </div>
                            <div>
                              <Link
                                href={`/admin/products/${product.id}`}
                                className="font-medium text-gray-800 hover:text-indigo-600 hover:underline"
                              >
                                {product.name}
                              </Link>
                              {product.description && (
                                <div className="text-xs text-gray-500 mt-0.5 max-w-xs truncate">
                                  {product.description}
                                </div>
                              )}
                            </div>
                          </div>
                        </TableCell>
                        <TableCell className="text-gray-700">
                          {formatCurrency(product.price)}
                          {product.discounts &&
                            product.discounts.length > 0 && (
                              <div className="text-xs text-gray-500 line-through">
                                {formatCurrency(
                                  product.price *
                                    (1 + product.discounts[0].percentage / 100)
                                )}
                              </div>
                            )}
                        </TableCell>
                        <TableCell>
                          <span
                            className={
                              product.inventory <= 0
                                ? "text-red-500 font-medium"
                                : product.inventory <= lowStockThreshold
                                ? "text-amber-500 font-medium"
                                : "text-gray-700"
                            }
                          >
                            {product.inventory}
                          </span>
                          {product.inventory <= lowStockThreshold &&
                            product.inventory > 0 && (
                              <span className="ml-2 text-xs text-amber-500">
                                (Low)
                              </span>
                            )}
                        </TableCell>
                        <TableCell className="text-gray-700">
                          <div className="flex flex-wrap gap-1">
                            {product.categories &&
                            product.categories.length > 0 ? (
                              product.categories.map((category) => (
                                <Badge
                                  key={category.id}
                                  variant="outline"
                                  className="bg-blue-50 text-blue-700 border-blue-200"
                                >
                                  {category.name}
                                </Badge>
                              ))
                            ) : (
                              <span className="text-gray-400 text-xs">
                                No categories
                              </span>
                            )}
                          </div>
                        </TableCell>
                        <TableCell className="text-gray-700">
                          {product._count && product._count.variants > 0 ? (
                            <Badge
                              variant="outline"
                              className="bg-purple-50 text-purple-700 border-purple-200"
                            >
                              {product._count.variants} variants
                            </Badge>
                          ) : (
                            <span className="text-gray-400 text-xs">
                              No variants
                            </span>
                          )}
                        </TableCell>
                        <TableCell className="text-gray-700">
                          <div className="text-xs">
                            {product.barcode && (
                              <div className="flex items-center">
                                <span className="text-gray-500 mr-1">
                                  Barcode:
                                </span>
                                <span className="text-gray-700">
                                  {product.barcode}
                                </span>
                              </div>
                            )}
                            {product.sku && (
                              <div className="flex items-center">
                                <span className="text-gray-500 mr-1">SKU:</span>
                                <span className="text-gray-700">
                                  {product.sku}
                                </span>
                              </div>
                            )}
                            {!product.barcode && !product.sku && (
                              <span className="text-gray-400">Not set</span>
                            )}
                          </div>
                        </TableCell>
                        <TableCell>
                          {product.discounts && product.discounts.length > 0 ? (
                            <div className="flex items-center">
                              <Tag className="h-3 w-3 text-green-600 mr-1" />
                              <span className="text-green-600 font-medium">
                                {product.discounts[0].percentage}% OFF
                              </span>
                            </div>
                          ) : (
                            <span className="text-gray-400 text-xs">
                              No discount
                            </span>
                          )}
                        </TableCell>
                        <TableCell>
                          {product._count && product._count.orderItems > 0 ? (
                            <div className="flex items-center">
                              <ShoppingBag className="h-3 w-3 text-blue-600 mr-1" />
                              <span className="text-blue-600">
                                {product._count.orderItems}
                              </span>
                            </div>
                          ) : (
                            <span className="text-gray-400 text-xs">None</span>
                          )}
                        </TableCell>
                        <TableCell className="text-right">
                          <ProductListActions productId={product.id} />
                        </TableCell>
                      </TableRow>
                    ))
                  )}
                </TableBody>
              </Table>
            </div>
          )}

          {/* Grid View */}
          {viewMode === "grid" && (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
              {products.length === 0 ? (
                <div className="col-span-full bg-white border border-gray-200 rounded-lg p-6 text-center">
                  <p className="text-gray-600">
                    No products found.{" "}
                    <Link
                      href="/admin/products/new"
                      className="text-indigo-600 hover:underline"
                    >
                      Create your first product
                    </Link>
                    .
                  </p>
                </div>
              ) : (
                products.map((product) => (
                  <Card key={product.id} className="overflow-hidden">
                    <div className="h-48 bg-gray-100 relative">
                      {product.images && product.images[0] ? (
                        <Image
                          src={product.images[0]}
                          alt={product.name}
                          fill
                          className="object-cover"
                        />
                      ) : (
                        <div className="flex items-center justify-center h-full text-gray-400">
                          No image
                        </div>
                      )}

                      {/* Discount tag */}
                      {product.discounts && product.discounts.length > 0 && (
                        <div className="absolute top-2 right-2 bg-green-600 text-white px-2 py-1 rounded text-xs font-bold">
                          {product.discounts[0].percentage}% OFF
                        </div>
                      )}

                      {/* Inventory status */}
                      <div className="absolute bottom-2 right-2">
                        {product.inventory <= 0 ? (
                          <Badge variant="destructive">Out of stock</Badge>
                        ) : product.inventory <= lowStockThreshold ? (
                          <Badge
                            variant="outline"
                            className="bg-amber-100 text-amber-800 border-amber-200"
                          >
                            Low stock: {product.inventory}
                          </Badge>
                        ) : (
                          <Badge
                            variant="outline"
                            className="bg-green-100 text-green-800 border-green-200"
                          >
                            In stock: {product.inventory}
                          </Badge>
                        )}
                      </div>
                    </div>

                    <CardContent className="p-4">
                      <h3 className="font-medium text-gray-800 mb-1 truncate">
                        <Link
                          href={`/admin/products/${product.id}`}
                          className="hover:text-indigo-600 hover:underline"
                        >
                          {product.name}
                        </Link>
                      </h3>

                      <div className="flex justify-between items-center mb-2">
                        <div className="text-gray-700 font-medium">
                          {formatCurrency(product.price)}
                        </div>
                        <div className="text-xs text-gray-500">
                          {product._count &&
                            product._count.variants > 0 &&
                            `${product._count.variants} variants`}
                        </div>
                      </div>

                      {/* Categories */}
                      {product.categories && product.categories.length > 0 && (
                        <div className="flex flex-wrap gap-1 mb-2">
                          {product.categories.slice(0, 2).map((category) => (
                            <Badge
                              key={category.id}
                              variant="outline"
                              className="bg-blue-50 text-blue-700 border-blue-200 text-xs"
                            >
                              {category.name}
                            </Badge>
                          ))}
                          {product.categories.length > 2 && (
                            <Badge
                              variant="outline"
                              className="bg-gray-50 text-gray-700 border-gray-200 text-xs"
                            >
                              +{product.categories.length - 2} more
                            </Badge>
                          )}
                        </div>
                      )}

                      <div className="mt-4 flex justify-between items-center">
                        <span className="text-xs text-gray-500">
                          {product._count && product._count.orderItems > 0 ? (
                            <span className="flex items-center">
                              <ShoppingBag className="h-3 w-3 mr-1" />
                              {product._count.orderItems} orders
                            </span>
                          ) : (
                            "No orders"
                          )}
                        </span>
                        <ProductListActions productId={product.id} />
                      </div>
                    </CardContent>
                  </Card>
                ))
              )}
            </div>
          )}

          <ProductPagination
            currentPage={page}
            totalPages={totalPages}
            totalItems={totalProducts}
          />
        </>
      )}
    </div>
  );
}

File: ./src/app/admin/api/shop/route.ts
// src/app/api/admin/shop/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { getSubdomain } from "@/lib/subdomain";

export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get subdomain
    const subdomain = getSubdomain(req);

    // Check if subdomain matches what's in the environment variable
    if (!subdomain || subdomain !== process.env.SHOP_SUBDOMAIN) {
      return NextResponse.json(
        { error: "Shop not found", redirect: "https://store.tn" },
        { status: 404 }
      );
    }

    // Find the shop by subdomain
    const shop = await db.shop.findUnique({
      where: { subdomain },
      include: {
        settings: true,
        owner: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        _count: {
          select: {
            products: true,
            orders: true,
            users: {
              where: { role: "CUSTOMER" },
            },
          },
        },
      },
    });

    if (!shop) {
      return NextResponse.json({ error: "Shop not found" }, { status: 404 });
    }

    // Access control based on role
    if (session.user.role === "ADMIN") {
      // Admin has full access to all shop data
      return NextResponse.json({
        id: shop.id,
        name: shop.name,
        subdomain: shop.subdomain,
        description: shop.description,
        logo: shop.logo,
        planType: shop.planType,
        settings: shop.settings,
        owner: shop.owner,
        stats: {
          products: shop._count.products,
          orders: shop._count.orders,
          customers: shop._count.users,
        },
        isOwner: false,
        isAdmin: true,
      });
    } else if (
      session.user.role === "SHOP_ADMIN" ||
      session.user.role === "SHOP_STAFF"
    ) {
      // Check if user belongs to this shop
      if (session.user.shopId !== shop.id) {
        return NextResponse.json(
          { error: "You do not have permission to access this shop" },
          { status: 403 }
        );
      }

      // Determine if user is the owner
      const isOwner =
        session.user.role === "SHOP_ADMIN" &&
        shop.owner?.id === session.user.id;

      return NextResponse.json({
        id: shop.id,
        name: shop.name,
        subdomain: shop.subdomain,
        description: shop.description,
        logo: shop.logo,
        planType: shop.planType,
        settings: shop.settings,
        stats: {
          products: shop._count.products,
          orders: shop._count.orders,
          customers: shop._count.users,
        },
        isOwner: isOwner,
        isAdmin: false,
        role: session.user.role,
      });
    } else {
      // Customers shouldn't access admin API
      return NextResponse.json({ error: "Access denied" }, { status: 403 });
    }
  } catch (error) {
    console.error("Error fetching admin shop data:", error);
    return NextResponse.json(
      { error: "Failed to fetch shop data" },
      { status: 500 }
    );
  }
}

File: ./src/app/admin/api/shops/route.ts
// src/app/api/admin/shops/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user || session.user.role !== "ADMIN") {
      return NextResponse.json(
        {
          error: "Unauthorized. Only administrators can access this resource.",
        },
        { status: 401 }
      );
    }

    // Parse query parameters for pagination, sorting, and filtering
    const { searchParams } = new URL(req.url);
    const page = parseInt(searchParams.get("page") || "1", 10);
    const perPage = parseInt(searchParams.get("perPage") || "10", 10);
    const sortBy = searchParams.get("sort") || "createdAt";
    const sortDirection = searchParams.get("dir") || "desc";
    const searchQuery = searchParams.get("q") || "";
    const planType = searchParams.get("planType") || "";
    const active = searchParams.get("active");

    // Build where clause
    let where: any = {};

    if (searchQuery) {
      where.OR = [
        { name: { contains: searchQuery, mode: "insensitive" } },
        { subdomain: { contains: searchQuery, mode: "insensitive" } },
        { description: { contains: searchQuery, mode: "insensitive" } },
      ];
    }

    if (planType) {
      where.planType = planType;
    }

    if (active !== null && active !== undefined) {
      where.active = active === "true";
    }

    // Count total shops for pagination
    const totalShops = await db.shop.count({ where });

    // Get shops with pagination, sorting, and filtering
    const shops = await db.shop.findMany({
      where,
      select: {
        id: true,
        name: true,
        subdomain: true,
        description: true,
        logo: true,
        planType: true,
        active: true,
        createdAt: true,
        owner: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        _count: {
          select: {
            products: true,
            orders: true,
            users: true,
          },
        },
      },
      orderBy: {
        [sortBy]: sortDirection,
      },
      skip: (page - 1) * perPage,
      take: perPage,
    });

    return NextResponse.json({
      shops,
      pagination: {
        total: totalShops,
        page,
        perPage,
        totalPages: Math.ceil(totalShops / perPage),
      },
    });
  } catch (error) {
    console.error("Error fetching shops:", error);
    return NextResponse.json(
      { error: "Failed to fetch shops" },
      { status: 500 }
    );
  }
}

File: ./src/app/admin/discounts/[id]/page.tsx
// src/app/admin/discounts/[id]/page.tsx
import { getServerSession } from "next-auth/next";
import { redirect, notFound } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import DiscountForm from "@/components/admin/discount-form";

interface EditDiscountPageProps {
  params: {
    id: string;
  };
}

export default async function EditDiscountPage({
  params,
}: EditDiscountPageProps) {
  // Check authentication
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/discounts");
  }

  const shopId = session.user.shopId;
  const discountId = params.id;

  // Get the discount (with validation that it belongs to this shop)
  const discount = await db.discount.findFirst({
    where: {
      id: discountId,
      product: {
        shopId,
      },
    },
    include: {
      product: {
        select: {
          id: true,
          name: true,
          price: true,
        },
      },
    },
  });

  if (!discount) {
    notFound();
  }

  // Get all products for the shop
  const products = await db.product.findMany({
    where: { shopId },
    select: {
      id: true,
      name: true,
      price: true,
    },
    orderBy: {
      name: "asc",
    },
  });

  return (
    <div>
      <h1 className="text-2xl font-bold tracking-tight text-gray-800 mb-6">
        Edit Discount for {discount.product.name}
      </h1>

      <DiscountForm
        discount={discount}
        products={products}
        shopId={shopId}
        isEditing
      />
    </div>
  );
}

File: ./src/app/admin/discounts/new/page.tsx
// src/app/admin/discounts/new/page.tsx
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import DiscountForm from "@/components/admin/discount-form";

export default async function NewDiscountPage() {
  // Check authentication
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/discounts/new");
  }

  const shopId = session.user.shopId;

  // Get all products for the shop (for the product dropdown)
  const products = await db.product.findMany({
    where: { shopId },
    select: {
      id: true,
      name: true,
      price: true,
    },
    orderBy: {
      name: "asc",
    },
  });

  return (
    <div>
      <h1 className="text-2xl font-bold tracking-tight text-gray-800 mb-6">
        Create New Discount
      </h1>

      <DiscountForm products={products} shopId={shopId} />
    </div>
  );
}

File: ./src/app/admin/discounts/page.tsx
// src/app/admin/discounts/page.tsx
import { getServerSession } from "next-auth/next";
import Link from "next/link";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Plus } from "lucide-react";
import DiscountListActions from "@/components/admin/discount-list-actions";
import Pagination from "@/components/admin/pagination";

export default async function DiscountsPage({
  searchParams,
}: {
  searchParams: { page?: string; perPage?: string; product?: string };
}) {
  // Check authentication
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/discounts");
  }

  const shopId = session.user.shopId;

  // Parse pagination params
  const page = parseInt(searchParams.page || "1");
  const perPage = parseInt(searchParams.perPage || "10");
  const productId = searchParams.product;

  // Build where clause for filtering
  const where: any = {
    product: {
      shopId,
    },
  };

  // Filter by specific product if requested
  if (productId) {
    where.productId = productId;
  }

  // Count total discounts for pagination
  const totalDiscounts = await db.discount.count({
    where,
  });

  // Calculate total pages
  const totalPages = Math.ceil(totalDiscounts / perPage);

  // Get discounts with pagination
  const discounts = await db.discount.findMany({
    where,
    include: {
      product: {
        select: {
          id: true,
          name: true,
          price: true,
        },
      },
    },
    orderBy: {
      createdAt: "desc",
    },
    skip: (page - 1) * perPage,
    take: perPage,
  });

  // Get product info if filtering by product
  let productInfo = null;
  if (productId) {
    productInfo = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
      select: {
        id: true,
        name: true,
      },
    });
  }

  // Format dates for display
  const formatDate = (date: Date | string) => {
    return new Date(date).toLocaleDateString();
  };

  // Calculate the price after discount
  const getDiscountedPrice = (price: number, discountPercentage: number) => {
    const discount = (price * discountPercentage) / 100;
    return (price - discount).toFixed(2);
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            {productInfo
              ? `Discounts for ${productInfo.name}`
              : "All Discounts"}
          </h1>
          {productInfo && (
            <p className="text-gray-500">
              <Link
                href="/admin/discounts"
                className="text-indigo-600 hover:underline"
              >
                Back to all discounts
              </Link>
            </p>
          )}
        </div>
        <Link href="/admin/discounts/new">
          <Button>
            <Plus className="mr-2 h-4 w-4" />
            Add Discount
          </Button>
        </Link>
      </div>

      <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
        <Table>
          <TableHeader className="bg-gray-50">
            <TableRow>
              <TableHead className="text-gray-700">Product</TableHead>
              <TableHead className="text-gray-700">Percentage</TableHead>
              <TableHead className="text-gray-700">Original Price</TableHead>
              <TableHead className="text-gray-700">Discounted Price</TableHead>
              <TableHead className="text-gray-700">Valid Period</TableHead>
              <TableHead className="text-gray-700">Status</TableHead>
              <TableHead className="text-right text-gray-700">
                Actions
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {discounts.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={7}
                  className="text-center py-8 text-gray-600"
                >
                  No discounts found.{" "}
                  <Link
                    href="/admin/discounts/new"
                    className="text-indigo-600 hover:underline"
                  >
                    Add your first discount
                  </Link>
                  .
                </TableCell>
              </TableRow>
            ) : (
              discounts.map((discount) => (
                <TableRow key={discount.id}>
                  <TableCell>
                    <Link
                      href={`/admin/products/${discount.product.id}`}
                      className="font-medium text-indigo-600 hover:underline"
                    >
                      {discount.product.name}
                    </Link>
                  </TableCell>
                  <TableCell className="font-medium">
                    {discount.percentage}%
                  </TableCell>
                  <TableCell>${discount.product.price.toFixed(2)}</TableCell>
                  <TableCell className="text-green-600">
                    $
                    {getDiscountedPrice(
                      discount.product.price,
                      discount.percentage
                    )}
                  </TableCell>
                  <TableCell>
                    {formatDate(discount.startDate)} to{" "}
                    {formatDate(discount.endDate)}
                  </TableCell>
                  <TableCell>
                    <span
                      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                        discount.enabled
                          ? "bg-green-100 text-green-800"
                          : "bg-gray-100 text-gray-800"
                      }`}
                    >
                      {discount.enabled ? "Active" : "Inactive"}
                    </span>
                  </TableCell>
                  <TableCell className="text-right">
                    <DiscountListActions discountId={discount.id} />
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination using client component */}
      <Pagination
        currentPage={page}
        totalPages={totalPages}
        totalItems={totalDiscounts}
      />
    </div>
  );
}

File: ./src/app/admin/custom-fields/page.tsx
// src/app/admin/custom-fields/page.tsx (with improved contrast)
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import CustomFieldsTable from "@/components/admin/custom-fields-table";
import AddCustomFieldForm from "@/components/admin/add-custom-field-form";
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
} from "@/components/ui/card";

export default async function CustomFieldsPage() {
  // Check authentication and authorization
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/custom-fields");
  }

  const shopId = session.user.shopId;

  // Fetch all custom fields for this shop
  const customFields = await db.customField.findMany({
    where: { shopId },
    orderBy: { name: "asc" },
  });

  // Count products using each custom field
  const fieldsWithUsage = await Promise.all(
    customFields.map(async (field) => {
      const usageCount = await db.customFieldValue.count({
        where: { customFieldId: field.id },
      });

      return {
        ...field,
        usageCount,
      };
    })
  );

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold tracking-tight text-gray-800">
          Custom Fields
        </h1>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="md:col-span-2">
          <Card className="border-indigo-200 shadow-sm">
            <CardHeader className="bg-indigo-50 border-b border-indigo-200">
              <CardTitle className="text-indigo-800 font-semibold">
                Custom Fields List
              </CardTitle>
              <CardDescription className="text-indigo-700">
                Manage custom fields for your products
              </CardDescription>
            </CardHeader>
            <CardContent className="p-0 bg-white">
              <CustomFieldsTable customFields={fieldsWithUsage} />
            </CardContent>
          </Card>
        </div>

        <div>
          <Card className="border-indigo-200 shadow-sm">
            <CardHeader className="bg-indigo-50 border-b border-indigo-200">
              <CardTitle className="text-indigo-800 font-semibold">
                Add Custom Field
              </CardTitle>
              <CardDescription className="text-indigo-700">
                Create a new custom field for your products
              </CardDescription>
            </CardHeader>
            <CardContent className="pt-6 bg-white">
              <AddCustomFieldForm />
            </CardContent>
          </Card>

          <div className="mt-6">
            <Card className="border-blue-300 shadow-sm">
              <CardHeader className="bg-blue-100 border-b border-blue-200">
                <CardTitle className="text-blue-800 text-lg font-semibold">
                  About Custom Fields
                </CardTitle>
              </CardHeader>
              <CardContent className="pt-4 bg-white">
                <p className="text-blue-800 text-sm">
                  Custom fields allow you to add additional information to your
                  products beyond the standard fields. This is useful for:
                </p>
                <ul className="list-disc list-inside mt-2 text-blue-800 text-sm space-y-1">
                  <li>Product specifications (material, dimensions, etc.)</li>
                  <li>
                    Technical information (compatibility, system requirements)
                  </li>
                  <li>Additional product details (origin, certification)</li>
                  <li>And any other product-specific information</li>
                </ul>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
}

File: ./src/app/api/auth/register/route.ts
// src/app/api/auth/register/route.ts
import { NextRequest, NextResponse } from "next/server";
import bcrypt from "bcrypt";
import { db } from "@/lib/prisma";
import { z } from "zod";

// Validation schema
const registerSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  shopId: z.string().optional(),
});

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    // Validate input
    const validation = registerSchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      );
    }

    const { name, email, password, shopId } = validation.data;

    // Check if user already exists
    const existingUser = await db.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return NextResponse.json(
        { error: "Email already in use" },
        { status: 400 }
      );
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Determine role based on context
    // For subdomain shops, create a customer account by default
    let role = "CUSTOMER";

    // Create user
    const user = await db.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
        role,
        shopId: shopId || null, // Associate with shop if provided
      },
    });

    // Don't send password back
    const { password: _, ...userWithoutPassword } = user;

    return NextResponse.json(userWithoutPassword, { status: 201 });
  } catch (error) {
    console.error("Registration error:", error);
    return NextResponse.json({ error: "Registration failed" }, { status: 500 });
  }
}

File: ./src/app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

File: ./src/app/api/discount-codes/[id]/route.ts
// src/app/api/discount-codes/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET a specific discount code
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountCodeId = params.id;

    // Get the discount code
    const discountCode = await db.discountCode.findFirst({
      where: {
        id: discountCodeId,
        shopId,
      },
      include: {
        product: {
          select: {
            name: true,
          },
        },
        user: {
          select: {
            name: true,
            email: true,
          },
        },
      },
    });

    if (!discountCode) {
      return NextResponse.json(
        { error: "Discount code not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(discountCode);
  } catch (error) {
    console.error("Error fetching discount code:", error);
    return NextResponse.json(
      { error: "Failed to fetch discount code" },
      { status: 500 }
    );
  }
}

// UPDATE a discount code
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountCodeId = params.id;
    const body = await req.json();
    const {
      code,
      percentage,
      startDate,
      endDate,
      productId,
      userId,
      isActive,
    } = body;

    // Verify the discount code exists and belongs to this shop
    const existingCode = await db.discountCode.findFirst({
      where: {
        id: discountCodeId,
        shopId,
      },
    });

    if (!existingCode) {
      return NextResponse.json(
        { error: "Discount code not found" },
        { status: 404 }
      );
    }

    // Check if updated code already exists (if it's being changed)
    if (code && code !== existingCode.code) {
      const duplicateCode = await db.discountCode.findFirst({
        where: {
          shopId,
          code: {
            equals: code,
            mode: "insensitive",
          },
          id: {
            not: discountCodeId,
          },
        },
      });

      if (duplicateCode) {
        return NextResponse.json(
          { error: "A discount code with this code already exists" },
          { status: 400 }
        );
      }
    }

    // Verify the product belongs to this shop if it's being changed
    if (productId && productId !== existingCode.productId) {
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: "Product not found" },
          { status: 404 }
        );
      }
    }

    // Verify the user belongs to this shop if it's being changed
    if (userId && userId !== existingCode.userId) {
      const user = await db.user.findUnique({
        where: {
          id: userId,
          shopId,
        },
      });

      if (!user) {
        return NextResponse.json({ error: "User not found" }, { status: 404 });
      }
    }

    // Update the discount code
    const updatedDiscountCode = await db.discountCode.update({
      where: { id: discountCodeId },
      data: {
        code: code ? code.toUpperCase() : undefined,
        percentage: percentage !== undefined ? parseInt(percentage) : undefined,
        startDate: startDate ? new Date(startDate) : undefined,
        endDate: endDate ? new Date(endDate) : undefined,
        productId: productId === undefined ? undefined : productId || null,
        userId: userId === undefined ? undefined : userId || null,
        isActive: isActive !== undefined ? isActive === true : undefined,
      },
    });

    return NextResponse.json(updatedDiscountCode);
  } catch (error) {
    console.error("Error updating discount code:", error);
    return NextResponse.json(
      { error: "Failed to update discount code" },
      { status: 500 }
    );
  }
}

// DELETE a discount code
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountCodeId = params.id;

    // Verify the discount code exists and belongs to this shop
    const discountCode = await db.discountCode.findFirst({
      where: {
        id: discountCodeId,
        shopId,
      },
    });

    if (!discountCode) {
      return NextResponse.json(
        { error: "Discount code not found" },
        { status: 404 }
      );
    }

    // Delete the discount code
    await db.discountCode.delete({
      where: { id: discountCodeId },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting discount code:", error);
    return NextResponse.json(
      { error: "Failed to delete discount code" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/discount-codes/route.ts
// src/app/api/discount-codes/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET: List discount codes
export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const { searchParams } = new URL(req.url);
    const productId = searchParams.get("productId");

    // Build the where clause
    const where: any = { shopId };

    // Add product filter if provided
    if (productId) {
      where.productId = productId;

      // Verify the product belongs to this shop
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: "Product not found" },
          { status: 404 }
        );
      }
    }

    // Get discount codes
    const discountCodes = await db.discountCode.findMany({
      where,
      include: {
        product: {
          select: {
            name: true,
          },
        },
        user: {
          select: {
            name: true,
            email: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json(discountCodes);
  } catch (error) {
    console.error("Error fetching discount codes:", error);
    return NextResponse.json(
      { error: "Failed to fetch discount codes" },
      { status: 500 }
    );
  }
}

// POST: Create a new discount code
export async function POST(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const body = await req.json();
    const {
      code,
      percentage,
      startDate,
      endDate,
      productId,
      userId,
      isActive,
    } = body;

    // Validate required fields
    if (!code || !percentage || !startDate || !endDate) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Check if code already exists for this shop
    const existingCode = await db.discountCode.findFirst({
      where: {
        shopId,
        code: {
          equals: code,
          mode: "insensitive", // Case insensitive
        },
      },
    });

    if (existingCode) {
      return NextResponse.json(
        { error: "A discount code with this code already exists" },
        { status: 400 }
      );
    }

    // Verify the product belongs to this shop if provided
    if (productId) {
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: "Product not found" },
          { status: 404 }
        );
      }
    }

    // Verify the user belongs to this shop if provided
    if (userId) {
      const user = await db.user.findUnique({
        where: {
          id: userId,
          shopId,
        },
      });

      if (!user) {
        return NextResponse.json({ error: "User not found" }, { status: 404 });
      }
    }

    // Create the discount code
    const discountCode = await db.discountCode.create({
      data: {
        code: code.toUpperCase(), // Store in uppercase
        percentage: parseInt(percentage),
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        shopId,
        productId: productId || null,
        userId: userId || null,
        isActive: isActive === true,
      },
    });

    return NextResponse.json(discountCode, { status: 201 });
  } catch (error) {
    console.error("Error creating discount code:", error);
    return NextResponse.json(
      { error: "Failed to create discount code" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/orders/[id]/route.ts
// src/app/api/orders/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET a specific order
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const orderId = params.id;

    // Get the order with all details
    const order = await db.order.findUnique({
      where: {
        id: orderId,
        shopId, // Ensure it belongs to this shop
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        address: true,
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                slug: true,
                images: true,
              },
            },
            variant: {
              select: {
                id: true,
                name: true,
                options: true,
              },
            },
          },
        },
        invoice: true,
      },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    return NextResponse.json(order);
  } catch (error) {
    console.error("Error fetching order:", error);
    return NextResponse.json(
      { error: "Failed to fetch order" },
      { status: 500 }
    );
  }
}

// UPDATE an order's status
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user?.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const orderId = params.id;
    const body = await req.json();

    // Extract update fields
    const { status, paymentStatus, shippingStatus, notes } = body;

    // Validate order belongs to this shop
    const order = await db.order.findUnique({
      where: {
        id: orderId,
        shopId,
      },
      select: { id: true },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // Update the order
    const updatedOrder = await db.order.update({
      where: { id: orderId },
      data: {
        status: status || undefined,
        paymentStatus: paymentStatus || undefined,
        shippingStatus: shippingStatus || undefined,
        notes: notes !== undefined ? notes : undefined,
        updatedAt: new Date(),
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        address: true,
        items: true,
        invoice: true,
      },
    });

    // Generate automatic notification if status changed
    if (status && status !== order.status) {
      await db.notification.create({
        data: {
          title: `Order ${updatedOrder.orderNumber} Updated`,
          message: `Your order status has been updated to ${status}`,
          type: "ORDER_UPDATE",
          userId: updatedOrder.userId,
          shopId,
        },
      });
    }

    return NextResponse.json(updatedOrder);
  } catch (error) {
    console.error("Error updating order:", error);
    return NextResponse.json(
      { error: "Failed to update order" },
      { status: 500 }
    );
  }
}

// DELETE an order (soft delete or cancellation)
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user?.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const orderId = params.id;

    // Validate order belongs to this shop
    const order = await db.order.findUnique({
      where: {
        id: orderId,
        shopId,
      },
      include: {
        items: {
          select: {
            productId: true,
            variantId: true,
            quantity: true,
          },
        },
      },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // For safety, we don't actually delete the order, but cancel it
    // This is to preserve order history
    const cancelledOrder = await db.order.update({
      where: { id: orderId },
      data: {
        status: "CANCELLED",
        paymentStatus: "CANCELLED",
        shippingStatus: "CANCELLED",
        updatedAt: new Date(),
      },
    });

    // Restore inventory for cancelled orders
    if (order.items.length > 0) {
      for (const item of order.items) {
        if (item.variantId) {
          // Restore variant inventory
          await db.productVariant.update({
            where: { id: item.variantId },
            data: {
              inventory: {
                increment: item.quantity,
              },
            },
          });
        } else if (item.productId) {
          // Restore product inventory
          await db.product.update({
            where: { id: item.productId },
            data: {
              inventory: {
                increment: item.quantity,
              },
            },
          });
        }
      }
    }

    // Create notification
    await db.notification.create({
      data: {
        title: `Order ${order.orderNumber} Cancelled`,
        message: `Your order has been cancelled.`,
        type: "ORDER_CANCELLED",
        userId: order.userId,
        shopId,
      },
    });

    return NextResponse.json({
      success: true,
      message: "Order has been cancelled",
    });
  } catch (error) {
    console.error("Error cancelling order:", error);
    return NextResponse.json(
      { error: "Failed to cancel order" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/orders/[id]/invoice/route.ts
// src/app/api/orders/[id]/invoice/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { formatCurrency } from "@/lib/utils";
import { hasFeatureAccess, Feature } from "@/lib/feature-authorization";

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Check if user has the invoice generation feature
    if (!hasFeatureAccess(session.user, Feature.INVOICE_GENERATION)) {
      return NextResponse.json(
        {
          error:
            "Access denied. Your plan does not include invoice generation.",
        },
        { status: 403 }
      );
    }

    const shopId = session.user.shopId;
    const orderId = params.id;

    // Get order with all necessary information
    const order = await db.order.findUnique({
      where: {
        id: orderId,
        shopId, // Ensure it belongs to this shop
      },
      include: {
        user: {
          select: {
            name: true,
            email: true,
          },
        },
        address: true,
        items: true, // This includes all stored product information
        invoice: true, // Check if invoice already exists
      },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // Get shop information for invoice
    const shop = await db.shop.findUnique({
      where: { id: shopId },
      include: {
        settings: true,
      },
    });

    if (!shop) {
      return NextResponse.json({ error: "Shop not found" }, { status: 404 });
    }

    // Check if invoice already exists
    if (order.invoice) {
      // Return existing invoice information
      return NextResponse.json({
        invoiceNumber: order.invoice.invoiceNumber,
        pdfUrl: order.invoice.pdfUrl,
        orderId: order.id,
        orderNumber: order.orderNumber,
        date: order.createdAt,
        // Include a link to download the existing invoice
        downloadUrl: `/api/invoices/${order.invoice.id}/download`,
      });
    }

    // Generate invoice number
    const invoiceNumber = `INV-${order.orderNumber.slice(4)}`;

    // Generate PDF content (simplified - in real implementation this would use a PDF library)
    const invoiceData = {
      invoiceNumber,
      orderNumber: order.orderNumber,
      date: order.createdAt,
      dueDate: order.createdAt, // Due immediately for simplicity
      customer: {
        name: order.user.name,
        email: order.user.email,
        address: order.address
          ? {
              line1: order.address.line1,
              line2: order.address.line2,
              city: order.address.city,
              state: order.address.state,
              postalCode: order.address.postalCode,
              country: order.address.country,
            }
          : null,
      },
      shop: {
        name: shop.name,
        address: shop.settings?.address,
        email: shop.settings?.contactEmail,
        phone: shop.settings?.contactPhone,
      },
      items: order.items.map((item) => ({
        // Use stored information from order time, not current product info
        name: item.productName,
        description: item.productDescription,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        originalPrice: item.originalPrice,
        discountPercentage: item.discountPercentage,
        discountAmount: item.discountAmount,
        total: item.total,
        tva: item.productTva,
        tvaTotalAmount: (item.total * item.productTva) / 100,
      })),
      subtotal: order.subtotal,
      tax: order.tax,
      shipping: order.shipping,
      discount: order.discount,
      total: order.total,
      paymentStatus: order.paymentStatus,
    };

    // In a real implementation, you would generate a PDF here
    // For this example, we'll just create the invoice record

    // Create the invoice record
    const invoice = await db.invoice.create({
      data: {
        invoiceNumber,
        orderId: order.id,
        pdfUrl: `/invoices/${invoiceNumber}.pdf`, // This would be the actual PDF URL in production
      },
    });

    // Return invoice data
    return NextResponse.json({
      invoice: {
        id: invoice.id,
        invoiceNumber: invoice.invoiceNumber,
        pdfUrl: invoice.pdfUrl,
        createdAt: invoice.createdAt,
      },
      // Include the full invoice data for rendering
      invoiceData,
    });
  } catch (error) {
    console.error("Error generating invoice:", error);
    return NextResponse.json(
      { error: "Failed to generate invoice" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/orders/route.ts
// src/app/api/orders/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { generateOrderNumber } from "@/lib/utils";

// GET: List all orders with pagination, filtering and sorting
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;

    // Parse query parameters
    const { searchParams } = new URL(req.url);
    const page = parseInt(searchParams.get("page") || "1");
    const perPage = parseInt(searchParams.get("perPage") || "10");
    const status = searchParams.get("status") || undefined;
    const paymentStatus = searchParams.get("paymentStatus") || undefined;
    const search = searchParams.get("search") || "";
    const sortField = searchParams.get("sort") || "createdAt";
    const sortOrder = searchParams.get("order") || "desc";
    const customerId = searchParams.get("customerId") || undefined;

    // Build where clause
    let where: any = { shopId };

    if (status) {
      where.status = status;
    }

    if (paymentStatus) {
      where.paymentStatus = paymentStatus;
    }

    if (customerId) {
      where.userId = customerId;
    }

    if (search) {
      where.OR = [
        { orderNumber: { contains: search, mode: "insensitive" } },
        { user: { name: { contains: search, mode: "insensitive" } } },
        { user: { email: { contains: search, mode: "insensitive" } } },
      ];
    }

    // Count total orders for pagination
    const totalOrders = await db.order.count({ where });

    // Get orders with pagination and sorting
    const orders = await db.order.findMany({
      where,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        address: true,
        items: {
          take: 5, // Limit to first 5 items
        },
        invoice: {
          select: {
            id: true,
            invoiceNumber: true,
            pdfUrl: true,
          },
        },
        _count: {
          select: {
            items: true,
          },
        },
      },
      orderBy: { [sortField]: sortOrder },
      skip: (page - 1) * perPage,
      take: perPage,
    });

    return NextResponse.json({
      orders,
      pagination: {
        total: totalOrders,
        page,
        perPage,
        totalPages: Math.ceil(totalOrders / perPage),
      },
    });
  } catch (error) {
    console.error("Error fetching orders:", error);
    return NextResponse.json(
      { error: "Failed to fetch orders" },
      { status: 500 }
    );
  }
}

// POST: Create a new order
export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const userId = session.user.id;

    const body = await req.json();
    const { items, shippingAddressId, paymentMethod, notes, couponCode } = body;

    if (!items || !Array.isArray(items) || items.length === 0) {
      return NextResponse.json(
        { error: "Order must contain at least one item" },
        { status: 400 }
      );
    }

    // Generate a unique order number
    const orderNumber = generateOrderNumber();

    // Calculate totals and prepare items
    let subtotal = 0;
    const orderItems = [];

    // Process each item to capture product information
    for (const item of items) {
      const { productId, variantId, quantity } = item;

      // If neither product nor variant is provided, reject
      if (!productId) {
        return NextResponse.json(
          { error: "Each item must specify a product" },
          { status: 400 }
        );
      }

      // Look up the product and variant
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId, // Ensure it belongs to this shop
        },
        include: {
          variants: true,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: `Product with ID ${productId} not found` },
          { status: 404 }
        );
      }

      // Determine the variant if applicable
      let variant = null;
      if (variantId) {
        variant = product.variants.find((v) => v.id === variantId);
        if (!variant) {
          return NextResponse.json(
            { error: `Variant with ID ${variantId} not found` },
            { status: 404 }
          );
        }
      }

      // Check for active discounts on this product
      const activeDiscount = await db.discount.findFirst({
        where: {
          productId,
          enabled: true,
          startDate: { lte: new Date() },
          endDate: { gte: new Date() },
        },
        orderBy: {
          percentage: "desc", // Get the highest discount if multiple exist
        },
      });

      // Calculate the unit price based on product or variant
      let unitPrice = variant ? variant.price : product.price;
      let originalPrice = unitPrice;
      let discountPercentage = null;
      let discountAmount = null;

      // Apply product-specific discount if available
      if (activeDiscount) {
        discountPercentage = activeDiscount.percentage;
        discountAmount = (unitPrice * discountPercentage) / 100;
        unitPrice = unitPrice - discountAmount;
      }

      // Calculate total for this item
      const itemTotal = unitPrice * quantity;
      subtotal += itemTotal;

      // Capture product information at the time of order
      orderItems.push({
        productId,
        variantId: variant ? variant.id : null,
        quantity,
        unitPrice,
        total: itemTotal,
        // Capture product information for historical records
        productName: product.name,
        productSku: product.sku || null,
        productBarcode: product.barcode || null,
        productDescription: product.description || null,
        productOptions: variant ? variant.options : null,
        productImage:
          product.images && product.images.length > 0
            ? product.images[0]
            : null,
        // Tax and discount information
        productTva: product.tva || 19, // Capture TVA rate at time of order
        discountPercentage: discountPercentage,
        discountAmount: discountAmount,
        discountCode: null, // This will be updated if a coupon code is applied
        originalPrice: originalPrice,
      });
    }

    // Apply coupon if provided
    let discount = 0;
    let appliedCouponCode = null;
    let couponPercentage = 0;

    if (couponCode) {
      // Fetch and validate the coupon
      const coupon = await db.discountCode.findFirst({
        where: {
          code: couponCode,
          shopId,
          isActive: true,
          startDate: { lte: new Date() },
          endDate: { gte: new Date() },
        },
      });

      if (coupon) {
        // Apply the discount
        couponPercentage = coupon.percentage;
        discount = (subtotal * couponPercentage) / 100;
        appliedCouponCode = coupon.code;

        // Update order items with the coupon code information if the coupon is valid
        orderItems.forEach((item) => {
          item.discountCode = appliedCouponCode;

          // If the item already has a product-specific discount, we keep the higher one
          // and adjust the discountAmount and discountPercentage accordingly
          if (
            !item.discountPercentage ||
            couponPercentage > item.discountPercentage
          ) {
            const itemOriginalPrice = item.originalPrice || item.unitPrice;
            const newDiscountAmount =
              (itemOriginalPrice * couponPercentage) / 100;

            // Update discount information
            item.discountPercentage = couponPercentage;
            item.discountAmount = newDiscountAmount;

            // Recalculate unit price and total
            item.unitPrice = itemOriginalPrice - newDiscountAmount;
            item.total = item.unitPrice * item.quantity;
          }
        });

        // Recalculate subtotal based on updated item totals
        subtotal = orderItems.reduce((sum, item) => sum + item.total, 0);
      }
    }

    // Calculate tax and shipping (simplified example)
    const tax = subtotal * 0.1; // 10% tax
    const shipping = 10.0; // Flat shipping rate
    const total = subtotal + tax + shipping - discount;

    // Create the order in a transaction
    const order = await db.$transaction(async (tx) => {
      // Create the order
      const newOrder = await tx.order.create({
        data: {
          orderNumber,
          status: "PENDING",
          paymentStatus: "PENDING",
          shippingStatus: "PENDING",
          subtotal,
          tax,
          shipping,
          discount,
          total,
          notes,
          userId,
          shopId,
          addressId: shippingAddressId,
          // Create order items with captured product info
          items: {
            create: orderItems,
          },
        },
        include: {
          items: true,
          user: {
            select: {
              name: true,
              email: true,
            },
          },
        },
      });

      // Update inventory
      for (const item of items) {
        const { productId, variantId, quantity } = item;

        if (variantId) {
          // Update variant inventory
          await tx.productVariant.update({
            where: { id: variantId },
            data: {
              inventory: {
                decrement: quantity,
              },
            },
          });
        } else {
          // Update product inventory
          await tx.product.update({
            where: { id: productId },
            data: {
              inventory: {
                decrement: quantity,
              },
            },
          });
        }
      }

      return newOrder;
    });

    return NextResponse.json(order, { status: 201 });
  } catch (error) {
    console.error("Error creating order:", error);
    return NextResponse.json(
      { error: "Failed to create order" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/shop/route.ts
// src/app/api/shop/route.ts
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/prisma";
import { getSubdomain } from "@/lib/subdomain";

export async function GET(req: NextRequest) {
  try {
    // Get subdomain from the request or environment
    const subdomain = getSubdomain(req);

    // If no subdomain found or it doesn't match the expected one, redirect to main domain
    if (!subdomain || subdomain !== process.env.SHOP_SUBDOMAIN) {
      // Redirect to main domain
      return NextResponse.json(
        { redirect: "https://store.tn" },
        { status: 307 }
      );
    }

    // Find the shop by subdomain
    const shop = await db.shop.findUnique({
      where: { subdomain },
      include: {
        settings: true,
      },
    });

    if (!shop) {
      return NextResponse.json(
        { error: "Shop not found", redirect: "https://store.tn" },
        { status: 404 }
      );
    }

    // Return shop data
    return NextResponse.json({
      name: shop.name,
      subdomain: shop.subdomain,
      description: shop.description,
      logo: shop.logo,
      settings: {
        currency: shop.settings?.currency || "USD",
        language: shop.settings?.language || "en",
        contactEmail: shop.settings?.contactEmail,
        contactPhone: shop.settings?.contactPhone,
      },
    });
  } catch (error) {
    console.error("Error fetching shop data:", error);
    return NextResponse.json(
      { error: "Failed to fetch shop data" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/products/[id]/orders/route.ts
// src/app/api/products/[id]/orders/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const productId = params.id;

    // Verify the product exists and belongs to this shop
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Get all order items for this product, even if it has been deleted
    // We can rely on stored productId or if productId is null, match on product name
    const orderItems = await db.orderItem.findMany({
      where: {
        OR: [
          { productId: productId },
          // For items where product was deleted but originally was this product
          {
            productId: null,
            productName: product.name,
          },
        ],
        order: {
          shopId, // Ensure orders belong to this shop
        },
      },
      include: {
        order: {
          select: {
            id: true,
            orderNumber: true,
            status: true,
            createdAt: true,
            user: {
              select: {
                name: true,
                email: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json(orderItems);
  } catch (error) {
    console.error("Error fetching product order history:", error);
    return NextResponse.json(
      { error: "Failed to fetch product order history" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/products/[id]/route.ts
// src/app/api/products/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { slugify } from "@/lib/utils";

// GET a specific product
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const productId = params.id;

    // Get the product
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId, // Ensure it belongs to this shop
      },
      include: {
        categories: true,
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    return NextResponse.json(product);
  } catch (error) {
    console.error("Error fetching product:", error);
    return NextResponse.json(
      { error: "Failed to fetch product" },
      { status: 500 }
    );
  }
}

// UPDATE a product
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const productId = params.id;
    const body = await req.json();

    // Verify the product exists and belongs to this shop
    const existingProduct = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!existingProduct) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Extract and prepare the data for update
    const {
      name,
      slug,
      description,
      price,
      cost,
      sku,
      barcode,
      inventory,
      tva,
      categoryIds,
      images,
      variants,
      expiryDate,
      customFieldValues,
    } = body;

    // Generate slug if changed
    const productSlug = slugify(name);

    // If slug changed, check if it's already in use
    if (productSlug !== existingProduct.slug) {
      const slugExists = await db.product.findUnique({
        where: {
          shopId_slug: {
            shopId,
            slug: productSlug,
          },
        },
      });

      if (slugExists && slugExists.id !== productId) {
        return NextResponse.json(
          { error: "A product with this slug already exists" },
          { status: 400 }
        );
      }
    }

    // Update the product in a transaction
    const updatedProduct = await db.$transaction(async (tx) => {
      // Update the product
      const product = await tx.product.update({
        where: { id: productId },
        data: {
          name,
          slug: productSlug,
          description,
          price,
          cost,
          sku,
          barcode,
          inventory,
          tva,
          expiryDate: expiryDate ? new Date(expiryDate) : null,
          images: images || [],
          categories: {
            set: [], // Clear existing categories
            connect: categoryIds?.map((id: string) => ({ id })) || [],
          },
        },
        include: {
          categories: true,
        },
      });

      // Handle custom field values
      if (customFieldValues && customFieldValues.length > 0) {
        // Remove existing custom field values
        await tx.customFieldValue.deleteMany({
          where: { productId },
        });

        // Add new custom field values
        for (const field of customFieldValues) {
          await tx.customFieldValue.create({
            data: {
              customFieldId: field.customFieldId,
              value: field.value,
              productId,
            },
          });
        }
      }

      // Handle variants
      if (variants && variants.length > 0) {
        // Remove existing variants that aren't in the updated list
        const variantIds = variants
          .filter((v: any) => v.id)
          .map((v: any) => v.id);

        if (variantIds.length > 0) {
          await tx.productVariant.deleteMany({
            where: {
              productId,
              id: { notIn: variantIds },
            },
          });
        } else {
          // If no existing variants were kept, delete all
          await tx.productVariant.deleteMany({
            where: { productId },
          });
        }

        // Update or create variants
        for (const variant of variants) {
          if (variant.id) {
            // Update existing variant
            await tx.productVariant.update({
              where: { id: variant.id },
              data: {
                name: variant.name,
                price: variant.price,
                inventory: variant.inventory,
                sku: variant.sku,
                options: variant.options,
              },
            });
          } else {
            // Create new variant
            await tx.productVariant.create({
              data: {
                name: variant.name,
                price: variant.price,
                inventory: variant.inventory,
                sku: variant.sku,
                options: variant.options,
                productId,
              },
            });
          }
        }
      } else {
        // If no variants provided, delete all existing variants
        await tx.productVariant.deleteMany({
          where: { productId },
        });
      }

      return product;
    });

    // Get the complete updated product
    const completeProduct = await db.product.findUnique({
      where: { id: productId },
      include: {
        categories: true,
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
      },
    });

    return NextResponse.json(completeProduct);
  } catch (error) {
    console.error("Error updating product:", error);
    return NextResponse.json(
      { error: "Failed to update product" },
      { status: 500 }
    );
  }
}

// DELETE a product
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const productId = params.id;

    // Verify the product exists and belongs to this shop
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Delete in a transaction to ensure all related records are deleted properly
    await db.$transaction(async (tx) => {
      // 1. Delete custom field values associated with the product
      await tx.customFieldValue.deleteMany({
        where: { productId },
      });

      // 2. Delete variants associated with the product
      await tx.productVariant.deleteMany({
        where: { productId },
      });

      // 3. Delete discounts associated with the product
      await tx.discount.deleteMany({
        where: { productId },
      });

      // 4. Set productId to null in discount codes (since it's nullable)
      await tx.discountCode.updateMany({
        where: { productId },
        data: { productId: null },
      });

      // 5. Check for CartItems and OrderItems (this might be our blocker)
      const cartItemCount = await tx.cartItem.count({
        where: { productId },
      });

      if (cartItemCount > 0) {
        // Delete cart items that reference this product
        await tx.cartItem.deleteMany({
          where: { productId },
        });
      }

      const orderItemCount = await tx.orderItem.count({
        where: { productId },
      });

      if (orderItemCount > 0) {
        // Instead of blocking deletion, provide specific error
        throw new Error(
          "Cannot delete product that is in completed orders. Please archive it instead."
        );
      }

      // 6. Disconnect product from all categories (many-to-many relation)
      await tx.product.update({
        where: { id: productId },
        data: {
          categories: {
            set: [], // Remove all category connections
          },
        },
      });

      // 7. Finally delete the product
      await tx.product.delete({
        where: { id: productId },
      });
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting product:", error);
    return NextResponse.json(
      {
        error:
          error instanceof Error ? error.message : "Failed to delete product",
      },
      { status: 500 }
    );
  }
}

File: ./src/app/api/products/route.ts
// src/app/api/products/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { productsService } from "@/lib/services/products.service";
import { shopService } from "@/lib/services/shop.service";
import { slugify } from "@/lib/utils";
import { db } from "@/lib/prisma";
import { serializeBigInt } from "@/lib/serializer";

// GET products with filtering, sorting, and pagination
export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;

    // Verify shop exists
    const shopExists = await shopService.shopExists(shopId);
    if (!shopExists) {
      return NextResponse.json({ error: "Shop not found" }, { status: 404 });
    }

    // Parse query parameters
    const { searchParams } = new URL(req.url);
    const page = parseInt(searchParams.get("page") || "1");
    const perPage = parseInt(searchParams.get("perPage") || "10");
    const sortField = searchParams.get("sort") || "createdAt";
    const sortOrder = searchParams.get("order") || "desc";
    const search = searchParams.get("search") || "";
    const categoryId = searchParams.get("category") || "";
    const inStock = searchParams.get("inStock") === "true";
    const lowStock = searchParams.get("lowStock") === "true";
    const expiringSoon = searchParams.get("expiringSoon") === "true";
    const viewMode = searchParams.get("view") || "list";

    // Get shop settings for low stock threshold
    const shopSettings = await shopService.getShopSettings(shopId);
    const lowStockThreshold = shopSettings?.lowStockThreshold || 5;

    // Prepare filters
    const filters = {
      shopId,
      search,
      categoryId: categoryId || undefined,
      inStock,
      lowStock,
      expiringSoon,
      lowStockThreshold,
    };

    // Prepare pagination
    const pagination = {
      page,
      perPage,
    };

    // Prepare sorting
    const sort = {
      sortField,
      sortOrder: sortOrder as "asc" | "desc",
    };

    // Get total products count for pagination
    const totalProducts = await productsService.getTotalProducts(filters);

    // Get products with pagination and sorting
    const products = await productsService.getProducts(
      filters,
      pagination,
      sort
    );

    // Get product statistics
    const productStats = await productsService.getProductStats(
      shopId,
      lowStockThreshold
    );

    // Serialize data to handle BigInt values
    const responseData = serializeBigInt({
      products,
      pagination: {
        total: totalProducts,
        page,
        perPage,
        totalPages: Math.ceil(totalProducts / perPage),
      },
      stats: productStats,
      filter: {
        lowStockThreshold,
      },
      viewMode,
    });

    return NextResponse.json(responseData);
  } catch (error) {
    console.error("Error fetching products:", error);
    return NextResponse.json(
      { error: "Failed to fetch products" },
      { status: 500 }
    );
  }
}

// CREATE a new product
export async function POST(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;

    // Parse the request body
    const body = await req.json();

    const {
      name,
      slug,
      description,
      price,
      cost,
      sku,
      barcode,
      inventory,
      tva,
      weight,
      categoryIds,
      images,
      variants,
      expiryDate,
      customFields = [],
    } = body;

    // Validate required fields
    if (!name || price === undefined) {
      return NextResponse.json(
        { error: "Name and price are required" },
        { status: 400 }
      );
    }

    // Generate slug if not provided
    const productSlug = slug || slugify(name);

    // Check if slug is already in use
    const existingProduct = await db.product.findUnique({
      where: {
        shopId_slug: {
          shopId,
          slug: productSlug,
        },
      },
    });

    if (existingProduct) {
      return NextResponse.json(
        { error: "A product with this slug already exists" },
        { status: 400 }
      );
    }

    // Get shop settings for low stock threshold
    const shopSettings = await db.shopSettings.findUnique({
      where: { shopId },
    });

    const lowStockThreshold = shopSettings?.lowStockThreshold || 5;
    const lowStockAlert = inventory <= lowStockThreshold;

    // Process custom fields - validate they exist for this shop
    const customFieldsData = [];

    if (customFields && customFields.length > 0) {
      for (const cf of customFields) {
        // Look up the custom field in the database to ensure it exists
        let customField = await db.customField.findFirst({
          where: {
            shopId,
            name: cf.key,
          },
        });

        // If it doesn't exist, create it
        if (!customField) {
          customField = await db.customField.create({
            data: {
              name: cf.key,
              type: "TEXT", // Default type
              required: false,
              shopId,
            },
          });
        }

        customFieldsData.push({
          customFieldId: customField.id,
          value: cf.value,
        });
      }
    }

    // Create the product in a transaction
    const product = await db.$transaction(async (tx) => {
      // Create the product
      const newProduct = await tx.product.create({
        data: {
          name,
          slug: productSlug,
          description,
          price,
          cost,
          sku,
          barcode,
          inventory,
          tva: tva || 19, // Default TVA to 19% if not provided
          lowStockAlert,
          weight,
          images: images || [],
          expiryDate: expiryDate ? new Date(expiryDate) : null,
          shopId,
          categories: {
            connect: categoryIds?.map((id: string) => ({ id })) || [],
          },
        },
      });

      // Create custom field values
      if (customFieldsData.length > 0) {
        await Promise.all(
          customFieldsData.map((cfData) =>
            tx.customFieldValue.create({
              data: {
                ...cfData,
                productId: newProduct.id,
              },
            })
          )
        );
      }

      // Create variants if provided
      if (variants && variants.length > 0) {
        await Promise.all(
          variants.map((variant: any) =>
            tx.productVariant.create({
              data: {
                name: variant.name,
                price: variant.price,
                inventory: variant.inventory,
                sku: variant.sku,
                options: variant.options,
                productId: newProduct.id,
              },
            })
          )
        );
      }

      return newProduct;
    });

    // Get the complete product with relationships
    const completeProduct = await db.product.findUnique({
      where: { id: product.id },
      include: {
        categories: true,
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
      },
    });

    // Serialize the response
    return NextResponse.json(serializeBigInt(completeProduct), { status: 201 });
  } catch (error) {
    console.error("Error creating product:", error);
    return NextResponse.json(
      { error: "Failed to create product" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/categories/route.ts
// src/app/api/categories/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { serializeBigInt } from "@/lib/serializer";

export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const parentId = searchParams.get("parentId");
    const flat = searchParams.get("flat") === "true";

    // Build where clause
    const where: any = { shopId };

    // Filter by parent category if specified
    if (parentId) {
      where.parentId = parentId;
    }

    // Query categories
    let categories;

    if (flat) {
      // Get all categories for the shop without hierarchy
      categories = await db.category.findMany({
        where: { shopId },
        select: {
          id: true,
          name: true,
          slug: true,
        },
        orderBy: {
          name: "asc",
        },
      });
    } else {
      // Get all categories with hierarchy information
      const allCategories = await db.category.findMany({
        where: { shopId },
        select: {
          id: true,
          name: true,
          slug: true,
          parentId: true,
        },
        orderBy: {
          name: "asc",
        },
      });

      // Function to add level information to categories
      const addLevelToCategories = (
        categories: any[],
        parentId: string | null = null,
        level = 0
      ) => {
        return categories
          .filter((category) => category.parentId === parentId)
          .map((category) => ({
            id: category.id,
            name: category.name,
            slug: category.slug,
            level,
            parentId: category.parentId,
          }));
      };

      // Function to create flat array with correct level
      const createFlatCategoriesWithLevels = (categories: any[]) => {
        // First get all root categories (those with no parent)
        let result = addLevelToCategories(categories);

        // For each root category, recursively add its children
        for (let i = 0; i < result.length; i++) {
          const category = result[i];
          const children = addLevelToCategories(
            categories,
            category.id,
            category.level + 1
          );

          // Insert children after their parent
          if (children.length > 0) {
            result.splice(i + 1, 0, ...children);
            // Skip the children we just added
            i += children.length;
          }
        }

        return result;
      };

      categories = createFlatCategoriesWithLevels(allCategories);
    }

    // Handle the case where no categories exist
    if (!categories) {
      categories = [];
    }

    // Serialize any BigInt values that might be in the response
    return NextResponse.json(serializeBigInt(categories));
  } catch (error) {
    console.error("Error fetching categories:", error);
    return NextResponse.json(
      { error: "Failed to fetch categories" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/users/search/route.ts
// src/app/api/users/search/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const { searchParams } = new URL(req.url);
    const query = searchParams.get("q");

    if (!query || query.length < 2) {
      return NextResponse.json(
        { error: "Search query must be at least 2 characters" },
        { status: 400 }
      );
    }

    // Search for users that belong to this shop
    const users = await db.user.findMany({
      where: {
        shopId,
        OR: [
          { name: { contains: query, mode: "insensitive" } },
          { email: { contains: query, mode: "insensitive" } },
        ],
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
      },
      take: 10, // Limit to 10 results
    });

    return NextResponse.json(users);
  } catch (error) {
    console.error("Error searching users:", error);
    return NextResponse.json(
      { error: "Failed to search users" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/discounts/[id]/route.ts
// src/app/api/discounts/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET a specific discount
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountId = params.id;

    // Get the discount with validation that it belongs to a product in this shop
    const discount = await db.discount.findFirst({
      where: {
        id: discountId,
        product: {
          shopId,
        },
      },
    });

    if (!discount) {
      return NextResponse.json(
        { error: "Discount not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(discount);
  } catch (error) {
    console.error("Error fetching discount:", error);
    return NextResponse.json(
      { error: "Failed to fetch discount" },
      { status: 500 }
    );
  }
}

// UPDATE a discount
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountId = params.id;
    const body = await req.json();
    const { percentage, enabled, startDate, endDate, productId } = body;

    // Verify the discount exists and belongs to a product in this shop
    const existingDiscount = await db.discount.findFirst({
      where: {
        id: discountId,
        product: {
          shopId,
        },
      },
    });

    if (!existingDiscount) {
      return NextResponse.json(
        { error: "Discount not found" },
        { status: 404 }
      );
    }

    // Verify the product belongs to this shop if it's being changed
    if (productId && productId !== existingDiscount.productId) {
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: "Product not found" },
          { status: 404 }
        );
      }
    }

    // Update the discount
    const updatedDiscount = await db.discount.update({
      where: { id: discountId },
      data: {
        percentage:
          percentage !== undefined ? parseFloat(percentage) : undefined,
        enabled: enabled !== undefined ? enabled === true : undefined,
        startDate: startDate ? new Date(startDate) : undefined,
        endDate: endDate ? new Date(endDate) : undefined,
        productId: productId || undefined,
      },
    });

    return NextResponse.json(updatedDiscount);
  } catch (error) {
    console.error("Error updating discount:", error);
    return NextResponse.json(
      { error: "Failed to update discount" },
      { status: 500 }
    );
  }
}

// DELETE a discount
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountId = params.id;

    // Verify the discount exists and belongs to a product in this shop
    const discount = await db.discount.findFirst({
      where: {
        id: discountId,
        product: {
          shopId,
        },
      },
    });

    if (!discount) {
      return NextResponse.json(
        { error: "Discount not found" },
        { status: 404 }
      );
    }

    // Delete the discount
    await db.discount.delete({
      where: { id: discountId },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting discount:", error);
    return NextResponse.json(
      { error: "Failed to delete discount" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/discounts/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET: List discounts for a product
export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const { searchParams } = new URL(req.url);
    const productId = searchParams.get("productId");

    if (!productId) {
      return NextResponse.json(
        { error: "Product ID is required" },
        { status: 400 }
      );
    }

    // Verify the product belongs to this shop
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Get discounts for this product
    const discounts = await db.discount.findMany({
      where: {
        productId,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json(discounts);
  } catch (error) {
    console.error("Error fetching discounts:", error);
    return NextResponse.json(
      { error: "Failed to fetch discounts" },
      { status: 500 }
    );
  }
}

// POST: Create a new discount
export async function POST(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const body = await req.json();
    const { percentage, enabled, startDate, endDate, productId } = body;

    // Validate required fields
    if (!percentage || !startDate || !endDate || !productId) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Verify the product belongs to this shop
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Create the discount
    const discount = await db.discount.create({
      data: {
        percentage: parseFloat(percentage),
        enabled: enabled === true,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        productId,
      },
    });

    return NextResponse.json(discount, { status: 201 });
  } catch (error) {
    console.error("Error creating discount:", error);
    return NextResponse.json(
      { error: "Failed to create discount" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/custom-fields/[id]/route.ts
// src/app/api/custom-fields/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { z } from "zod";

// Validation schema for custom field updates
const updateCustomFieldSchema = z.object({
  name: z.string().min(2, "Field name must be at least 2 characters"),
  type: z.string().min(1, "Field type is required"),
  required: z.boolean().default(false),
});

// GET a single custom field
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const fieldId = params.id;

    // Get the custom field
    const customField = await db.customField.findUnique({
      where: {
        id: fieldId,
      },
    });

    // Check if it belongs to this shop
    if (!customField || customField.shopId !== shopId) {
      return NextResponse.json(
        { error: "Custom field not found" },
        { status: 404 }
      );
    }

    // Get usage count
    const usageCount = await db.customFieldValue.count({
      where: { customFieldId: fieldId },
    });

    return NextResponse.json({
      ...customField,
      usageCount,
    });
  } catch (error) {
    console.error("Error fetching custom field:", error);
    return NextResponse.json(
      { error: "Failed to fetch custom field" },
      { status: 500 }
    );
  }
}

// UPDATE a custom field
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const fieldId = params.id;

    // Check if custom field exists and belongs to this shop
    const existingField = await db.customField.findUnique({
      where: {
        id: fieldId,
      },
    });

    if (!existingField || existingField.shopId !== shopId) {
      return NextResponse.json(
        { error: "Custom field not found" },
        { status: 404 }
      );
    }

    // Parse request body
    const body = await req.json();
    const validationResult = updateCustomFieldSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: validationResult.error.message },
        { status: 400 }
      );
    }

    const { name, type, required } = validationResult.data;

    // Check if name already exists (except for this field)
    if (name !== existingField.name) {
      const nameExists = await db.customField.findFirst({
        where: {
          shopId,
          name: {
            equals: name,
            mode: "insensitive",
          },
          id: {
            not: fieldId,
          },
        },
      });

      if (nameExists) {
        return NextResponse.json(
          { error: "A custom field with this name already exists" },
          { status: 400 }
        );
      }
    }

    // Update custom field
    const updatedField = await db.customField.update({
      where: { id: fieldId },
      data: {
        name,
        type,
        required: required === true,
      },
    });

    return NextResponse.json(updatedField);
  } catch (error) {
    console.error("Error updating custom field:", error);
    return NextResponse.json(
      { error: "Failed to update custom field" },
      { status: 500 }
    );
  }
}

// DELETE a custom field
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const fieldId = params.id;

    // Check if custom field exists and belongs to this shop
    const existingField = await db.customField.findUnique({
      where: {
        id: fieldId,
      },
    });

    if (!existingField || existingField.shopId !== shopId) {
      return NextResponse.json(
        { error: "Custom field not found" },
        { status: 404 }
      );
    }

    // Check if the field is in use
    const inUseCount = await db.customFieldValue.count({
      where: { customFieldId: fieldId },
    });

    if (inUseCount > 0) {
      return NextResponse.json(
        {
          error: "Cannot delete a custom field that is in use",
          count: inUseCount,
        },
        { status: 400 }
      );
    }

    // Delete the custom field
    await db.customField.delete({
      where: { id: fieldId },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting custom field:", error);
    return NextResponse.json(
      { error: "Failed to delete custom field" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/custom-fields/route.ts
// src/app/api/custom-fields/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { z } from "zod";

// Validation schema for custom field creation
const createCustomFieldSchema = z.object({
  name: z.string().min(2, "Field name must be at least 2 characters"),
  type: z.string().min(1, "Field type is required"),
  required: z.boolean().default(false),
});

// POST: Create a new custom field
export async function POST(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;

    // Parse and validate request body
    const body = await req.json();
    const validationResult = createCustomFieldSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: validationResult.error.message },
        { status: 400 }
      );
    }

    const { name, type, required } = validationResult.data;

    // Check if field with the same name already exists for this shop
    const existingField = await db.customField.findFirst({
      where: {
        shopId,
        name: {
          equals: name,
          mode: "insensitive", // Case insensitive comparison
        },
      },
    });

    if (existingField) {
      return NextResponse.json(
        { error: "A custom field with this name already exists" },
        { status: 400 }
      );
    }

    // Create the custom field
    const customField = await db.customField.create({
      data: {
        name,
        type,
        required,
        shopId,
      },
    });

    return NextResponse.json(customField, { status: 201 });
  } catch (error) {
    console.error("Error creating custom field:", error);
    return NextResponse.json(
      { error: "Failed to create custom field" },
      { status: 500 }
    );
  }
}

// GET: List all custom fields for the shop
export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const search = searchParams.get("search") || "";
    const type = searchParams.get("type") || "";
    const sort = searchParams.get("sort") || "name";
    const order = searchParams.get("order") || "asc";

    // Build where clause
    let where: any = { shopId };

    if (search) {
      where.name = {
        contains: search,
        mode: "insensitive",
      };
    }

    if (type) {
      where.type = type;
    }

    // Get custom fields
    const customFields = await db.customField.findMany({
      where,
      orderBy: {
        [sort]: order,
      },
    });

    // Count usage for each field
    const fieldsWithUsage = await Promise.all(
      customFields.map(async (field) => {
        const usageCount = await db.customFieldValue.count({
          where: { customFieldId: field.id },
        });

        return {
          ...field,
          usageCount,
        };
      })
    );

    return NextResponse.json(fieldsWithUsage);
  } catch (error) {
    console.error("Error fetching custom fields:", error);
    return NextResponse.json(
      { error: "Failed to fetch custom fields" },
      { status: 500 }
    );
  }
}

File: ./src/types/product.ts
// src/types/product.ts

export interface Category {
  id: string;
  name: string;
  slug: string;
  level?: number;
  parentId?: string | null;
}

export interface ProductVariant {
  id?: string;
  name: string;
  price: number;
  inventory: number;
  sku?: string;
  barcode?: string;
  options: Record<string, any>;
}

export interface CustomField {
  id?: string;
  customFieldId: string;
  value: string;
  customField?: {
    id: string;
    name: string;
    type: string;
    required?: boolean;
  };
}

export interface Discount {
  id?: string;
  percentage: number;
  enabled?: boolean;
  startDate?: string | Date;
  endDate?: string | Date;
  productId?: string;
}

export interface Product {
  id: string;
  name: string;
  slug?: string;
  description?: string;
  price: number;
  cost?: number | null;
  tva?: number;
  sku?: string;
  barcode?: string;
  inventory: number;
  lowStockAlert?: boolean;
  weight?: number | null;
  dimensions?: Record<string, any> | null;
  images: string[];
  expiryDate?: string | Date | null;
  categories: Category[];
  variants: ProductVariant[];
  customFields: CustomField[];
  _count: {
    variants: number;
    orderItems: number;
  };
  discounts: Discount[];
  createdAt?: string | Date;
  updatedAt?: string | Date;
}

export interface ProductResponse {
  products: Product[];
  pagination: {
    total: number;
    page: number;
    perPage: number;
    totalPages: number;
  };
  stats: {
    totalInventory: number;
    lowStockCount: number;
    outOfStockCount: number;
  };
  filter: {
    lowStockThreshold: number;
  };
  viewMode: string;
}

export interface ProductFormValues {
  name: string;
  description?: string;
  price: number;
  cost?: number | null;
  barcode?: string;
  inventory: number;
  tva?: number;
  categoryIds: string[];
  images: string[];
  variants: ProductVariant[];
  expiryDate?: string | null;
  customFieldValues: CustomField[];
}

export interface ProductFiltersType {
  search?: string;
  category?: string;
  inStock?: string;
  lowStock?: string;
  page?: string;
  perPage?: string;
  sort?: string;
  order?: string;
}

File: ./src/hooks/useProducts.ts
// src/hooks/useProducts.ts
import { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import { useToast } from "@/components/ui/use-toast";
import { apiClient } from "@/lib/api-client";
import { Product, ProductResponse, ProductFiltersType } from "@/types/product";

export function useProducts(filters: ProductFiltersType) {
  const { data: session, status } = useSession();
  const { toast } = useToast();

  const [isLoading, setIsLoading] = useState(true);
  const [products, setProducts] = useState<Product[]>([]);
  const [totalProducts, setTotalProducts] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [lowStockThreshold, setLowStockThreshold] = useState(5);
  const [productStats, setProductStats] = useState({
    totalInventory: 0,
    lowStockCount: 0,
    outOfStockCount: 0,
  });

  // Use a ref to track the previous filters to avoid unnecessary API calls
  const prevFiltersRef = useRef<string>("");
  const currentFiltersString = JSON.stringify(filters);

  useEffect(() => {
    // Skip if session is loading or filters haven't changed
    if (
      status === "loading" ||
      !session?.user?.shopId ||
      prevFiltersRef.current === currentFiltersString
    ) {
      return;
    }

    // Update the previous filters ref
    prevFiltersRef.current = currentFiltersString;

    const fetchProducts = async () => {
      setIsLoading(true);

      try {
        // Fetch products with all params
        const response = await apiClient.products.getProducts(filters);

        setProducts(response.products);
        setTotalProducts(response.pagination.total);
        setTotalPages(response.pagination.totalPages);
        setLowStockThreshold(response.filter.lowStockThreshold);
        setProductStats(response.stats);
      } catch (error) {
        console.error("Error fetching products:", error);
        toast({
          title: "Error",
          description: "Failed to load products",
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
      }
    };

    fetchProducts();
  }, [session, status, currentFiltersString, toast]);

  return {
    isLoading,
    products,
    totalProducts,
    totalPages,
    lowStockThreshold,
    productStats,
  };
}

Directory Structure:
.
├── .git
│   ├── branches
│   ├── hooks
│   │   ├── applypatch-msg.sample
│   │   ├── commit-msg.sample
│   │   ├── fsmonitor-watchman.sample
│   │   ├── post-update.sample
│   │   ├── pre-applypatch.sample
│   │   ├── pre-commit.sample
│   │   ├── pre-merge-commit.sample
│   │   ├── prepare-commit-msg.sample
│   │   ├── pre-push.sample
│   │   ├── pre-rebase.sample
│   │   ├── pre-receive.sample
│   │   ├── push-to-checkout.sample
│   │   ├── sendemail-validate.sample
│   │   └── update.sample
│   ├── info
│   │   └── exclude
│   ├── logs
│   │   ├── refs
│   │   │   └── heads
│   │   │       └── main
│   │   └── HEAD
│   ├── objects
│   │   ├── 00
│   │   │   └── 4145cddf3f9db91b57b9cb596683c8eb420862
│   │   ├── 13
│   │   │   └── b978eaa10efc80206f388fe93c6f474da01413
│   │   ├── 22
│   │   │   └── 960675d687b6d20e8816d9bce3d60454b62a28
│   │   ├── 3e
│   │   │   └── ee0141abe634fab81de261c7133991b5a56a17
│   │   ├── 51
│   │   │   └── 74b28c565c285e3e312ec5178be64fbeca8398
│   │   ├── 53
│   │   │   └── e044ce7aa85068d44f2a758b51475c96239406
│   │   ├── 56
│   │   │   └── 7f17b0d7c7fb662c16d4357dd74830caf2dccb
│   │   ├── 5e
│   │   │   └── f6a520780202a1d6addd833d800ccb1ecac0bb
│   │   ├── 71
│   │   │   └── 8d6fea4835ec2d246af9800eddb7ffb276240c
│   │   ├── 77
│   │   │   └── 053960334e2e34dc584dea8019925c3b4ccca9
│   │   ├── a2
│   │   │   └── dc41ecee5ec435200fe7cba2bde4107f823774
│   │   ├── ad
│   │   │   └── f48003b58dc594427a8c871449611a07bc4ba4
│   │   ├── b2
│   │   │   └── b2a44f6ebc70c450043c05a002e7a93ba5d651
│   │   ├── bd
│   │   │   └── e0e1a3c99288f4bee5ac901389e12130182e68
│   │   ├── c1
│   │   │   └── 334095f876a408c10f2357faaced969ec090ab
│   │   ├── c7
│   │   │   └── bcb4b1ee14cd5e25078c2c934529afdd2a7df9
│   │   ├── c8
│   │   │   ├── 5fb67c463f20d1ee449b0ffee725a61dfb9259
│   │   │   └── 8f389de09f418da376598c42e8788d4fb6d172
│   │   ├── e2
│   │   │   └── 15bc4ccf138bbc38ad58ad57e92135484b3c0f
│   │   ├── e9
│   │   │   └── ffa3083ad279ecf95fd8eae59cb253e9a539c4
│   │   ├── ed
│   │   │   └── e9a621760c89e16e9e1a365db94667cdf4b4e5
│   │   ├── f7
│   │   │   └── fa87eb875260ed98651bc419c8139b5119e554
│   │   ├── info
│   │   └── pack
│   ├── refs
│   │   ├── heads
│   │   │   └── main
│   │   └── tags
│   ├── COMMIT_EDITMSG
│   ├── config
│   ├── description
│   ├── HEAD
│   └── index
├── prisma
│   ├── fixtures
│   │   ├── advancedShop.js
│   │   ├── categories.js
│   │   ├── clear-all.js
│   │   ├── generate.js
│   │   ├── orders.js
│   │   ├── planPricing.js
│   │   ├── products.js
│   │   ├── run.js
│   │   ├── shops.js
│   │   ├── subscriptions.js
│   │   ├── users.js
│   │   └── utils.js
│   ├── migrations
│   │   ├── 20250315100735_ame
│   │   │   └── migration.sql
│   │   ├── 20250322090727_add_product_tva
│   │   │   └── migration.sql
│   │   ├── 20250417064031_ame
│   │   │   └── migration.sql
│   │   ├── 20250421003921_ame
│   │   │   └── migration.sql
│   │   └── migration_lock.toml
│   ├── schema.prisma
│   └── seed.ts
├── public
│   ├── file.svg
│   ├── globe.svg
│   ├── next.svg
│   ├── vercel.svg
│   └── window.svg
├── src
│   ├── app
│   │   ├── admin
│   │   │   ├── api
│   │   │   │   ├── shop
│   │   │   │   │   └── route.ts
│   │   │   │   └── shops
│   │   │   │       └── route.ts
│   │   │   ├── custom-fields
│   │   │   │   └── page.tsx
│   │   │   ├── discount-codes
│   │   │   │   └── page.tsx
│   │   │   ├── discounts
│   │   │   │   ├── [id]
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── new
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx
│   │   │   ├── products
│   │   │   │   ├── [id]
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── new
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx
│   │   │   ├── layout.tsx
│   │   │   └── page.tsx
│   │   ├── api
│   │   │   ├── auth
│   │   │   │   ├── [...nextauth]
│   │   │   │   │   └── route.ts
│   │   │   │   └── register
│   │   │   │       └── route.ts
│   │   │   ├── categories
│   │   │   │   └── route.ts
│   │   │   ├── custom-fields
│   │   │   │   ├── [id]
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── discount-codes
│   │   │   │   ├── [id]
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── discounts
│   │   │   │   ├── [id]
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── orders
│   │   │   │   ├── [id]
│   │   │   │   │   ├── invoice
│   │   │   │   │   │   └── route.ts
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── products
│   │   │   │   ├── [id]
│   │   │   │   │   ├── orders
│   │   │   │   │   │   └── route.ts
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── shop
│   │   │   │   └── route.ts
│   │   │   └── users
│   │   │       └── search
│   │   │           └── route.ts
│   │   ├── login
│   │   │   └── page.tsx
│   │   ├── register
│   │   │   └── page.tsx
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components
│   │   ├── admin
│   │   │   ├── product-tabs
│   │   │   │   ├── basic-info-tab.tsx
│   │   │   │   ├── categories-tab.tsx
│   │   │   │   ├── custom-fields-tab.tsx
│   │   │   │   ├── discount-codes-tab.tsx
│   │   │   │   ├── discounts-tab.tsx
│   │   │   │   ├── images-tab.tsx
│   │   │   │   ├── order-history-tab.tsx
│   │   │   │   ├── pricing-tab.tsx
│   │   │   │   └── variants-tab.tsx
│   │   │   ├── add-custom-field-form.tsx
│   │   │   ├── custom-fields-table.tsx
│   │   │   ├── discount-code-list-actions.tsx
│   │   │   ├── discount-form.tsx
│   │   │   ├── discount-list-actions.tsx
│   │   │   ├── header.tsx
│   │   │   ├── pagination.tsx
│   │   │   ├── product-categories-select.tsx
│   │   │   ├── product-custom-fields.tsx
│   │   │   ├── product-filters.tsx
│   │   │   ├── product-form.tsx
│   │   │   ├── product-form-types.ts
│   │   │   ├── product-images-upload.tsx
│   │   │   ├── product-list-actions.tsx
│   │   │   ├── product-pagination.tsx
│   │   │   ├── product-variants-form.tsx
│   │   │   ├── sidebar.tsx
│   │   │   └── subscription-info.tsx
│   │   ├── authorization
│   │   │   └── feature-guard.tsx
│   │   ├── providers
│   │   │   ├── session-provider.tsx
│   │   │   ├── shop-provider.tsx
│   │   │   └── toast-provider.tsx
│   │   └── ui
│   │       ├── alert-dialog.tsx
│   │       ├── alert.tsx
│   │       ├── badge.tsx
│   │       ├── button.tsx
│   │       ├── card.tsx
│   │       ├── checkbox.tsx
│   │       ├── collapsible.tsx
│   │       ├── dialog.tsx
│   │       ├── dropdown-menu.tsx
│   │       ├── form.tsx
│   │       ├── input.tsx
│   │       ├── label.tsx
│   │       ├── select.tsx
│   │       ├── switch.tsx
│   │       ├── table.tsx
│   │       ├── tabs.tsx
│   │       ├── textarea.tsx
│   │       ├── toast.tsx
│   │       └── use-toast.ts
│   ├── hooks
│   │   └── useProducts.ts
│   ├── lib
│   │   ├── services
│   │   │   ├── categories.service.ts
│   │   │   ├── index.ts
│   │   │   ├── products.service.ts
│   │   │   └── shop.service.ts
│   │   ├── api-client.ts
│   │   ├── authorization.ts
│   │   ├── auth.ts
│   │   ├── feature-authorization.ts
│   │   ├── permissions.ts
│   │   ├── plan-features.ts
│   │   ├── prisma.ts
│   │   ├── serializer.ts
│   │   ├── subdomain.ts
│   │   └── utils.ts
│   ├── types
│   │   └── product.ts
│   └── middleware.ts
├── all_texts.txt
├── docker-compose.yml
├── .env
├── eslint.config.mjs
├── file_list.txt
├── .gitignore
├── makefile
├── next.config.ts
├── postcss.config.mjs
└── README.md

89 directories, 180 files
