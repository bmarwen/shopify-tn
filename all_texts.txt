File: ./src/components/authorization/feature-guard.tsx
"use client";

import { ReactNode } from "react";
import { useSession } from "next-auth/react";
import { Feature, hasFeatureAccess } from "@/lib/feature-authorization";

interface FeatureGuardProps {
  /**
   * The feature(s) to check
   * - Can be a single feature or an array of features
   * - If array, requires access to ALL features (AND logic)
   */
  feature: Feature | Feature[];

  /**
   * The content to render if the user has access to the feature
   */
  children: ReactNode;

  /**
   * Optional fallback component to render if user doesn't have access
   * - If not provided, renders nothing when access is denied
   */
  fallback?: ReactNode;
}

/**
 * A component that conditionally renders content based on feature access
 */
export function FeatureGuard({
  feature,
  children,
  fallback,
}: FeatureGuardProps) {
  const { data: session } = useSession();

  // Check if user has access to the required feature(s)
  const hasAccess = Array.isArray(feature)
    ? feature.every((f) => hasFeatureAccess(session?.user, f))
    : hasFeatureAccess(session?.user, feature);

  // Render children if user has access, otherwise render fallback or nothing
  return hasAccess ? <>{children}</> : fallback ? <>{fallback}</> : null;
}

/**
 * A component that conditionally renders based on the user's plan type
 */
export function PlanGuard({
  plan,
  children,
  fallback,
}: {
  plan:
    | "STANDARD"
    | "ADVANCED"
    | "PREMIUM"
    | ("STANDARD" | "ADVANCED" | "PREMIUM")[];
  children: ReactNode;
  fallback?: ReactNode;
}) {
  const { data: session } = useSession();
  const userPlan = session?.user?.planType || "STANDARD";

  const hasAccess = Array.isArray(plan)
    ? plan.includes(userPlan as any)
    : userPlan === plan;

  return hasAccess ? <>{children}</> : fallback ? <>{fallback}</> : null;
}

/**
 * A component that only renders for specific user roles
 */
export function RoleGuard({
  role,
  children,
  fallback,
}: {
  role:
    | "SUPER_ADMIN"
    | "SHOP_ADMIN"
    | "SHOP_STAFF"
    | "CUSTOMER"
    | ("SUPER_ADMIN" | "SHOP_ADMIN" | "SHOP_STAFF" | "CUSTOMER")[];
  children: ReactNode;
  fallback?: ReactNode;
}) {
  const { data: session } = useSession();
  const userRole = session?.user?.role;

  if (!userRole) return fallback ? <>{fallback}</> : null;

  const hasAccess = Array.isArray(role)
    ? role.includes(userRole as any)
    : userRole === role;

  return hasAccess ? <>{children}</> : fallback ? <>{fallback}</> : null;
}

/**
 * Example usage:
 *
 * <FeatureGuard feature={Feature.INVOICE_GENERATION}>
 *   <InvoiceGenerationButton/>
 * </FeatureGuard>
 *
 * <PlanGuard plan="PREMIUM">
 *   <PremiumFeature/>
 * </PlanGuard>
 *
 * <RoleGuard role={["SHOP_ADMIN", "SUPER_ADMIN"]}>
 *   <AdminControls/>
 * </RoleGuard>
 */

File: ./src/components/providers/session-provider.tsx
// src/components/providers/session-provider.tsx
"use client";

import { SessionProvider as NextAuthSessionProvider } from "next-auth/react";

export function SessionProvider({ children }: { children: React.ReactNode }) {
  return <NextAuthSessionProvider>{children}</NextAuthSessionProvider>;
}

File: ./src/components/providers/toast-provider.tsx
// src/components/providers/toast-provider.tsx
"use client";

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function ToastsProvider() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}

File: ./src/components/providers/shop-provider.tsx
"use client";

import React, { createContext, useContext, useEffect, useState } from "react";
import { useSession } from "next-auth/react";

// Define types for shop settings
type ShopSettingsType = {
  currency: string;
  language: string;
  timezone: string;
  contactEmail: string | null;
  contactPhone: string | null;
  address: string | null;
  lowStockThreshold: number;
};

// Define the shape of the shop context
type ShopContextType = {
  shopId: string | null;
  shopName: string;
  shopLogo: string | null;
  shopSubdomain: string | null;
  settings: ShopSettingsType;
  planType: string;
  isLoading: boolean;
  refetch: () => Promise<void>;
};

// Default settings values
const defaultSettings: ShopSettingsType = {
  currency: "USD",
  language: "en",
  timezone: "UTC",
  contactEmail: null,
  contactPhone: null,
  address: null,
  lowStockThreshold: 5,
};

// Default context state
const defaultState: ShopContextType = {
  shopId: null,
  shopName: "",
  shopLogo: null,
  shopSubdomain: null,
  settings: defaultSettings,
  planType: "STANDARD",
  isLoading: true,
  refetch: async () => {},
};

// Create the context
const ShopContext = createContext<ShopContextType>(defaultState);

// Hook to use the shop context
export const useShop = () => useContext(ShopContext);

// Shop provider component
export const ShopProvider = ({ children }: { children: React.ReactNode }) => {
  const { data: session } = useSession();
  const [shopState, setShopState] = useState<ShopContextType>(defaultState);

  // Function to fetch shop information
  const fetchShopInfo = async () => {
    try {
      setShopState((prev) => ({ ...prev, isLoading: true }));

      const res = await fetch("/api/shop");

      if (!res.ok) {
        throw new Error("Failed to fetch shop data");
      }

      const data = await res.json();

      // If there's a redirect property, the shop doesn't exist
      if (data.redirect) {
        throw new Error("Shop not found");
      }

      setShopState({
        shopId: session?.user?.shopId || null,
        shopName: data.name,
        shopLogo: data.logo,
        shopSubdomain: data.subdomain,
        settings: {
          currency: data.settings?.currency || "USD",
          language: data.settings?.language || "en",
          timezone: data.settings?.timezone || "UTC",
          contactEmail: data.settings?.contactEmail || null,
          contactPhone: data.settings?.contactPhone || null,
          address: data.settings?.address || null,
          lowStockThreshold: data.settings?.lowStockThreshold || 5,
        },
        planType: session?.user?.planType || "STANDARD",
        isLoading: false,
        refetch: fetchShopInfo,
      });
    } catch (error) {
      console.error("Failed to load shop information:", error);
      setShopState({
        ...defaultState,
        isLoading: false,
        refetch: fetchShopInfo,
      });
    }
  };

  // Effect to load shop data when component mounts or session changes
  useEffect(() => {
    if (session) {
      fetchShopInfo();
    }
  }, [session]);

  return (
    <ShopContext.Provider value={shopState}>{children}</ShopContext.Provider>
  );
};

File: ./src/components/admin/order-status-badge.tsx
// src/components/admin/order-status-badge.tsx
"use client";

import { Badge } from "@/components/ui/badge";

type StatusType = "order" | "payment" | "shipping";

interface OrderStatusBadgeProps {
  status: string;
  type?: StatusType;
}

export default function OrderStatusBadge({
  status,
  type = "order",
}: OrderStatusBadgeProps) {
  // Different statuses based on type
  if (type === "order") {
    switch (status) {
      case "PENDING":
        return (
          <Badge
            variant="outline"
            className="bg-blue-50 text-blue-700 border-blue-200"
          >
            Pending
          </Badge>
        );
      case "PROCESSING":
        return (
          <Badge
            variant="outline"
            className="bg-amber-50 text-amber-700 border-amber-200"
          >
            Processing
          </Badge>
        );
      case "SHIPPED":
        return (
          <Badge
            variant="outline"
            className="bg-purple-50 text-purple-700 border-purple-200"
          >
            Shipped
          </Badge>
        );
      case "DELIVERED":
        return (
          <Badge
            variant="outline"
            className="bg-green-50 text-green-700 border-green-200"
          >
            Delivered
          </Badge>
        );
      case "CANCELLED":
        return (
          <Badge
            variant="outline"
            className="bg-red-50 text-red-700 border-red-200"
          >
            Cancelled
          </Badge>
        );
      case "REFUNDED":
        return (
          <Badge
            variant="outline"
            className="bg-orange-50 text-orange-700 border-orange-200"
          >
            Refunded
          </Badge>
        );
      default:
        return (
          <Badge
            variant="outline"
            className="bg-gray-50 text-gray-700 border-gray-200"
          >
            {status}
          </Badge>
        );
    }
  }

  // Payment statuses
  if (type === "payment") {
    switch (status) {
      case "PENDING":
        return (
          <Badge
            variant="outline"
            className="bg-blue-50 text-blue-700 border-blue-200"
          >
            Pending
          </Badge>
        );
      case "PAID":
        return (
          <Badge
            variant="outline"
            className="bg-green-50 text-green-700 border-green-200"
          >
            Paid
          </Badge>
        );
      case "FAILED":
        return (
          <Badge
            variant="outline"
            className="bg-red-50 text-red-700 border-red-200"
          >
            Failed
          </Badge>
        );
      case "REFUNDED":
        return (
          <Badge
            variant="outline"
            className="bg-orange-50 text-orange-700 border-orange-200"
          >
            Refunded
          </Badge>
        );
      case "PARTIALLY_REFUNDED":
        return (
          <Badge
            variant="outline"
            className="bg-amber-50 text-amber-700 border-amber-200"
          >
            Partial Refund
          </Badge>
        );
      default:
        return (
          <Badge
            variant="outline"
            className="bg-gray-50 text-gray-700 border-gray-200"
          >
            {status}
          </Badge>
        );
    }
  }

  // Shipping statuses
  if (type === "shipping") {
    switch (status) {
      case "PENDING":
        return (
          <Badge
            variant="outline"
            className="bg-blue-50 text-blue-700 border-blue-200"
          >
            Pending
          </Badge>
        );
      case "PROCESSING":
        return (
          <Badge
            variant="outline"
            className="bg-amber-50 text-amber-700 border-amber-200"
          >
            Processing
          </Badge>
        );
      case "SHIPPED":
        return (
          <Badge
            variant="outline"
            className="bg-purple-50 text-purple-700 border-purple-200"
          >
            Shipped
          </Badge>
        );
      case "DELIVERED":
        return (
          <Badge
            variant="outline"
            className="bg-green-50 text-green-700 border-green-200"
          >
            Delivered
          </Badge>
        );
      case "RETURNED":
        return (
          <Badge
            variant="outline"
            className="bg-orange-50 text-orange-700 border-orange-200"
          >
            Returned
          </Badge>
        );
      default:
        return (
          <Badge
            variant="outline"
            className="bg-gray-50 text-gray-700 border-gray-200"
          >
            {status}
          </Badge>
        );
    }
  }

  // Fallback
  return (
    <Badge
      variant="outline"
      className="bg-gray-50 text-gray-700 border-gray-200"
    >
      {status}
    </Badge>
  );
}

File: ./src/components/admin/product-list-actions.tsx
// src/components/admin/product-list-actions.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { MoreHorizontal, Edit, Copy, Trash, ExternalLink } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useToast } from "@/components/ui/use-toast";

interface ProductListActionsProps {
  productId: string;
  onDelete?: () => void;
}

export default function ProductListActions({
  productId,
  onDelete,
}: ProductListActionsProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleDelete = async () => {
    try {
      setIsDeleting(true);

      const response = await fetch(`/api/products/${productId}`, {
        method: "DELETE",
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.error || "Failed to delete product");
      }

      // Show success toast
      toast({
        title: "Product deleted",
        description: "The product has been successfully deleted",
      });

      // Close the dialog
      setShowDeleteDialog(false);

      onDelete?.(); // Call the callback
    } catch (error) {
      console.error("Error deleting product:", error);

      // Show error toast
      toast({
        title: "Error",
        description:
          error instanceof Error ? error.message : "Failed to delete product",
        variant: "destructive",
      });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
            <span className="sr-only">Open menu</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem asChild>
            <Link
              href={`/admin/products/${productId}`}
              className="flex items-center"
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit
            </Link>
          </DropdownMenuItem>
          <DropdownMenuItem asChild>
            <Link
              href={`/products/${productId}`}
              target="_blank"
              className="flex items-center"
            >
              <ExternalLink className="mr-2 h-4 w-4" />
              View on site
            </Link>
          </DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            className="text-red-600 focus:text-red-600 cursor-pointer"
            onClick={() => setShowDeleteDialog(true)}
          >
            <Trash className="mr-2 h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              product and all of its data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700"
              disabled={isDeleting}
            >
              {isDeleting ? "Deleting..." : "Delete"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

File: ./src/components/admin/product-categories-select.tsx
// src/components/admin/product-categories-select.tsx
"use client";

import { useState, useEffect } from "react";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Search, ChevronRight, ChevronDown } from "lucide-react";

interface Category {
  id: string;
  name: string;
  level: number;
  parentId?: string | null;
}

interface CategoryTreeItem extends Category {
  children?: CategoryTreeItem[];
  isExpanded?: boolean;
}

interface ProductCategoriesSelectProps {
  categories: Category[];
  selectedCategories: string[];
  onChange: (selected: string[]) => void;
}

export default function ProductCategoriesSelect({
  categories,
  selectedCategories,
  onChange,
}: ProductCategoriesSelectProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [localSelected, setLocalSelected] = useState<string[]>(
    selectedCategories || []
  );
  const [categoryTree, setCategoryTree] = useState<CategoryTreeItem[]>([]);
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set()
  );

  // Sync local state with props
  useEffect(() => {
    setLocalSelected(selectedCategories || []);
  }, [selectedCategories]);

  // Build category tree
  useEffect(() => {
    // First, organize into a tree structure
    const buildCategoryTree = (cats: Category[]): CategoryTreeItem[] => {
      // Map to store categories by ID for quick lookup
      const categoryMap: Record<string, CategoryTreeItem> = {};

      // Initialize the map with all categories
      cats.forEach((cat) => {
        categoryMap[cat.id] = {
          ...cat,
          children: [],
          isExpanded: expandedCategories.has(cat.id),
        };
      });

      // Build the tree by assigning children to their parents
      const rootCategories: CategoryTreeItem[] = [];

      cats.forEach((cat) => {
        if (cat.parentId && categoryMap[cat.parentId]) {
          // This is a child category
          if (!categoryMap[cat.parentId].children) {
            categoryMap[cat.parentId].children = [];
          }
          categoryMap[cat.parentId].children!.push(categoryMap[cat.id]);
        } else {
          // This is a root category (no parent)
          rootCategories.push(categoryMap[cat.id]);
        }
      });

      return rootCategories;
    };

    setCategoryTree(buildCategoryTree(categories));
  }, [categories, expandedCategories]);

  const handleCategoryChange = (categoryId: string, checked: boolean) => {
    let newSelected = [...localSelected];

    if (checked) {
      // Add this category
      newSelected.push(categoryId);

      // When selecting a subcategory, also select all its parent categories
      let currentCategory = categories.find((c) => c.id === categoryId);
      while (currentCategory && currentCategory.parentId) {
        // If the parent isn't already selected, add it
        if (!newSelected.includes(currentCategory.parentId)) {
          newSelected.push(currentCategory.parentId);
        }
        // Move up to the parent
        currentCategory = categories.find(
          (c) => c.id === currentCategory?.parentId
        );
      }
    } else {
      // Remove this category
      newSelected = newSelected.filter((id) => id !== categoryId);

      // When deselecting a category, also deselect all its children
      const getAllChildrenIds = (parentId: string): string[] => {
        const children = categories.filter((c) => c.parentId === parentId);
        if (children.length === 0) return [];

        const childrenIds = children.map((c) => c.id);
        const grandChildrenIds = children.flatMap((c) =>
          getAllChildrenIds(c.id)
        );
        return [...childrenIds, ...grandChildrenIds];
      };

      const childrenIds = getAllChildrenIds(categoryId);
      newSelected = newSelected.filter((id) => !childrenIds.includes(id));
    }

    setLocalSelected(newSelected);
    onChange(newSelected);
  };

  const toggleCategoryExpansion = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (newExpanded.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  // Filter categories based on search term
  const filterCategories = (
    items: CategoryTreeItem[],
    term: string
  ): CategoryTreeItem[] => {
    if (!term) return items;

    return items
      .filter((item) => {
        const nameMatches = item.name
          .toLowerCase()
          .includes(term.toLowerCase());
        const childMatches = item.children
          ? filterCategories(item.children, term).length > 0
          : false;

        return nameMatches || childMatches;
      })
      .map((item) => {
        if (!item.children) return item;

        return {
          ...item,
          children: filterCategories(item.children, term),
        };
      });
  };

  const filteredCategoryTree = searchTerm
    ? filterCategories(categoryTree, searchTerm)
    : categoryTree;

  // Render a category item with its children recursively
  const renderCategory = (category: CategoryTreeItem, depth = 0) => {
    const hasChildren = category.children && category.children.length > 0;
    const isExpanded = expandedCategories.has(category.id);

    return (
      <div key={category.id} className="category-item">
        <div
          className={`flex items-center px-3 py-2 hover:bg-gray-50 ${
            localSelected.includes(category.id) ? "bg-gray-50" : ""
          }`}
          style={{ paddingLeft: `${16 + depth * 20}px` }}
        >
          {hasChildren && (
            <button
              type="button"
              onClick={() => toggleCategoryExpansion(category.id)}
              className="p-1 mr-1 rounded-sm hover:bg-gray-100 text-gray-500"
            >
              {isExpanded ? (
                <ChevronDown className="h-4 w-4" />
              ) : (
                <ChevronRight className="h-4 w-4" />
              )}
            </button>
          )}
          {!hasChildren && <div className="w-6 mr-1"></div>}

          <Checkbox
            id={`category-${category.id}`}
            checked={localSelected.includes(category.id)}
            onCheckedChange={(checked) =>
              handleCategoryChange(category.id, checked === true)
            }
            className="mr-2"
          />
          <Label
            htmlFor={`category-${category.id}`}
            className="cursor-pointer flex-grow text-sm"
            style={{ color: "#2c3e50" }}
          >
            {category.name}
          </Label>
        </div>

        {hasChildren && isExpanded && (
          <div className="children">
            {category.children!.map((child) =>
              renderCategory(child, depth + 1)
            )}
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="space-y-4">
      {/* Search input */}
      <div className="relative">
        <Search
          className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4"
          style={{ color: "#bdc3c7" }}
        />
        <Input
          type="text"
          placeholder="Search categories..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="pl-10 border-2 text-gray-800 placeholder-gray-400"
          style={{
            borderColor: "#bdc3c7",
            backgroundColor: "white",
          }}
        />
      </div>

      {categories.length === 0 ? (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
          <p className="text-yellow-800">
            No categories found. Please create categories first.
          </p>
        </div>
      ) : filteredCategoryTree.length === 0 ? (
        <p style={{ color: "#2c3e50" }}>No categories match your search.</p>
      ) : (
        <div
          className="border rounded-lg overflow-auto max-h-[400px]"
          style={{ borderColor: "#bdc3c7" }}
        >
          <div className="category-tree">
            {filteredCategoryTree.map((category) => renderCategory(category))}
          </div>
        </div>
      )}

      {localSelected.length > 0 && (
        <div className="mt-4">
          <p className="text-sm" style={{ color: "#2c3e50" }}>
            Selected categories: {localSelected.length}
          </p>
          <div className="flex flex-wrap gap-2 mt-2">
            {localSelected.map((id) => {
              const category = categories.find((c) => c.id === id);
              if (!category) return null;

              return (
                <div
                  key={id}
                  style={{
                    backgroundColor: "#16a085",
                    color: "white",
                  }}
                  className="px-3 py-1 rounded-full text-sm flex items-center"
                >
                  {category.name}
                  <button
                    onClick={() => handleCategoryChange(id, false)}
                    className="ml-2 hover:text-gray-200"
                  >
                    ×
                  </button>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}

File: ./src/components/admin/custom-fields-table.tsx
// src/components/admin/custom-fields-table.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Pencil, Trash, Info, Filter } from "lucide-react";
import { formatDate } from "@/lib/utils";

interface CustomField {
  id: string;
  name: string;
  type: string;
  required: boolean;
  createdAt: string | Date;
  updatedAt: string | Date;
  usageCount?: number;
}

interface CustomFieldsTableProps {
  customFields: CustomField[];
}

export default function CustomFieldsTable({
  customFields = [],
}: CustomFieldsTableProps) {
  const router = useRouter();
  const [isEditing, setIsEditing] = useState<string | null>(null);
  const [deleteField, setDeleteField] = useState<string | null>(null);
  const [editName, setEditName] = useState("");
  const [editType, setEditType] = useState("");
  const [editRequired, setEditRequired] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [fieldTypeFilter, setFieldTypeFilter] = useState<string>("all");

  // Start editing a field
  const handleEdit = (field: CustomField) => {
    setIsEditing(field.id);
    setEditName(field.name);
    setEditType(field.type);
    setEditRequired(field.required);
  };

  // Cancel editing
  const handleCancelEdit = () => {
    setIsEditing(null);
  };

  // Save edited field
  const handleSaveEdit = async () => {
    if (!isEditing) return;

    setIsSubmitting(true);

    try {
      const response = await fetch(`/api/custom-fields/${isEditing}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: editName,
          type: editType,
          required: editRequired,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to update custom field");
      }

      setIsEditing(null);
      router.refresh();
    } catch (error) {
      console.error("Error updating custom field:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Delete a field
  const handleDelete = async () => {
    if (!deleteField) return;

    try {
      const response = await fetch(`/api/custom-fields/${deleteField}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete custom field");
      }

      setDeleteField(null);
      router.refresh();
    } catch (error) {
      console.error("Error deleting custom field:", error);
    }
  };

  // Filter and search custom fields
  const filteredFields = customFields.filter((field) => {
    const matchesSearch = field.name
      .toLowerCase()
      .includes(searchTerm.toLowerCase());
    const matchesType =
      fieldTypeFilter === "all" || field.type === fieldTypeFilter;
    return matchesSearch && matchesType;
  });

  const fieldTypes = [
    { value: "TEXT", label: "Text" },
    { value: "NUMBER", label: "Number" },
    { value: "BOOLEAN", label: "Yes/No" },
    { value: "DATE", label: "Date" },
    { value: "TEXTAREA", label: "Long Text" },
    { value: "SELECT", label: "Select" },
  ];

  // Get readable field type
  const getFieldTypeLabel = (type: string) => {
    const fieldType = fieldTypes.find((t) => t.value === type);
    return fieldType ? fieldType.label : type;
  };

  return (
    <div>
      {/* Filters */}
      <div className="flex flex-col sm:flex-row gap-3 p-4 border-b border-gray-200">
        <div className="relative flex-1">
          <Input
            placeholder="Search fields..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-8 border-gray-300 text-gray-800 placeholder:text-gray-400"
          />
          <Filter className="absolute left-2.5 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
        </div>
        <div className="w-full sm:w-48">
          <Select value={fieldTypeFilter} onValueChange={setFieldTypeFilter}>
            <SelectTrigger className="border-gray-300 text-gray-800">
              <SelectValue placeholder="Filter by type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Types</SelectItem>
              {fieldTypes.map((type) => (
                <SelectItem key={type.value} value={type.value}>
                  {type.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Table */}
      <div className="overflow-x-auto">
        <Table>
          <TableHeader className="bg-gray-50">
            <TableRow>
              <TableHead className="text-gray-700">Name</TableHead>
              <TableHead className="text-gray-700">Type</TableHead>
              <TableHead className="text-gray-700">Required</TableHead>
              <TableHead className="text-gray-700">Usage</TableHead>
              <TableHead className="text-gray-700">Created</TableHead>
              <TableHead className="text-right text-gray-700">
                Actions
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {filteredFields.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={6}
                  className="h-32 text-center text-gray-500"
                >
                  {customFields.length === 0
                    ? "No custom fields found. Add your first custom field to get started."
                    : "No custom fields match your search criteria."}
                </TableCell>
              </TableRow>
            ) : (
              filteredFields.map((field) => (
                <TableRow key={field.id} className="hover:bg-gray-50">
                  {isEditing === field.id ? (
                    // Editing row
                    <>
                      <TableCell>
                        <Input
                          value={editName}
                          onChange={(e) => setEditName(e.target.value)}
                          className="border-gray-300 text-gray-800 w-full max-w-xs"
                        />
                      </TableCell>
                      <TableCell>
                        <Select value={editType} onValueChange={setEditType}>
                          <SelectTrigger className="border-gray-300 text-gray-800 w-full max-w-[130px]">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            {fieldTypes.map((type) => (
                              <SelectItem key={type.value} value={type.value}>
                                {type.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center">
                          <Switch
                            checked={editRequired}
                            onCheckedChange={setEditRequired}
                            className="data-[state=checked]:bg-indigo-600"
                          />
                        </div>
                      </TableCell>
                      <TableCell>{field.usageCount || 0} products</TableCell>
                      <TableCell>{formatDate(field.createdAt)}</TableCell>
                      <TableCell className="text-right space-x-2">
                        <Button
                          type="button"
                          variant="outline"
                          size="sm"
                          onClick={handleCancelEdit}
                          className="border-gray-300 text-gray-700"
                        >
                          Cancel
                        </Button>
                        <Button
                          type="button"
                          size="sm"
                          onClick={handleSaveEdit}
                          disabled={isSubmitting}
                          className="bg-indigo-600 hover:bg-indigo-700 text-white"
                        >
                          Save
                        </Button>
                      </TableCell>
                    </>
                  ) : (
                    // Normal row
                    <>
                      <TableCell className="font-medium text-gray-800">
                        {field.name}
                      </TableCell>
                      <TableCell>{getFieldTypeLabel(field.type)}</TableCell>
                      <TableCell>
                        {field.required ? (
                          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                            Required
                          </span>
                        ) : (
                          <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                            Optional
                          </span>
                        )}
                      </TableCell>
                      <TableCell>
                        <span className="text-gray-700">
                          {field.usageCount || 0} products
                        </span>
                      </TableCell>
                      <TableCell>{formatDate(field.createdAt)}</TableCell>
                      <TableCell className="text-right space-x-1">
                        <Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => handleEdit(field)}
                          className="text-gray-700 hover:text-indigo-600"
                        >
                          <Pencil className="h-4 w-4" />
                        </Button>
                        <Button
                          type="button"
                          variant="ghost"
                          size="sm"
                          onClick={() => setDeleteField(field.id)}
                          className="text-gray-700 hover:text-red-600"
                          disabled={
                            field.usageCount ? field.usageCount > 0 : false
                          }
                          title={
                            field.usageCount && field.usageCount > 0
                              ? "Cannot delete fields in use"
                              : "Delete field"
                          }
                        >
                          <Trash className="h-4 w-4" />
                        </Button>
                      </TableCell>
                    </>
                  )}
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Delete Confirmation Dialog */}
      <AlertDialog
        open={!!deleteField}
        onOpenChange={() => setDeleteField(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              custom field and may affect products using it.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="border-gray-300 text-gray-700">
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700 text-white"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

File: ./src/components/admin/product-form-types.ts
// src/components/admin/product-form-types.ts
import { z } from "zod";

// Custom field value matching your database model
export interface CustomFieldValue {
  id?: string;
  customFieldId: string;
  value: string;
}

// Form schema validation
export const productSchema = z.object({
  name: z
    .string()
    .min(2, { message: "Product name must be at least 2 characters" }),
  description: z.string().optional(),
  price: z.coerce
    .number()
    .min(0, { message: "Price must be a positive number" }),
  // Remove compareAtPrice
  cost: z.coerce.number().optional().nullable(),
  barcode: z.string().optional(),
  inventory: z.coerce.number().int().default(0),
  tva: z.coerce.number().min(0).max(100).default(19), // TVA field with default 19%
  // We'll calculate profit % automatically
  categoryIds: z.array(z.string()).default([]),
  images: z.array(z.string()).default([]),
  variants: z
    .array(
      z.object({
        id: z.string().optional(),
        name: z.string(),
        price: z.coerce.number().min(0),
        inventory: z.coerce.number().int().default(0),
        sku: z.string().optional(),
        barcode: z.string().optional(),
        options: z.record(z.string(), z.string()),
      })
    )
    .default([]),
  expiryDate: z.string().optional().nullable(),
  customFieldValues: z
    .array(
      z.object({
        id: z.string().optional(),
        customFieldId: z.string(),
        value: z.string(),
      })
    )
    .default([]),
});

export type ProductFormValues = z.infer<typeof productSchema>;

// Types for other components
export interface Category {
  id: string;
  name: string;
  level: number;
}

export interface CustomField {
  id: string;
  name: string;
  type: string;
  required: boolean;
}

export interface ProductFormProps {
  product?: any;
  categories: Category[];
  customFields?: CustomField[];
  shopId: string;
  isEditing?: boolean;
}

// New type for discounts
export interface Discount {
  id?: string;
  percentage: number;
  enabled: boolean;
  startDate: Date | string;
  endDate: Date | string;
  productId: string;
}

// New type for discount codes
export interface DiscountCode {
  id?: string;
  code: string;
  percentage: number;
  startDate: Date | string;
  endDate: Date | string;
  shopId: string;
  productId?: string | null;
  userId?: string | null;
  isActive: boolean;
}

File: ./src/components/admin/add-custom-field-form.tsx
// src/components/admin/add-custom-field-form.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { AlertCircle, CheckCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";

// Form schema
const customFieldSchema = z.object({
  name: z.string().min(2, "Field name must be at least 2 characters"),
  type: z.string().min(1, "Field type is required"),
  required: z.boolean().default(false),
});

type CustomFieldFormValues = z.infer<typeof customFieldSchema>;

export default function AddCustomFieldForm() {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const form = useForm<CustomFieldFormValues>({
    resolver: zodResolver(customFieldSchema),
    defaultValues: {
      name: "",
      type: "TEXT",
      required: false,
    },
  });

  const onSubmit = async (values: CustomFieldFormValues) => {
    setIsSubmitting(true);
    setError(null);
    setSuccess(false);

    try {
      const response = await fetch("/api/custom-fields", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Failed to create custom field");
      }

      // Reset form and show success message
      form.reset();
      setSuccess(true);

      // Refresh to update the list
      router.refresh();

      // Clear success message after 3 seconds
      setTimeout(() => {
        setSuccess(false);
      }, 3000);
    } catch (err: any) {
      setError(err.message || "An error occurred");
      console.error("Error creating custom field:", err);
    } finally {
      setIsSubmitting(false);
    }
  };

  const fieldTypes = [
    { value: "TEXT", label: "Text (Single line)" },
    { value: "TEXTAREA", label: "Text (Multiple lines)" },
    { value: "NUMBER", label: "Number" },
    { value: "DATE", label: "Date" },
    { value: "BOOLEAN", label: "Yes/No" },
    { value: "SELECT", label: "Select (Dropdown)" },
  ];

  return (
    <div>
      {error && (
        <Alert variant="destructive" className="mb-4">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {success && (
        <Alert className="mb-4 bg-green-50 border-green-200">
          <CheckCircle className="h-4 w-4 text-green-600" />
          <AlertDescription className="text-green-700">
            Custom field created successfully!
          </AlertDescription>
        </Alert>
      )}

      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-gray-700">Field Name</FormLabel>
                <FormControl>
                  <Input
                    {...field}
                    placeholder="e.g., Material, Color, Dimensions"
                    className="border-gray-300 text-gray-800 placeholder:text-gray-400"
                  />
                </FormControl>
                <FormDescription className="text-gray-600">
                  This name will appear as a label in product forms
                </FormDescription>
                <FormMessage className="text-red-500" />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="type"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-gray-700">Field Type</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger className="border-gray-300 text-gray-800">
                      <SelectValue placeholder="Select field type" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {fieldTypes.map((type) => (
                      <SelectItem key={type.value} value={type.value}>
                        {type.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormDescription className="text-gray-600">
                  This determines how the field will be displayed and what kind
                  of data it accepts
                </FormDescription>
                <FormMessage className="text-red-500" />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="required"
            render={({ field }) => (
              <FormItem className="flex flex-row items-center justify-between rounded-lg border border-gray-200 p-4">
                <div className="space-y-0.5">
                  <FormLabel className="text-gray-700">
                    Required Field
                  </FormLabel>
                  <FormDescription className="text-gray-600">
                    Make this field mandatory when creating or editing products
                  </FormDescription>
                </div>
                <FormControl>
                  <Switch
                    checked={field.value}
                    onCheckedChange={field.onChange}
                    className="data-[state=checked]:bg-indigo-600"
                  />
                </FormControl>
              </FormItem>
            )}
          />

          <Button
            type="submit"
            disabled={isSubmitting}
            className="w-full bg-indigo-600 hover:bg-indigo-700 text-white"
          >
            {isSubmitting ? "Creating..." : "Create Custom Field"}
          </Button>
        </form>
      </Form>
    </div>
  );
}

File: ./src/components/admin/product-variants-form.tsx
// src/components/admin/product-variants-form.tsx
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Trash, Plus, ChevronDown, ChevronUp } from "lucide-react";
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

interface Variant {
  id?: string;
  name: string;
  price: number;
  inventory: number;
  sku?: string;
  barcode?: string;
  options: Record<string, string>;
}

interface ProductVariantsFormProps {
  variants: Variant[];
  onChange: (variants: Variant[]) => void;
}

export default function ProductVariantsForm({
  variants = [],
  onChange,
}: ProductVariantsFormProps) {
  // Local state to ensure we don't lose changes when switching tabs
  const [localVariants, setLocalVariants] = useState<Variant[]>(variants);
  const [expandedVariants, setExpandedVariants] = useState<Set<number>>(
    new Set()
  );
  const [optionTypes, setOptionTypes] = useState<string[]>(
    // Extract unique option types from existing variants or provide defaults
    Array.from(
      new Set(
        localVariants.flatMap((variant) => Object.keys(variant.options || {}))
      )
    ).length > 0
      ? Array.from(
          new Set(
            localVariants.flatMap((variant) =>
              Object.keys(variant.options || {})
            )
          )
        )
      : ["Color", "Size"] // Default option types
  );

  // Sync with parent when props change
  useEffect(() => {
    setLocalVariants(variants);
  }, [variants]);

  // Toggle variant expanded/collapsed state
  const toggleVariant = (index: number) => {
    const newExpandedVariants = new Set(expandedVariants);
    if (expandedVariants.has(index)) {
      newExpandedVariants.delete(index);
    } else {
      newExpandedVariants.add(index);
    }
    setExpandedVariants(newExpandedVariants);
  };

  // Add a new variant
  const addVariant = () => {
    // Create a new variant with empty values for each option type
    const newVariant: Variant = {
      name: "",
      price: 0,
      inventory: 0,
      sku: "",
      options: optionTypes.reduce((acc, type) => {
        acc[type] = "";
        return acc;
      }, {} as Record<string, string>),
    };

    const updatedVariants = [...localVariants, newVariant];
    setLocalVariants(updatedVariants);
    onChange(updatedVariants);

    // Auto-expand the newly added variant
    setExpandedVariants(new Set([...expandedVariants, localVariants.length]));
  };

  // Update a variant
  const updateVariant = (index: number, field: keyof Variant, value: any) => {
    const updatedVariants = [...localVariants];

    if (field === "options") {
      updatedVariants[index].options = {
        ...updatedVariants[index].options,
        ...value,
      };

      // Auto-generate name from options if it hasn't been manually set
      const currentName = updatedVariants[index].name;
      const generatedName = Object.values(updatedVariants[index].options)
        .filter(Boolean)
        .join(" / ");

      // Only update name if it appears to be auto-generated or empty
      if (
        !currentName ||
        currentName ===
          Object.values({ ...updatedVariants[index].options, ...value })
            .filter(Boolean)
            .join(" / ")
      ) {
        updatedVariants[index].name = generatedName;
      }
    } else {
      // @ts-ignore - We know this is a valid field
      updatedVariants[index][field] = value;
    }

    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  // Remove a variant
  const removeVariant = (index: number) => {
    const updatedVariants = [...localVariants];
    updatedVariants.splice(index, 1);

    // Update expanded variants set
    const newExpandedVariants = new Set<number>();
    expandedVariants.forEach((expandedIndex) => {
      if (expandedIndex < index) {
        newExpandedVariants.add(expandedIndex);
      } else if (expandedIndex > index) {
        newExpandedVariants.add(expandedIndex - 1);
      }
    });

    setExpandedVariants(newExpandedVariants);
    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  // Add a new option type (e.g., Color, Size)
  const addOptionType = () => {
    let newOptionName = "New Option";
    let counter = 1;

    // Make sure the name is unique
    while (optionTypes.includes(newOptionName)) {
      newOptionName = `New Option ${counter}`;
      counter++;
    }

    // Add to option types
    const newOptionTypes = [...optionTypes, newOptionName];
    setOptionTypes(newOptionTypes);

    // Add this option to all variants with empty value
    const updatedVariants = localVariants.map((variant) => ({
      ...variant,
      options: {
        ...variant.options,
        [newOptionName]: "",
      },
    }));

    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  // Update option type name
  const updateOptionType = (oldType: string, newType: string) => {
    // Prevent duplicate option types
    if (optionTypes.includes(newType) && oldType !== newType) {
      return;
    }

    // Update option type
    const newOptionTypes = optionTypes.map((type) =>
      type === oldType ? newType : type
    );
    setOptionTypes(newOptionTypes);

    // Update option keys in all variants
    const updatedVariants = localVariants.map((variant) => {
      const updatedOptions = { ...variant.options };
      if (oldType in updatedOptions) {
        updatedOptions[newType] = updatedOptions[oldType];
        delete updatedOptions[oldType];
      }

      return {
        ...variant,
        options: updatedOptions,
      };
    });

    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  // Remove an option type
  const removeOptionType = (typeToRemove: string) => {
    // Remove from option types
    const newOptionTypes = optionTypes.filter((type) => type !== typeToRemove);
    setOptionTypes(newOptionTypes);

    // Remove this option from all variants
    const updatedVariants = localVariants.map((variant) => {
      const updatedOptions = { ...variant.options };
      delete updatedOptions[typeToRemove];

      return {
        ...variant,
        options: updatedOptions,
      };
    });

    setLocalVariants(updatedVariants);
    onChange(updatedVariants);
  };

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
            Option Types
          </h3>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={addOptionType}
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
            }}
          >
            <Plus className="h-4 w-4 mr-2" />
            Add Option Type
          </Button>
        </div>

        <div
          className="border rounded-lg p-4"
          style={{ borderColor: "#bdc3c7" }}
        >
          <p className="text-sm mb-4" style={{ color: "#7f8c8d" }}>
            Define the option types for your variants (e.g., Color, Size,
            Material). Each variant can have different values for these options.
          </p>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {optionTypes.map((type, index) => (
              <div key={index} className="flex items-center space-x-2">
                <Input
                  value={type}
                  onChange={(e) => updateOptionType(type, e.target.value)}
                  placeholder="e.g., Color, Size, Material"
                  className="border-2"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#2c3e50",
                    backgroundColor: "white",
                  }}
                />
                <Button
                  type="button"
                  variant="ghost"
                  size="icon"
                  onClick={() => removeOptionType(type)}
                  disabled={optionTypes.length <= 1}
                  style={{
                    color: optionTypes.length <= 1 ? "#bdc3c7" : "#e74c3c",
                  }}
                >
                  <Trash className="h-4 w-4" />
                </Button>
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
            Product Variants
          </h3>
          <Button
            type="button"
            onClick={addVariant}
            style={{
              backgroundColor: "#16a085",
              color: "white",
            }}
          >
            <Plus className="h-4 w-4 mr-2" />
            Add Variant
          </Button>
        </div>

        {localVariants.length === 0 ? (
          <div
            className="border rounded-lg p-6 text-center"
            style={{ borderColor: "#bdc3c7" }}
          >
            <p style={{ color: "#2c3e50" }}>
              No variants yet. Add variants to create different versions of your
              product (e.g., different colors, sizes).
            </p>
            <Button
              type="button"
              onClick={addVariant}
              style={{
                backgroundColor: "#16a085",
                color: "white",
                marginTop: "1rem",
              }}
            >
              <Plus className="h-4 w-4 mr-2" />
              Add Your First Variant
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {localVariants.map((variant, index) => (
              <Card
                key={index}
                className="border overflow-hidden"
                style={{ borderColor: "#bdc3c7" }}
              >
                <CardHeader
                  className="flex flex-row items-center justify-between cursor-pointer p-4"
                  style={{
                    backgroundColor: expandedVariants.has(index)
                      ? "#f5f7fa"
                      : "white",
                  }}
                  onClick={() => toggleVariant(index)}
                >
                  <div className="flex items-center">
                    {expandedVariants.has(index) ? (
                      <ChevronUp
                        className="h-4 w-4 mr-2"
                        style={{ color: "#2c3e50" }}
                      />
                    ) : (
                      <ChevronDown
                        className="h-4 w-4 mr-2"
                        style={{ color: "#2c3e50" }}
                      />
                    )}
                    <CardTitle
                      className="text-base font-medium"
                      style={{ color: "#2c3e50" }}
                    >
                      {variant.name || `Variant ${index + 1}`}
                    </CardTitle>
                  </div>
                  <div className="flex items-center">
                    <span style={{ color: "#2c3e50" }}>
                      ${variant.price.toFixed(2)}
                    </span>
                    <span className="mx-2 text-sm" style={{ color: "#7f8c8d" }}>
                      |
                    </span>
                    <span style={{ color: "#2c3e50" }}>
                      {variant.inventory} in stock
                    </span>
                  </div>
                </CardHeader>

                {expandedVariants.has(index) && (
                  <CardContent
                    className="p-4 border-t"
                    style={{ borderColor: "#bdc3c7" }}
                  >
                    <div className="space-y-4">
                      {/* Option values section */}
                      <div>
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "#2c3e50" }}
                        >
                          Options
                        </h4>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                          {optionTypes.map((optionType) => (
                            <div key={optionType} className="space-y-2">
                              <Label style={{ color: "#2c3e50" }}>
                                {optionType}
                              </Label>
                              <Input
                                value={variant.options[optionType] || ""}
                                onChange={(e) =>
                                  updateVariant(index, "options", {
                                    [optionType]: e.target.value,
                                  })
                                }
                                placeholder={`Enter ${optionType.toLowerCase()}`}
                                className="border-2"
                                style={{
                                  borderColor: "#bdc3c7",
                                  color: "#2c3e50",
                                  backgroundColor: "white",
                                }}
                              />
                            </div>
                          ))}
                        </div>
                      </div>

                      {/* Basic info section */}
                      <div>
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "#2c3e50" }}
                        >
                          Variant Details
                        </h4>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>
                              Variant Name
                            </Label>
                            <Input
                              value={variant.name}
                              onChange={(e) =>
                                updateVariant(index, "name", e.target.value)
                              }
                              placeholder="Auto-generated from options if empty"
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>

                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>Price</Label>
                            <Input
                              type="number"
                              step="0.01"
                              value={variant.price}
                              onChange={(e) =>
                                updateVariant(
                                  index,
                                  "price",
                                  parseFloat(e.target.value) || 0
                                )
                              }
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>

                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>
                              Inventory
                            </Label>
                            <Input
                              type="number"
                              value={variant.inventory}
                              onChange={(e) =>
                                updateVariant(
                                  index,
                                  "inventory",
                                  parseInt(e.target.value) || 0
                                )
                              }
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>
                        </div>
                      </div>

                      {/* Extra fields */}
                      <div>
                        <h4
                          className="font-medium mb-2"
                          style={{ color: "#2c3e50" }}
                        >
                          Additional Information
                        </h4>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>SKU</Label>
                            <Input
                              value={variant.sku || ""}
                              onChange={(e) =>
                                updateVariant(index, "sku", e.target.value)
                              }
                              placeholder="Optional"
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>

                          <div className="space-y-2">
                            <Label style={{ color: "#2c3e50" }}>Barcode</Label>
                            <Input
                              value={variant.barcode || ""}
                              onChange={(e) =>
                                updateVariant(index, "barcode", e.target.value)
                              }
                              placeholder="Optional"
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                                backgroundColor: "white",
                              }}
                            />
                          </div>
                        </div>
                      </div>
                    </div>

                    <div className="flex justify-end mt-4">
                      <Button
                        type="button"
                        variant="destructive"
                        onClick={() => removeVariant(index)}
                        style={{
                          backgroundColor: "#e74c3c",
                          color: "white",
                        }}
                      >
                        <Trash className="h-4 w-4 mr-2" />
                        Remove Variant
                      </Button>
                    </div>
                  </CardContent>
                )}
              </Card>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

File: ./src/components/admin/discount-form.tsx
// src/components/admin/discount-form.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import * as z from "zod";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

// Form schema
const discountSchema = z.object({
  productId: z.string().min(1, "Product is required"),
  percentage: z
    .number()
    .min(0.01, "Discount must be greater than 0")
    .max(100, "Discount cannot exceed 100%"),
  enabled: z.boolean().default(true),
  startDate: z.string().min(1, "Start date is required"),
  endDate: z.string().min(1, "End date is required"),
});

type DiscountFormValues = z.infer<typeof discountSchema>;

interface Product {
  id: string;
  name: string;
  price: number;
}

interface Discount {
  id: string;
  percentage: number;
  enabled: boolean;
  startDate: string | Date;
  endDate: string | Date;
  productId: string;
  product: {
    id: string;
    name: string;
    price: number;
  };
}

interface DiscountFormProps {
  discount?: Discount;
  products: Product[];
  shopId: string;
  isEditing?: boolean;
}

export default function DiscountForm({
  discount,
  products,
  shopId,
  isEditing = false,
}: DiscountFormProps) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(
    discount?.product || null
  );

  // Default values for the form
  const defaultValues: DiscountFormValues = discount
    ? {
        productId: discount.productId,
        percentage: discount.percentage,
        enabled: discount.enabled,
        startDate: new Date(discount.startDate).toISOString().split("T")[0],
        endDate: new Date(discount.endDate).toISOString().split("T")[0],
      }
    : {
        productId: "",
        percentage: 10,
        enabled: true,
        startDate: new Date().toISOString().split("T")[0],
        endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
          .toISOString()
          .split("T")[0], // Default to 30 days from now
      };

  // Create form
  const form = useForm<DiscountFormValues>({
    resolver: zodResolver(discountSchema),
    defaultValues,
  });

  // Watch the product ID to update the selected product
  const productId = form.watch("productId");
  const percentage = form.watch("percentage");

  // Update selected product when productId changes
  useEffect(() => {
    if (productId) {
      const product = products.find((p) => p.id === productId);
      if (product) {
        setSelectedProduct(product);
      }
    } else {
      setSelectedProduct(null);
    }
  }, [productId, products]);

  // Calculate discounted price for preview
  const getDiscountedPrice = (price: number, discountPercentage: number) => {
    if (!price || !discountPercentage) return price;
    const discount = (price * discountPercentage) / 100;
    return price - discount;
  };

  // Form submission handler
  const onSubmit = async (values: DiscountFormValues) => {
    setIsSubmitting(true);
    setSubmitError(null);

    try {
      const url = isEditing
        ? `/api/discounts/${discount?.id}`
        : "/api/discounts";
      const method = isEditing ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to save discount");
      }

      // Redirect to the discounts list page
      router.push("/admin/discounts");
      router.refresh();
    } catch (error: any) {
      console.error("Error saving discount:", error);
      setSubmitError(error.message || "An error occurred while saving");
      setIsSubmitting(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        {submitError && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{submitError}</AlertDescription>
          </Alert>
        )}

        <div className="grid gap-6 md:grid-cols-2">
          <Card className="border-0 shadow">
            <CardHeader
              style={{ backgroundColor: "#2c3e50" }}
              className="text-white rounded-t-lg"
            >
              <CardTitle className="text-xl font-medium">
                Discount Details
              </CardTitle>
              <CardDescription
                style={{ color: "#bdc3c7" }}
                className="mt-1 text-base"
              >
                Configure your product discount
              </CardDescription>
            </CardHeader>

            <CardContent className="pt-6 space-y-4 bg-white">
              <FormField
                control={form.control}
                name="productId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel
                      style={{ color: "#2c3e50" }}
                      className="font-medium text-base"
                    >
                      Product *
                    </FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                      disabled={isEditing} // Disable changing product in edit mode
                    >
                      <FormControl>
                        <SelectTrigger
                          className="border-2"
                          style={{
                            borderColor: "#bdc3c7",
                            color: "#2c3e50",
                            backgroundColor: "white",
                          }}
                        >
                          <SelectValue placeholder="Select a product" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {products.map((product) => (
                          <SelectItem key={product.id} value={product.id}>
                            {product.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormDescription style={{ color: "#7f8c8d" }}>
                      Select the product this discount applies to
                    </FormDescription>
                    <FormMessage className="text-red-600" />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="percentage"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel
                      style={{ color: "#2c3e50" }}
                      className="font-medium text-base"
                    >
                      Discount Percentage *
                    </FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        step="0.01"
                        min="0"
                        max="100"
                        className="border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                        {...field}
                        onChange={(e) => {
                          const value = parseFloat(e.target.value);
                          field.onChange(isNaN(value) ? 0 : value);
                        }}
                      />
                    </FormControl>
                    <FormDescription style={{ color: "#7f8c8d" }}>
                      Enter a discount percentage (0-100)
                    </FormDescription>
                    <FormMessage className="text-red-600" />
                  </FormItem>
                )}
              />

              <div className="grid grid-cols-2 gap-4">
                <FormField
                  control={form.control}
                  name="startDate"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel
                        style={{ color: "#2c3e50" }}
                        className="font-medium text-base"
                      >
                        Start Date *
                      </FormLabel>
                      <FormControl>
                        <Input
                          type="date"
                          className="border-2"
                          style={{
                            borderColor: "#bdc3c7",
                            color: "#2c3e50",
                            backgroundColor: "white",
                          }}
                          {...field}
                        />
                      </FormControl>
                      <FormMessage className="text-red-600" />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="endDate"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel
                        style={{ color: "#2c3e50" }}
                        className="font-medium text-base"
                      >
                        End Date *
                      </FormLabel>
                      <FormControl>
                        <Input
                          type="date"
                          className="border-2"
                          style={{
                            borderColor: "#bdc3c7",
                            color: "#2c3e50",
                            backgroundColor: "white",
                          }}
                          {...field}
                        />
                      </FormControl>
                      <FormMessage className="text-red-600" />
                    </FormItem>
                  )}
                />
              </div>

              <FormField
                control={form.control}
                name="enabled"
                render={({ field }) => (
                  <FormItem className="flex flex-row items-center justify-between rounded-lg border border-gray-200 p-4 shadow-sm">
                    <div className="space-y-0.5">
                      <FormLabel
                        style={{ color: "#2c3e50" }}
                        className="font-medium text-base"
                      >
                        Active
                      </FormLabel>
                      <FormDescription style={{ color: "#7f8c8d" }}>
                        Enable or disable this discount
                      </FormDescription>
                    </div>
                    <FormControl>
                      <Switch
                        checked={field.value}
                        onCheckedChange={field.onChange}
                      />
                    </FormControl>
                  </FormItem>
                )}
              />
            </CardContent>
          </Card>

          <div className="space-y-6">
            {selectedProduct && (
              <Card className="border border-gray-200 shadow-sm">
                <CardHeader className="bg-gray-50 border-b border-gray-200">
                  <CardTitle className="text-lg text-gray-800">
                    Discount Preview
                  </CardTitle>
                </CardHeader>
                <CardContent className="pt-6 bg-white">
                  <div className="space-y-4">
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Product
                      </h3>
                      <p className="text-lg font-medium text-gray-900">
                        {selectedProduct.name}
                      </p>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Original Price
                      </h3>
                      <p className="text-lg font-medium text-gray-900">
                        ${selectedProduct.price.toFixed(2)}
                      </p>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Discount
                      </h3>
                      <p className="text-lg font-medium text-orange-600">
                        {percentage}%
                      </p>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Discounted Price
                      </h3>
                      <p className="text-xl font-bold text-green-600">
                        $
                        {getDiscountedPrice(
                          selectedProduct.price,
                          percentage
                        ).toFixed(2)}
                      </p>
                    </div>
                    <div>
                      <h3 className="text-sm font-medium text-gray-500">
                        Savings
                      </h3>
                      <p className="text-lg font-medium text-red-600">
                        $
                        {(
                          selectedProduct.price -
                          getDiscountedPrice(selectedProduct.price, percentage)
                        ).toFixed(2)}
                      </p>
                    </div>
                  </div>
                </CardContent>
              </Card>
            )}

            {/* Help section */}
            <Card className="border border-blue-200 shadow-sm">
              <CardHeader className="bg-blue-50 border-b border-blue-200">
                <CardTitle className="text-lg text-blue-800">
                  About Discounts
                </CardTitle>
              </CardHeader>
              <CardContent className="pt-4 bg-white">
                <ul className="space-y-2 text-sm text-blue-700">
                  <li>• Discounts apply to specific products</li>
                  <li>• Set a percentage discount (e.g., 10% off)</li>
                  <li>• Define a date range for your promotion</li>
                  <li>• Enable/disable discounts without deleting them</li>
                  <li>• Create multiple discounts for different products</li>
                </ul>
              </CardContent>
            </Card>
          </div>
        </div>

        <div className="flex justify-end gap-4">
          <Button
            type="button"
            variant="outline"
            onClick={() => router.push("/admin/discounts")}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          >
            Cancel
          </Button>
          <Button
            type="submit"
            disabled={isSubmitting}
            style={{
              backgroundColor: "#16a085",
              color: "white",
            }}
            className="font-semibold hover:opacity-90"
          >
            {isSubmitting
              ? "Saving..."
              : isEditing
              ? "Update Discount"
              : "Create Discount"}
          </Button>
        </div>
      </form>
    </Form>
  );
}

File: ./src/components/admin/product-images-upload.tsx
"use client";

import { useState, useEffect } from "react";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import {
  Trash,
  Upload,
  MoveUp,
  MoveDown,
  PlusCircle,
  ImageIcon,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { s3ImageService } from "@/lib/services/s3-image.service";

interface ProductImagesUploadProps {
  existingImages: string[];
  onImagesChange: (images: string[]) => void;
}

// Use localStorage to persist image previews across tab changes
const LOCAL_STORAGE_KEY = "product_image_previews";

export default function ProductImagesUpload({
  existingImages = [],
  onImagesChange,
}: ProductImagesUploadProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [images, setImages] = useState<string[]>(existingImages || []);
  const [previewImages, setPreviewImages] = useState<Record<string, string>>(
    {}
  );

  // Load previews from localStorage on component mount
  useEffect(() => {
    try {
      const storedPreviews = localStorage.getItem(LOCAL_STORAGE_KEY);
      if (storedPreviews) {
        setPreviewImages(JSON.parse(storedPreviews));
      }
    } catch (error) {
      console.error("Error loading image previews from localStorage:", error);
    }
  }, []);

  // Save previews to localStorage whenever they change
  useEffect(() => {
    if (Object.keys(previewImages).length > 0) {
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(previewImages));
      } catch (error) {
        console.error("Error saving image previews to localStorage:", error);
      }
    }
  }, [previewImages]);

  // Initialize preview images from existing images and sync when props change
  useEffect(() => {
    setImages(existingImages || []);

    // Initialize preview images for existing images
    const initialPreviews: Record<string, string> = {};

    existingImages?.forEach(async (img: string) => {
      // Only create previews for items that appear to be URLs or S3 keys
      // and aren't already in the preview cache
      if (img && !previewImages[img]) {
        if (img.startsWith("http") || img.startsWith("/")) {
          // For HTTP URLs or local paths
          initialPreviews[img] = img;
        } else if (s3ImageService.isS3Key(img)) {
          // For S3 keys, get the URL
          try {
            const imageUrl = await s3ImageService.getImageUrl(img);
            initialPreviews[img] = imageUrl;
          } catch (error) {
            console.error(`Error getting URL for S3 image ${img}:`, error);
            // Use a placeholder or just the key itself
            initialPreviews[img] = img;
          }
        }
      }
    });

    if (Object.keys(initialPreviews).length > 0) {
      setPreviewImages((prev) => ({ ...prev, ...initialPreviews }));
    }
  }, [existingImages]);

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;
    setIsUploading(true);

    try {
      // In a real implementation, you would upload to your storage service
      // For now, we'll just create local object URLs as a placeholder
      const newImages = [...images];
      const newPreviews = { ...previewImages };

      for (let i = 0; i < e.target.files.length; i++) {
        const file = e.target.files[i];

        // Create a unique ID for this image
        const imageId = `image_${Date.now()}_${i}`;

        // Create a base64 data URL for the image
        const reader = new FileReader();
        reader.onload = (event) => {
          if (event.target?.result) {
            const imageDataUrl = event.target.result as string;
            newPreviews[imageId] = imageDataUrl;

            // Add the data URL to the images array to be processed by the S3 service later
            newImages.push(imageDataUrl);

            // Update state if this is the last file
            if (i === e.target.files!.length - 1) {
              setImages(newImages);
              setPreviewImages(newPreviews);
              onImagesChange(newImages);
              setIsUploading(false);
            }
          }
        };
        reader.readAsDataURL(file);
      }
    } catch (error) {
      console.error("Error uploading images:", error);
      setIsUploading(false);
    }
  };

  const removeImage = (index: number) => {
    const newImages = [...images];
    const removedImageId = newImages.splice(index, 1)[0];

    // Clean up object URL to prevent memory leaks
    if (previewImages[removedImageId]) {
      // Only revoke URL if it's a blob URL (created by URL.createObjectURL)
      if (previewImages[removedImageId].startsWith("blob:")) {
        URL.revokeObjectURL(previewImages[removedImageId]);
      }
      const newPreviews = { ...previewImages };
      delete newPreviews[removedImageId];
      setPreviewImages(newPreviews);
    }

    setImages(newImages);
    onImagesChange(newImages);
  };

  const moveImage = (index: number, direction: "up" | "down") => {
    if (
      (direction === "up" && index === 0) ||
      (direction === "down" && index === images.length - 1)
    ) {
      return;
    }

    const newImages = [...images];
    const newIndex = direction === "up" ? index - 1 : index + 1;
    [newImages[index], newImages[newIndex]] = [
      newImages[newIndex],
      newImages[index],
    ];

    setImages(newImages);
    onImagesChange(newImages);
  };

  // Helper to get image src (either from preview or from the image URL itself)
  const getImageSrc = (imageId: string): string | null => {
    // Check if it's a preview image first
    if (previewImages[imageId]) {
      return previewImages[imageId];
    }

    // Handle existing images that could be URLs or paths
    if (imageId.startsWith("http") || imageId.startsWith("/")) {
      return imageId;
    }

    // Handle S3 keys - in this component we should already have URLs in the preview state
    // But include this for safety
    if (s3ImageService.isS3Key(imageId)) {
      // For the UI display, we return a placeholder while loading S3 URL
      return "/placeholder.jpg";
    }

    // Log for debugging
    console.log("No preview found for:", imageId);
    console.log("Current previews:", previewImages);

    // Fallback to a placeholder for invalid images
    return null;
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col items-center justify-center w-full">
        <label
          htmlFor="image-upload"
          className="flex flex-col items-center justify-center w-full h-40 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100 transition-colors"
        >
          <div className="flex flex-col items-center justify-center pt-5 pb-6">
            <Upload className="w-10 h-10 mb-3 text-gray-400" />
            <p className="mb-2 text-sm text-gray-600">
              <span className="font-semibold">Click to upload</span> or drag and
              drop
            </p>
            <p className="text-xs text-gray-500">PNG, JPG, GIF up to 10MB</p>
          </div>
          <Input
            id="image-upload"
            type="file"
            accept="image/*"
            multiple
            className="hidden"
            onChange={handleImageUpload}
            disabled={isUploading}
          />
        </label>
      </div>

      {isUploading && (
        <div className="flex items-center justify-center py-2">
          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-indigo-600 mr-2"></div>
          <p className="text-gray-600">Uploading images...</p>
        </div>
      )}

      {images.length > 0 && (
        <div>
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-md font-medium text-gray-700">
              Product Images ({images.length})
            </h3>
            {images.length > 1 && (
              <p className="text-sm text-gray-500">
                First image will be the main product image.
              </p>
            )}
          </div>

          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {images.map((image, index) => (
              <Card
                key={index}
                className="relative group border border-gray-200 rounded-lg overflow-hidden"
              >
                <div className="aspect-square relative overflow-hidden">
                  <div
                    className={cn(
                      "w-full h-full flex items-center justify-center bg-gray-100",
                      index === 0 && "border-2 border-indigo-500"
                    )}
                  >
                    {getImageSrc(image) ? (
                      <Image
                        src={getImageSrc(image) || "/placeholder.jpg"}
                        alt={`Product image ${index + 1}`}
                        fill
                        className="object-cover"
                      />
                    ) : (
                      <div className="flex flex-col items-center justify-center text-gray-400">
                        <ImageIcon className="w-12 h-12 mb-2" />
                        <span className="text-xs">Image Preview</span>
                      </div>
                    )}
                  </div>
                </div>

                <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 flex space-x-1 transition-opacity">
                  <Button
                    type="button"
                    variant="destructive"
                    size="icon"
                    className="h-7 w-7 bg-red-600 hover:bg-red-700"
                    onClick={() => removeImage(index)}
                  >
                    <Trash className="h-4 w-4" />
                  </Button>
                </div>

                <div className="absolute bottom-2 right-2 opacity-0 group-hover:opacity-100 flex space-x-1 transition-opacity">
                  <Button
                    type="button"
                    variant="secondary"
                    size="icon"
                    className="h-7 w-7 bg-white text-gray-800"
                    onClick={() => moveImage(index, "up")}
                    disabled={index === 0}
                  >
                    <MoveUp className="h-4 w-4" />
                  </Button>
                  <Button
                    type="button"
                    variant="secondary"
                    size="icon"
                    className="h-7 w-7 bg-white text-gray-800"
                    onClick={() => moveImage(index, "down")}
                    disabled={index === images.length - 1}
                  >
                    <MoveDown className="h-4 w-4" />
                  </Button>
                </div>

                <div className="absolute bottom-2 left-2 bg-black bg-opacity-70 text-white text-xs px-2 py-1 rounded">
                  {index === 0 ? "Main" : `Image ${index + 1}`}
                </div>
              </Card>
            ))}

            {/* Add image placeholder */}
            <Card
              className="border-2 border-dashed border-gray-300 rounded-lg overflow-hidden hover:border-gray-400 transition-colors cursor-pointer"
              onClick={() => document.getElementById("image-upload")?.click()}
            >
              <div className="aspect-square flex flex-col items-center justify-center bg-gray-50 p-4">
                <PlusCircle className="w-10 h-10 mb-2 text-gray-400" />
                <p className="text-sm text-gray-500 text-center">
                  Add more images
                </p>
              </div>
            </Card>
          </div>
        </div>
      )}
    </div>
  );
}

File: ./src/components/admin/discount-list-actions.tsx
// src/components/admin/discount-list-actions.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { MoreHorizontal, Edit, Trash } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface DiscountListActionsProps {
  discountId: string;
}

export default function DiscountListActions({
  discountId,
}: DiscountListActionsProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const router = useRouter();

  const handleDelete = async () => {
    try {
      const response = await fetch(`/api/discounts/${discountId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete discount");
      }

      // Refresh the page
      router.refresh();
    } catch (error) {
      console.error("Error deleting discount:", error);
    }
  };

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
            <span className="sr-only">Open menu</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem asChild>
            <Link
              href={`/admin/discounts/${discountId}`}
              className="flex items-center"
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit
            </Link>
          </DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            className="text-red-600 focus:text-red-600"
            onClick={() => setShowDeleteDialog(true)}
          >
            <Trash className="mr-2 h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              discount.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

File: ./src/components/admin/order-list-actions.tsx
// src/components/admin/order-list-actions.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import {
  MoreHorizontal,
  Edit,
  ExternalLink,
  FileText,
  AlertTriangle,
} from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useToast } from "@/components/ui/use-toast";
import { FeatureGuard } from "@/components/authorization/feature-guard";
import { Feature } from "@/lib/feature-authorization";

interface OrderListActionsProps {
  orderId: string;
  hasInvoice?: boolean;
}

export default function OrderListActions({
  orderId,
  hasInvoice = false,
}: OrderListActionsProps) {
  const [showCancelDialog, setShowCancelDialog] = useState(false);
  const [isCancelling, setIsCancelling] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleCancelOrder = async () => {
    try {
      setIsCancelling(true);

      const response = await fetch(`/api/orders/${orderId}`, {
        method: "DELETE", // This is actually cancellation, not deletion
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.error || "Failed to cancel order");
      }

      // Show success toast
      toast({
        title: "Order cancelled",
        description: "The order has been successfully cancelled",
      });

      // Close the dialog
      setShowCancelDialog(false);

      // Refresh the page
      router.refresh();
    } catch (error) {
      console.error("Error cancelling order:", error);

      // Show error toast
      toast({
        title: "Error",
        description:
          error instanceof Error ? error.message : "Failed to cancel order",
        variant: "destructive",
      });
    } finally {
      setIsCancelling(false);
    }
  };

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
            <span className="sr-only">Open menu</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem asChild>
            <Link
              href={`/admin/orders/${orderId}`}
              className="flex items-center"
            >
              <Edit className="mr-2 h-4 w-4" />
              View Details
            </Link>
          </DropdownMenuItem>

          <FeatureGuard feature={Feature.INVOICE_GENERATION}>
            <DropdownMenuItem asChild>
              <Link
                href={
                  hasInvoice
                    ? `/api/orders/${orderId}/invoice`
                    : `/api/orders/${orderId}/invoice/generate`
                }
                className="flex items-center"
              >
                <FileText className="mr-2 h-4 w-4" />
                {hasInvoice ? "View Invoice" : "Generate Invoice"}
              </Link>
            </DropdownMenuItem>
          </FeatureGuard>

          <DropdownMenuSeparator />

          <DropdownMenuItem
            className="text-amber-600 focus:text-amber-600 cursor-pointer"
            onClick={() => setShowCancelDialog(true)}
          >
            <AlertTriangle className="mr-2 h-4 w-4" />
            Cancel Order
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <AlertDialog open={showCancelDialog} onOpenChange={setShowCancelDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Cancel Order?</AlertDialogTitle>
            <AlertDialogDescription>
              This will cancel the order and restore any inventory. This cannot
              be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isCancelling}>
              No, Keep Order
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleCancelOrder}
              className="bg-red-600 hover:bg-red-700"
              disabled={isCancelling}
            >
              {isCancelling ? "Cancelling..." : "Yes, Cancel Order"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

File: ./src/components/admin/header.tsx
// src/components/admin/header.tsx
"use client";

import { useState } from "react";
import { useSession, signOut } from "next-auth/react";
import Link from "next/link";
import { Menu, X, Bell, User, LogOut } from "lucide-react";
import { Button } from "@/components/ui/button";

export default function AdminHeader() {
  const { data: session } = useSession();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  return (
    <header className="bg-white shadow-sm">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          <div className="flex">
            <div className="flex-shrink-0 flex items-center md:hidden">
              <button
                type="button"
                className="inline-flex items-center justify-center p-2 rounded-md text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500"
                onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
              >
                <span className="sr-only">Open main menu</span>
                {mobileMenuOpen ? (
                  <X className="block h-6 w-6" aria-hidden="true" />
                ) : (
                  <Menu className="block h-6 w-6" aria-hidden="true" />
                )}
              </button>
            </div>
            <div className="hidden md:ml-6 md:flex md:space-x-8">
              <Link
                href="/admin"
                className="border-transparent text-gray-900 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
              >
                {session?.user?.shopName || "Dashboard"}
              </Link>
              <Link
                href="/"
                className="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
              >
                View Shop
              </Link>
            </div>
          </div>
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <Button variant="outline" size="sm" className="mx-2">
                <Bell className="h-4 w-4 mr-1" />
                <span className="hidden md:inline">Notifications</span>
              </Button>
            </div>
            <div className="ml-3 relative flex items-center gap-2">
              <Button variant="ghost" size="sm" className="flex items-center ">
                <User className="h-4 w-4 mr-1" />
                <span className="text-sm text-gray-700 hover:text-red-600">
                  {session?.user?.name || "Profile"}
                </span>
              </Button>

              <Button
                variant="ghost"
                size="sm"
                className="flex items-center "
                onClick={() => signOut({ callbackUrl: "/login" })}
              >
                <LogOut className="h-4 w-4 mr-1" />
                <span className="text-sm text-gray-700 hover:text-red-600">
                  Logout
                </span>
              </Button>
            </div>
          </div>
        </div>
      </div>
    </header>
  );
}

File: ./src/components/admin/subscription-info.tsx
// src/components/admin/subscription-info.tsx
"use client";

import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { formatCurrency } from "@/lib/utils";
import {
  canViewSubscription,
  formatPlanName,
  formatSubscriptionPeriod,
} from "@/lib/permissions";
import {
  CalendarClock,
  CreditCard,
  AlertCircle,
  CheckCircle2,
} from "lucide-react";

interface SubscriptionData {
  id: string;
  planType: string;
  period: string;
  startDate: string;
  endDate: string;
  status: string;
  totalAmount: number;
  appliedDiscount: number;
  paidAmount: number;
  remainingAmount: number;
  daysRemaining: number;
  isActive: boolean;
}

interface SubscriptionInfoProps {
  subscription: SubscriptionData | null;
  loading?: boolean;
}

export function SubscriptionInfo({
  subscription,
  loading = false,
}: SubscriptionInfoProps) {
  const { data: session } = useSession();

  // Check if user can view subscription
  if (!canViewSubscription(session?.user)) {
    return null;
  }

  if (loading) {
    return (
      <Card className="border-l-4 border-l-blue-500 mb-6">
        <CardContent className="pt-6">
          <div className="h-20 flex items-center justify-center">
            <p className="text-sm text-gray-500">
              Loading subscription information...
            </p>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (!subscription) {
    return (
      <Card className="border-l-4 border-l-yellow-500 mb-6">
        <CardHeader>
          <CardTitle className="text-lg flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-yellow-500" />
            No Active Subscription
          </CardTitle>
          <CardDescription>
            Your shop doesn't have an active subscription plan
          </CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-gray-600">
            Contact platform admin to set up your subscription and unlock all
            features.
          </p>
        </CardContent>
        <CardFooter>
          <Button variant="outline" size="sm">
            Contact Support
          </Button>
        </CardFooter>
      </Card>
    );
  }

  // Get border color based on status
  const getBorderColor = () => {
    switch (subscription.status) {
      case "ACTIVE":
        return "border-l-green-500";
      case "PENDING":
        return "border-l-yellow-500";
      case "EXPIRED":
      case "CANCELED":
        return "border-l-red-500";
      case "TRIAL":
        return "border-l-blue-500";
      default:
        return "border-l-gray-500";
    }
  };

  return (
    <Card className={`border-l-4 ${getBorderColor()} mb-6`}>
      <CardHeader className="pb-2">
        <div className="flex justify-between items-start">
          <div>
            <CardTitle className="text-lg flex items-center gap-2">
              {subscription.isActive ? (
                <CheckCircle2 className="h-5 w-5 text-green-500" />
              ) : (
                <AlertCircle className="h-5 w-5 text-red-500" />
              )}
              {formatPlanName(subscription.planType)}
            </CardTitle>
            <CardDescription>
              {formatSubscriptionPeriod(subscription.period)} subscription
              {!subscription.isActive &&
                ` (${subscription.status.toLowerCase()})`}
            </CardDescription>
          </div>
          <div className="text-right">
            <p className="text-lg font-bold">
              {formatCurrency(subscription.totalAmount)}
            </p>
            {subscription.appliedDiscount > 0 && (
              <p className="text-xs text-green-600">
                {subscription.appliedDiscount}% discount applied
              </p>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
          <div className="space-y-2">
            <div className="flex items-center gap-2 text-sm">
              <CalendarClock className="h-4 w-4 text-gray-500" />
              <span className="text-gray-600">
                Valid from{" "}
                {new Date(subscription.startDate).toLocaleDateString()} to{" "}
                {new Date(subscription.endDate).toLocaleDateString()}
              </span>
            </div>
            <div className="flex items-center gap-2 text-sm">
              <CalendarClock className="h-4 w-4 text-gray-500" />
              <span className="text-gray-600">
                {subscription.daysRemaining} days remaining
              </span>
            </div>
          </div>
          <div className="space-y-2">
            <div className="flex items-center gap-2 text-sm">
              <CreditCard className="h-4 w-4 text-gray-500" />
              <span className="text-gray-600">
                Paid: {formatCurrency(subscription.paidAmount)}
              </span>
            </div>
            {subscription.remainingAmount > 0 && (
              <div className="flex items-center gap-2 text-sm">
                <CreditCard className="h-4 w-4 text-gray-500" />
                <span className="text-red-600">
                  Remaining: {formatCurrency(subscription.remainingAmount)}
                </span>
              </div>
            )}
          </div>
        </div>
      </CardContent>
      {subscription.remainingAmount > 0 && (
        <CardFooter className="pt-0">
          <Button size="sm">Make Payment</Button>
        </CardFooter>
      )}
    </Card>
  );
}

File: ./src/components/admin/pagination.tsx
// src/components/admin/pagination.tsx
"use client";

import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
} from "lucide-react";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
}

export default function Pagination({
  currentPage,
  totalPages,
  totalItems,
}: PaginationProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const navigateToPage = (page: number) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", page.toString());
    router.push(`${pathname}?${params.toString()}`);
  };

  return (
    <div className="flex justify-between items-center mt-4">
      <div className="text-sm text-gray-500">
        Showing {totalItems > 0 ? (currentPage - 1) * 10 + 1 : 0} to{" "}
        {Math.min(currentPage * 10, totalItems)} of {totalItems} items
      </div>
      <div className="flex space-x-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => navigateToPage(1)}
          disabled={currentPage <= 1}
        >
          <ChevronsLeft className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => navigateToPage(currentPage - 1)}
          disabled={currentPage <= 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>

        <span className="px-3 py-1 text-sm">
          Page {currentPage} of {totalPages || 1}
        </span>

        <Button
          variant="outline"
          size="sm"
          onClick={() => navigateToPage(currentPage + 1)}
          disabled={currentPage >= totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => navigateToPage(totalPages)}
          disabled={currentPage >= totalPages}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

File: ./src/components/admin/product-filters.tsx
// src/components/admin/product-filters.tsx - Add lowStockThreshold prop
"use client";

import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { Search, X } from "lucide-react";

interface Category {
  id: string;
  name: string;
}

interface ProductFiltersProps {
  categories: Category[];
  currentFilters: {
    search?: string;
    category?: string;
    inStock?: string;
    lowStock?: string;
    page?: string;
    perPage?: string;
    sort?: string;
    order?: string;
  };
  lowStockThreshold: number;
}

export default function ProductFilters({
  categories,
  currentFilters,
  lowStockThreshold,
}: ProductFiltersProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  // Local state for filters to enable live updates
  const [searchTerm, setSearchTerm] = useState(currentFilters.search || "");
  const [selectedCategory, setSelectedCategory] = useState(
    currentFilters.category || "all"
  );
  const [isInStock, setIsInStock] = useState(currentFilters.inStock === "true");
  const [isLowStock, setIsLowStock] = useState(
    currentFilters.lowStock === "true"
  );

  // Update URL when filters change
  const updateFilters = () => {
    const params = new URLSearchParams(searchParams.toString());

    // Reset to page 1 when filters change
    params.set("page", "1");

    // Update search parameter
    if (searchTerm) {
      params.set("search", searchTerm);
    } else {
      params.delete("search");
    }

    // Update category parameter
    if (selectedCategory && selectedCategory !== "all") {
      params.set("category", selectedCategory);
    } else {
      params.delete("category");
    }

    // Update stock filters
    if (isInStock) {
      params.set("inStock", "true");
    } else {
      params.delete("inStock");
    }

    if (isLowStock) {
      params.set("lowStock", "true");
    } else {
      params.delete("lowStock");
    }

    router.push(`${pathname}?${params.toString()}`);
  };

  // Live search with debounce
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      updateFilters();
    }, 500); // 500ms debounce

    return () => clearTimeout(timeoutId);
  }, [searchTerm, selectedCategory, isInStock, isLowStock]);

  // Clear all filters
  const clearFilters = () => {
    setSearchTerm("");
    setSelectedCategory("all");
    setIsInStock(false);
    setIsLowStock(false);

    router.push(pathname);
  };

  return (
    <div className="bg-gray-50 p-4 rounded-lg shadow-sm mb-6 space-y-4 border border-gray-200">
      <div className="flex flex-col md:flex-row gap-4">
        <div className="flex-1">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <Input
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              placeholder="Search products..."
              className="pl-10 max-w-sm text-gray-800"
            />
            {searchTerm && (
              <button
                onClick={() => setSearchTerm("")}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
        </div>

        <div className="flex gap-4 flex-wrap items-center">
          <div className="w-48">
            <Select
              value={selectedCategory}
              onValueChange={setSelectedCategory}
            >
              <SelectTrigger className="text-gray-800">
                <SelectValue placeholder="All Categories" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Categories</SelectItem>
                {categories.map((category) => (
                  <SelectItem key={category.id} value={category.id}>
                    {category.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex items-center gap-2">
            <Checkbox
              id="inStock"
              checked={isInStock}
              onCheckedChange={(checked) => setIsInStock(checked === true)}
            />
            <Label htmlFor="inStock" className="text-gray-800">
              In Stock
            </Label>
          </div>

          <div className="flex items-center gap-2">
            <Checkbox
              id="lowStock"
              checked={isLowStock}
              onCheckedChange={(checked) => setIsLowStock(checked === true)}
            />
            <Label htmlFor="lowStock" className="text-gray-800">
              Low Stock (≤{lowStockThreshold})
            </Label>
          </div>

          {(searchTerm ||
            selectedCategory !== "all" ||
            isInStock ||
            isLowStock) && (
            <Button
              variant="outline"
              size="sm"
              onClick={clearFilters}
              className="text-gray-700"
            >
              <X className="h-4 w-4 mr-2" />
              Clear Filters
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

File: ./src/components/admin/category-form.tsx
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { useToast } from "@/components/ui/use-toast";
import { slugify } from "@/lib/utils";
import { AlertCircle, FolderTree } from "lucide-react";
import { s3ImageService } from "@/lib/services/s3-image.service";

interface Category {
  id: string;
  name: string;
  slug: string;
  description?: string;
  image?: string;
  parentId: string | null;
  level: number;
  createdAt: string;
  updatedAt: string;
  _count?: {
    products: number;
    children: number;
  };
  totalProducts?: number;
}

interface CategoryFormProps {
  isOpen: boolean;
  onClose: (refreshData?: boolean) => void;
  category: Category | null;
  categories: Category[];
}

// Schema validation
const categorySchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  slug: z.string().min(2, "Slug must be at least 2 characters").optional(),
  description: z.string().optional(),
  image: z.string().optional(),
  parentId: z.string().nullable().optional(),
});

type CategoryFormValues = z.infer<typeof categorySchema>;

export default function CategoryForm({
  isOpen,
  onClose,
  category,
  categories,
}: CategoryFormProps) {
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [isImageLoading, setIsImageLoading] = useState(false);

  // Get default values for the form
  const defaultValues: CategoryFormValues = {
    name: category?.name || "",
    slug: category?.slug || "",
    description: category?.description || "",
    image: category?.image || "",
    parentId: category?.parentId || null,
  };

  // Initialize form
  const form = useForm<CategoryFormValues>({
    resolver: zodResolver(categorySchema),
    defaultValues,
  });

  // Watch name field to auto-generate slug
  const watchedName = form.watch("name");

  // Load image preview from S3 if image is a key
  useEffect(() => {
    const loadImagePreview = async () => {
      const imageValue = category?.image || "";

      // If no image or it's already a data URL, set preview directly
      if (!imageValue || imageValue.startsWith("data:")) {
        setImagePreview(imageValue);
        return;
      }

      // Check if it's an S3 key or URL
      try {
        setIsImageLoading(true);
        if (s3ImageService.isS3Key(imageValue)) {
          // It's an S3 key, get the URL
          const url = await s3ImageService.getImageUrl(imageValue);
          setImagePreview(url);
        } else if (imageValue.startsWith("http")) {
          // It's already a URL, use it directly
          setImagePreview(imageValue);
        }
      } catch (error) {
        console.error("Error loading image preview:", error);
        setImagePreview(null);
      } finally {
        setIsImageLoading(false);
      }
    };

    loadImagePreview();
  }, [category]);

  // Always auto-generate slug when name changes
  useEffect(() => {
    if (!watchedName) return;
    const generatedSlug = slugify(watchedName);

    // Always update the slug based on the name
    form.setValue("slug", generatedSlug, { shouldValidate: true });
  }, [watchedName, form]);

  // Handle image upload
  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = (event) => {
        if (event.target?.result) {
          const imageDataUrl = event.target.result as string;
          setImagePreview(imageDataUrl);
          // Just store the data URL for now - will convert to S3 on form submit
          form.setValue("image", imageDataUrl);
        }
      };
      reader.readAsDataURL(file);
    }
  };

  // Handle form submission
  const onSubmit = async (values: CategoryFormValues) => {
    setIsSubmitting(true);
    setError(null);
    try {
      // Always ensure slug is generated from name
      values.slug = slugify(values.name);

      // Handle image upload to S3 if it's a data URL
      if (values.image && values.image.startsWith("data:")) {
        try {
          const uploadResult = await s3ImageService.uploadImage(
            values.image,
            `${values.slug}-image.jpg`,
            "categories"
          );

          // Replace data URL with S3 key
          values.image = uploadResult.key;
        } catch (uploadError) {
          console.error("Error uploading image to S3:", uploadError);
          toast({
            title: "Image Upload Failed",
            description:
              "Your category was saved but the image couldn't be uploaded.",
            variant: "destructive",
          });
          // Continue without image if upload fails
          values.image = "";
        }
      }

      const url = category
        ? `/api/categories/${category.id}`
        : "/api/categories";
      const method = category ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(
          data.error || `Failed to ${category ? "update" : "create"} category`
        );
      }

      toast({
        title: "Success",
        description: `Category ${
          category ? "updated" : "created"
        } successfully`,
      });
      onClose(true);
    } catch (error: any) {
      console.error("Error in form submission:", error);
      setError(error.message || "Something went wrong");
    } finally {
      setIsSubmitting(false);
    }
  };

  // Remove image
  const removeImage = () => {
    setImagePreview(null);
    form.setValue("image", "");
  };

  // Organize categories in hierarchical structure for the dropdown
  const organizeCategoriesForDropdown = () => {
    // Filter out the current category and categories with deep nesting
    const availableCategories = categories.filter(
      (c) => (!category || c.id !== category.id) && c.level < 2
    );

    // Group categories by parent ID
    const groupedByParent: Record<string | "root", Category[]> = { root: [] };

    // First pass: group all categories by their parent
    availableCategories.forEach((cat) => {
      if (!cat.parentId) {
        // Root categories
        groupedByParent["root"].push(cat);
      } else {
        // Child categories
        if (!groupedByParent[cat.parentId]) {
          groupedByParent[cat.parentId] = [];
        }
        groupedByParent[cat.parentId].push(cat);
      }
    });

    // Sort root categories by name
    groupedByParent["root"].sort((a, b) => a.name.localeCompare(b.name));

    // Sort children under each parent by name
    Object.keys(groupedByParent).forEach((parentId) => {
      if (parentId !== "root") {
        groupedByParent[parentId].sort((a, b) => a.name.localeCompare(b.name));
      }
    });

    // Create an array of objects for the dropdown with proper structure
    const result: Array<{
      id: string;
      name: string;
      level: number;
      hasChildren: boolean;
      children?: Category[];
    }> = [];

    // Add root categories first
    groupedByParent["root"].forEach((rootCat) => {
      const hasChildren = !!groupedByParent[rootCat.id]?.length;
      result.push({
        id: rootCat.id,
        name: rootCat.name,
        level: 0,
        hasChildren,
        children: hasChildren ? groupedByParent[rootCat.id] : undefined,
      });
    });

    return result;
  };

  const hierarchicalCategories = organizeCategoriesForDropdown();

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="sm:max-w-[550px]">
        <DialogHeader>
          <DialogTitle>
            <div className="flex items-center gap-2">
              <FolderTree className="h-5 w-5" />
              {category ? "Edit Category" : "Create New Category"}
            </div>
          </DialogTitle>
          <DialogDescription>
            {category
              ? "Update your category details below"
              : "Fill in the information below to create a new category"}
          </DialogDescription>
        </DialogHeader>
        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-5">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="text-gray-700">Name*</FormLabel>
                  <FormControl>
                    <Input
                      placeholder="e.g., Electronics, Clothing, Books"
                      className="border-2 text-gray-700"
                      style={{ borderColor: "#bdc3c7" }}
                      {...field}
                    />
                  </FormControl>
                  <FormDescription>
                    A clear, descriptive name for your category
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Slug field is removed from UI but still managed in the form */}

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="text-gray-700">Description</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="Describe this category for your customers"
                      className="min-h-[100px] border-2 text-gray-700"
                      style={{ borderColor: "#bdc3c7" }}
                      {...field}
                    />
                  </FormControl>
                  <FormDescription>
                    Optional description of what products belong in this
                    category
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="image"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="text-gray-700">
                    Category Image
                  </FormLabel>
                  <div className="space-y-2">
                    <div className="flex items-center justify-center w-full">
                      <label
                        htmlFor="image-upload"
                        className="flex flex-col items-center justify-center w-full h-64 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100 transition-colors"
                      >
                        {isImageLoading ? (
                          <div className="flex flex-col items-center justify-center">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-800"></div>
                            <p className="mt-2 text-sm text-gray-600">
                              Loading image...
                            </p>
                          </div>
                        ) : imagePreview ? (
                          <div className="relative w-full h-full">
                            <img
                              src={imagePreview}
                              alt="Category preview"
                              className="w-full h-full object-contain p-2"
                            />
                            <div className="absolute inset-0 bg-black bg-opacity-50 opacity-0 hover:opacity-100 flex items-center justify-center transition-opacity">
                              <span className="text-white text-sm font-medium">
                                Click to change image
                              </span>
                            </div>
                          </div>
                        ) : (
                          <div className="flex flex-col items-center justify-center pt-5 pb-6">
                            <svg
                              className="w-10 h-10 mb-3 text-gray-400"
                              fill="none"
                              stroke="currentColor"
                              viewBox="0 0 24 24"
                              xmlns="http://www.w3.org/2000/svg"
                            >
                              <path
                                strokeLinecap="round"
                                strokeLinejoin="round"
                                strokeWidth="2"
                                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                              ></path>
                            </svg>
                            <p className="mb-2 text-sm text-gray-600">
                              <span className="font-semibold">
                                Click to upload
                              </span>{" "}
                              or drag and drop
                            </p>
                            <p className="text-xs text-gray-500">
                              PNG, JPG, GIF up to 10MB
                            </p>
                          </div>
                        )}
                        <input
                          id="image-upload"
                          name="image-upload"
                          type="file"
                          accept="image/*"
                          className="hidden"
                          onChange={handleImageUpload}
                        />
                      </label>
                    </div>
                    {imagePreview && (
                      <Button
                        type="button"
                        variant="outline"
                        className="text-red-500 border-red-200 hover:text-red-600 hover:bg-red-50 w-full"
                        onClick={removeImage}
                      >
                        Remove Image
                      </Button>
                    )}
                  </div>
                  <FormDescription>
                    Upload an image to represent this category (optional)
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="parentId"
              render={({ field }) => (
                <FormItem>
                  <FormLabel className="text-gray-700">
                    Parent Category
                  </FormLabel>
                  <Select
                    value={field.value || "null"}
                    onValueChange={(value) => {
                      form.setValue(
                        "parentId",
                        value === "null" ? null : value
                      );
                    }}
                  >
                    <FormControl>
                      <SelectTrigger
                        className="border-2 text-gray-700"
                        style={{ borderColor: "#bdc3c7" }}
                      >
                        <SelectValue placeholder="Select a parent category (optional)" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="null">None (Root Category)</SelectItem>
                      {/* Root categories and their children */}
                      {hierarchicalCategories.map((rootCategory) => (
                        <React.Fragment key={rootCategory.id}>
                          {/* Root category */}
                          <SelectItem value={rootCategory.id}>
                            {rootCategory.name}
                          </SelectItem>
                          {/* Child categories */}
                          {rootCategory.children?.map((childCategory) => (
                            <SelectItem
                              key={childCategory.id}
                              value={childCategory.id}
                              className="pl-7"
                            >
                              └─ {childCategory.name}
                            </SelectItem>
                          ))}
                        </React.Fragment>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormDescription>
                    {category
                      ? "You can move this category under a different parent"
                      : "Leave empty to create a top-level category"}
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />
            <DialogFooter className="mt-6">
              <Button
                type="button"
                variant="outline"
                onClick={() => onClose()}
                className="border-2"
                style={{ borderColor: "#bdc3c7", color: "#2c3e50" }}
              >
                Cancel
              </Button>
              <Button
                type="submit"
                style={{ backgroundColor: "#16a085", color: "white" }}
                disabled={isSubmitting || isImageLoading}
              >
                {isSubmitting
                  ? "Saving..."
                  : category
                  ? "Update Category"
                  : "Create Category"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

File: ./src/components/admin/order-status-update-form.tsx
// src/components/admin/order-status-update-form.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import * as z from "zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useToast } from "@/components/ui/use-toast";
import { Loader2 } from "lucide-react";

// Order status options
const orderStatuses = [
  { value: "PENDING", label: "Pending" },
  { value: "PROCESSING", label: "Processing" },
  { value: "SHIPPED", label: "Shipped" },
  { value: "DELIVERED", label: "Delivered" },
  { value: "CANCELLED", label: "Cancelled" },
  { value: "REFUNDED", label: "Refunded" },
];

// Payment status options
const paymentStatuses = [
  { value: "PENDING", label: "Pending" },
  { value: "PAID", label: "Paid" },
  { value: "FAILED", label: "Failed" },
  { value: "REFUNDED", label: "Refunded" },
  { value: "PARTIALLY_REFUNDED", label: "Partially Refunded" },
];

// Shipping status options
const shippingStatuses = [
  { value: "PENDING", label: "Pending" },
  { value: "PROCESSING", label: "Processing" },
  { value: "SHIPPED", label: "Shipped" },
  { value: "DELIVERED", label: "Delivered" },
  { value: "RETURNED", label: "Returned" },
];

// Form schema
const formSchema = z.object({
  status: z.string().min(1, "Order status is required"),
  paymentStatus: z.string().min(1, "Payment status is required"),
  shippingStatus: z.string().min(1, "Shipping status is required"),
  notes: z.string().optional(),
});

type FormValues = z.infer<typeof formSchema>;

interface OrderStatusUpdateFormProps {
  orderId: string;
  currentStatus: string;
  currentPaymentStatus: string;
  currentShippingStatus: string;
}

export default function OrderStatusUpdateForm({
  orderId,
  currentStatus,
  currentPaymentStatus,
  currentShippingStatus,
}: OrderStatusUpdateFormProps) {
  const router = useRouter();
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Create form
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      status: currentStatus,
      paymentStatus: currentPaymentStatus,
      shippingStatus: currentShippingStatus || "PENDING",
      notes: "",
    },
  });

  // Handle form submission
  const onSubmit = async (values: FormValues) => {
    setIsSubmitting(true);

    try {
      const response = await fetch(`/api/orders/${orderId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Failed to update order status");
      }

      // Success message
      toast({
        title: "Order Updated",
        description: "The order status has been updated successfully.",
      });

      // Refresh the page to show updated data
      router.refresh();
    } catch (error) {
      console.error("Error updating order:", error);
      toast({
        title: "Error",
        description:
          error instanceof Error ? error.message : "An error occurred",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <FormField
            control={form.control}
            name="status"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-gray-700">Order Status</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                  disabled={isSubmitting}
                >
                  <FormControl>
                    <SelectTrigger className="w-full border-gray-300 text-gray-800">
                      <SelectValue placeholder="Select status" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {orderStatuses.map((status) => (
                      <SelectItem key={status.value} value={status.value}>
                        {status.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="paymentStatus"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-gray-700">Payment Status</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                  disabled={isSubmitting}
                >
                  <FormControl>
                    <SelectTrigger className="w-full border-gray-300 text-gray-800">
                      <SelectValue placeholder="Select payment status" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {paymentStatuses.map((status) => (
                      <SelectItem key={status.value} value={status.value}>
                        {status.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="shippingStatus"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="text-gray-700">Shipping Status</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                  disabled={isSubmitting}
                >
                  <FormControl>
                    <SelectTrigger className="w-full border-gray-300 text-gray-800">
                      <SelectValue placeholder="Select shipping status" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {shippingStatuses.map((status) => (
                      <SelectItem key={status.value} value={status.value}>
                        {status.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <FormField
          control={form.control}
          name="notes"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="text-gray-700">Notes (Optional)</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Add a note about this status change (visible to admin only)"
                  className="resize-none h-20 border-gray-300 text-gray-800"
                  {...field}
                  disabled={isSubmitting}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex justify-end">
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Updating...
              </>
            ) : (
              "Update Order Status"
            )}
          </Button>
        </div>
      </form>
    </Form>
  );
}

File: ./src/components/admin/product-order-table.tsx
// src/components/admin/product-order-table.tsx
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { formatCurrency, formatDate } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import OrderStatusBadge from "@/components/admin/order-status-badge";
import { Loader2, ExternalLink } from "lucide-react";

interface OrderItem {
  id: string;
  orderId: string;
  quantity: number;
  unitPrice: number;
  total: number;
  order: {
    id: string;
    orderNumber: string;
    status: string;
    createdAt: string;
    user: {
      name: string;
      email: string;
    };
  };
}

interface ProductOrderTableProps {
  productId: string;
  limit?: number;
  showViewAllLink?: boolean;
}

export default function ProductOrderTable({
  productId,
  limit = 5,
  showViewAllLink = true,
}: ProductOrderTableProps) {
  const router = useRouter();
  const [orders, setOrders] = useState<OrderItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState("");

  useEffect(() => {
    async function fetchOrders() {
      try {
        setIsLoading(true);
        setError("");

        const response = await fetch(`/api/products/${productId}/orders`);

        if (!response.ok) {
          throw new Error("Failed to fetch orders");
        }

        const data = await response.json();
        setOrders(data);
      } catch (err) {
        console.error("Error fetching product orders:", err);
        setError("Could not load order history");
      } finally {
        setIsLoading(false);
      }
    }

    fetchOrders();
  }, [productId]);

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-32">
        <Loader2 className="h-6 w-6 text-indigo-600 animate-spin" />
      </div>
    );
  }

  if (error) {
    return <div className="text-center p-4 text-red-500">{error}</div>;
  }

  if (orders.length === 0) {
    return (
      <div className="text-center p-8 text-gray-500">
        No orders found for this product
      </div>
    );
  }

  // Limit the number of orders to display
  const displayOrders = limit ? orders.slice(0, limit) : orders;

  return (
    <div className="space-y-4">
      <Card className="shadow-sm">
        <CardHeader className="bg-gray-50 border-b">
          <CardTitle className="text-lg text-gray-800">Order History</CardTitle>
          <CardDescription>
            Recent orders containing this product
          </CardDescription>
        </CardHeader>
        <CardContent className="p-0">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Order #</TableHead>
                <TableHead>Date</TableHead>
                <TableHead>Customer</TableHead>
                <TableHead>Quantity</TableHead>
                <TableHead>Price</TableHead>
                <TableHead>Status</TableHead>
                <TableHead className="text-right">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {displayOrders.map((item) => (
                <TableRow key={item.id}>
                  <TableCell className="font-medium">
                    <Link
                      href={`/admin/orders/${item.order.id}`}
                      className="text-indigo-600 hover:underline"
                    >
                      {item.order.orderNumber}
                    </Link>
                  </TableCell>
                  <TableCell>{formatDate(item.order.createdAt)}</TableCell>
                  <TableCell>
                    {item.order.user.name || item.order.user.email || "Guest"}
                  </TableCell>
                  <TableCell>{item.quantity}</TableCell>
                  <TableCell>{formatCurrency(item.total)}</TableCell>
                  <TableCell>
                    <OrderStatusBadge status={item.order.status} />
                  </TableCell>
                  <TableCell className="text-right">
                    <Button variant="ghost" size="sm" asChild>
                      <Link href={`/admin/orders/${item.order.id}`}>
                        <ExternalLink className="h-4 w-4 mr-2" />
                        View
                      </Link>
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
        {showViewAllLink && orders.length > limit && (
          <CardFooter className="bg-gray-50 border-t p-4">
            <Button
              variant="outline"
              onClick={() => router.push(`/admin/orders?product=${productId}`)}
              className="ml-auto"
            >
              View All Orders ({orders.length})
            </Button>
          </CardFooter>
        )}
      </Card>
    </div>
  );
}

File: ./src/components/admin/discount-code-list-actions.tsx
// src/components/admin/discount-code-list-actions.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { MoreHorizontal, Edit, Trash, Copy } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useToast } from "@/components/ui/use-toast";

interface DiscountCodeListActionsProps {
  discountCodeId: string;
}

export default function DiscountCodeListActions({
  discountCodeId,
}: DiscountCodeListActionsProps) {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleDelete = async () => {
    try {
      const response = await fetch(`/api/discount-codes/${discountCodeId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete discount code");
      }

      // Refresh the page
      router.refresh();
    } catch (error) {
      console.error("Error deleting discount code:", error);
      toast({
        title: "Error",
        description: "Failed to delete discount code",
        variant: "destructive",
      });
    }
  };

  const handleCopyCode = async () => {
    try {
      // Get the discount code
      const response = await fetch(`/api/discount-codes/${discountCodeId}`);
      if (!response.ok) {
        throw new Error("Failed to fetch discount code");
      }

      const data = await response.json();

      // Copy the code to clipboard
      await navigator.clipboard.writeText(data.code);

      toast({
        title: "Code Copied",
        description: `"${data.code}" copied to clipboard.`,
      });
    } catch (error) {
      console.error("Error copying discount code:", error);
      toast({
        title: "Error",
        description: "Failed to copy code to clipboard",
        variant: "destructive",
      });
    }
  };

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
            <span className="sr-only">Open menu</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem asChild>
            <Link
              href={`/admin/discount-codes/${discountCodeId}`}
              className="flex items-center"
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit
            </Link>
          </DropdownMenuItem>
          <DropdownMenuItem
            className="flex items-center cursor-pointer"
            onClick={handleCopyCode}
          >
            <Copy className="mr-2 h-4 w-4" />
            Copy Code
          </DropdownMenuItem>
          <DropdownMenuSeparator />
          <DropdownMenuItem
            className="text-red-600 focus:text-red-600 cursor-pointer"
            onClick={() => setShowDeleteDialog(true)}
          >
            <Trash className="mr-2 h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              discount code.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

File: ./src/components/admin/order-history-tab.tsx

File: ./src/components/admin/sidebar.tsx
// src/components/admin/sidebar.tsx
"use client";

import { usePathname } from "next/navigation";
import Link from "next/link";
import { useSession } from "next-auth/react";
import {
  Home,
  Package,
  List,
  ShoppingCart,
  Users,
  Settings,
  BarChart,
  Bell,
  Tag,
  Ticket,
} from "lucide-react";
import { cn } from "@/lib/utils";

export default function AdminSidebar() {
  const pathname = usePathname();
  const { data: session } = useSession();
  const isPremium = session?.user?.planType === "PREMIUM";
  const isAdvanced = session?.user?.planType === "ADVANCED" || isPremium;

  const navigation = [
    { name: "Dashboard", href: "/admin", icon: Home },
    { name: "Products", href: "/admin/products", icon: Package },
    { name: "Categories", href: "/admin/categories", icon: List },
    { name: "Discounts", href: "/admin/discounts", icon: Tag },
    { name: "Discount Codes", href: "/admin/discount-codes", icon: Ticket },
    { name: "Orders", href: "/admin/orders", icon: ShoppingCart },
    { name: "Customers", href: "/admin/customers", icon: Users },
    { name: "Settings", href: "/admin/settings", icon: Settings },
    // Advanced & Premium features
    {
      name: "Analytics",
      href: "/admin/analytics",
      icon: BarChart,
      requiredPlan: "ADVANCED",
    },
    {
      name: "Notifications",
      href: "/admin/notifications",
      icon: Bell,
      requiredPlan: "ADVANCED",
    },
  ];

  return (
    <div className="hidden md:flex md:flex-shrink-0">
      <div className="flex flex-col w-64">
        <div className="flex flex-col h-0 flex-1 bg-gray-800">
          <div className="flex-1 flex flex-col pt-5 pb-4 overflow-y-auto">
            <div className="flex items-center flex-shrink-0 px-4">
              <span className="text-xl font-bold text-gray-200">
                {session?.user?.shopName || "Shop Admin"}
              </span>
            </div>
            <nav className="mt-5 flex-1 px-2 space-y-1">
              {navigation.map((item) => {
                // Skip if this feature requires a higher plan than the user has
                if (item.requiredPlan === "ADVANCED" && !isAdvanced)
                  return null;
                if (item.requiredPlan === "PREMIUM" && !isPremium) return null;

                return (
                  <Link
                    key={item.name}
                    href={item.href}
                    className={cn(
                      pathname === item.href
                        ? "bg-gray-900 text-white"
                        : "text-gray-300 hover:bg-gray-700 hover:text-white",
                      "group flex items-center px-2 py-2 text-sm font-medium rounded-md"
                    )}
                  >
                    <item.icon
                      className={cn(
                        pathname === item.href
                          ? "text-gray-300"
                          : "text-gray-400 group-hover:text-gray-300",
                        "mr-3 flex-shrink-0 h-6 w-6"
                      )}
                      aria-hidden="true"
                    />
                    {item.name}
                  </Link>
                );
              })}
            </nav>
          </div>
        </div>
      </div>
    </div>
  );
}

File: ./src/components/admin/product-form.tsx
// src/components/admin/product-form.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import { Form } from "@/components/ui/form";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { AlertCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { slugify } from "@/lib/utils";

// Import form types
import {
  ProductFormProps,
  ProductFormValues,
  productSchema,
} from "./product-form-types";

// Import tab components
import BasicInfoTab from "./product-tabs/basic-info-tab";
import ImagesTab from "./product-tabs/images-tab";
import PricingTab from "./product-tabs/pricing-tab";
import CategoriesTab from "./product-tabs/categories-tab";
import VariantsTab from "./product-tabs/variants-tab";
import CustomFieldsTab from "./product-tabs/custom-fields-tab";

export default function ProductForm({
  product,
  categories,
  customFields = [],
  shopId,
  isEditing = false,
}: ProductFormProps) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState("basic");
  const [formState, setFormState] = useState<ProductFormValues | null>(null);

  // Transform custom field values from the product data format to form format
  const transformCustomFieldsForForm = () => {
    if (!product || !product.customFields) return [];

    return product.customFields.map((cf: any) => ({
      id: cf.id,
      customFieldId: cf.customFieldId,
      value: cf.value,
    }));
  };

  // Default values
  const defaultValues: ProductFormValues = product
    ? {
        name: product.name,
        description: product.description || "",
        price: product.price,
        // No compareAtPrice anymore
        cost: product.cost || null,
        barcode: product.barcode || "",
        inventory: product.inventory,
        tva: product.tva || 19,
        categoryIds: product.categories?.map((c: any) => c.id) || [],
        images: product.images || [],
        variants:
          product.variants?.map((v: any) => ({
            id: v.id,
            name: v.name,
            price: v.price,
            inventory: v.inventory,
            barcode: v.barcode || "",
            options: v.options,
          })) || [],
        expiryDate: product.expiryDate
          ? new Date(product.expiryDate).toISOString().split("T")[0]
          : null,
        customFieldValues: transformCustomFieldsForForm(),
      }
    : {
        name: "",
        description: "",
        price: 0,
        cost: null,
        inventory: 0,
        tva: 19,
        categoryIds: [],
        images: [],
        variants: [],
        expiryDate: null,
        customFieldValues: [],
      };

  // Create form with schema validation and default values
  const form = useForm<ProductFormValues>({
    resolver: zodResolver(productSchema),
    defaultValues,
  });

  // Initialize and store the form state with defaults
  useEffect(() => {
    setFormState(defaultValues);
  }, []);

  // Sync form state when switching tabs
  useEffect(() => {
    if (formState) {
      Object.keys(formState).forEach((key) => {
        form.setValue(key as any, formState[key as keyof ProductFormValues]);
      });
    }
  }, [formState]);

  // Handle tab change - preserve form state between tabs
  const handleTabChange = (value: string) => {
    // Get current values
    const currentValues = form.getValues();

    // Merge with existing state to keep all fields
    setFormState((prev) => ({
      ...(prev || defaultValues),
      ...currentValues,
    }));

    // Update the active tab
    setActiveTab(value);
  };

  // Update form state for a specific field
  const updateFormState = (field: string, value: any) => {
    setFormState((prev) => ({
      ...(prev || defaultValues),
      [field]: value,
    }));
  };

  // Handle form submission
  const onSubmit = async (values: ProductFormValues) => {
    setIsSubmitting(true);
    setSubmitError(null);

    try {
      // Auto-generate the slug
      const slug = slugify(values.name);

      const url = isEditing ? `/api/products/${product.id}` : "/api/products";
      const method = isEditing ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          ...values,
          slug,
          shopId,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to save product");
      }

      router.push(`/admin/products`);
      router.refresh();
    } catch (error: any) {
      console.error("Error saving product:", error);
      setSubmitError(
        error.message || "An error occurred while saving the product"
      );
      setIsSubmitting(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        {submitError && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{submitError}</AlertDescription>
          </Alert>
        )}
        {/* Global styles for input fields */}
        <style jsx global>{`
          input,
          textarea,
          select {
            color: #2c3e50 !important;
            background-color: white !important;
          }

          input::placeholder,
          textarea::placeholder {
            color: #bdc3c7 !important;
          }
        `}</style>
        {/* Tabs */}
        <Tabs
          value={activeTab}
          onValueChange={handleTabChange}
          className="w-full"
        >
          <TabsList className="mb-6 bg-gray-100 p-1 rounded-lg">
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "basic" ? "#2c3e50" : "transparent",
                color: activeTab === "basic" ? "white" : "#bdc3c7",
              }}
              value="basic"
            >
              Basic Info
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "images" ? "#2c3e50" : "transparent",
                color: activeTab === "images" ? "white" : "#bdc3c7",
              }}
              value="images"
            >
              Images
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "pricing" ? "#2c3e50" : "transparent",
                color: activeTab === "pricing" ? "white" : "#bdc3c7",
              }}
              value="pricing"
            >
              Pricing & Inventory
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "categories" ? "#2c3e50" : "transparent",
                color: activeTab === "categories" ? "white" : "#bdc3c7",
              }}
              value="categories"
            >
              Categories
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "variants" ? "#2c3e50" : "transparent",
                color: activeTab === "variants" ? "white" : "#bdc3c7",
              }}
              value="variants"
            >
              Variants
            </TabsTrigger>
            <TabsTrigger
              className="rounded-md"
              style={{
                backgroundColor:
                  activeTab === "custom-fields" ? "#2c3e50" : "transparent",
                color: activeTab === "custom-fields" ? "white" : "#bdc3c7",
              }}
              value="custom-fields"
            >
              Custom Fields
            </TabsTrigger>
          </TabsList>

          {/* Tab Contents */}
          <TabsContent value="basic" className="space-y-4">
            <BasicInfoTab control={form.control} />
          </TabsContent>

          <TabsContent value="images">
            <ImagesTab
              control={form.control}
              onFormStateChange={updateFormState}
            />
          </TabsContent>

          <TabsContent value="pricing" className="space-y-4">
            <PricingTab control={form.control} />
          </TabsContent>

          <TabsContent value="categories">
            <CategoriesTab
              control={form.control}
              categories={categories}
              onFormStateChange={updateFormState}
            />
          </TabsContent>

          <TabsContent value="variants">
            <VariantsTab
              control={form.control}
              onFormStateChange={updateFormState}
            />
          </TabsContent>

          <TabsContent value="custom-fields">
            <CustomFieldsTab
              control={form.control}
              customFields={customFields}
              onFormStateChange={updateFormState}
            />
          </TabsContent>
        </Tabs>
        <div className="flex justify-end gap-4">
          <Button
            type="button"
            variant="outline"
            onClick={() => router.push("/admin/products")}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          >
            Cancel
          </Button>
          <Button
            type="submit"
            disabled={isSubmitting}
            style={{
              backgroundColor: "#16a085",
              color: "white",
            }}
            className="font-semibold hover:opacity-90"
          >
            {isSubmitting
              ? "Saving..."
              : isEditing
              ? "Update Product"
              : "Create Product"}
          </Button>
        </div>
      </form>
    </Form>
  );
}

File: ./src/components/admin/order-filters.tsx
// src/components/admin/order-filters.tsx
"use client";

import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { Search, X, Calendar as CalendarIcon, Filter } from "lucide-react";
import { format } from "date-fns";

const orderStatuses = [
  { value: "all", label: "All Statuses" },
  { value: "PENDING", label: "Pending" },
  { value: "PROCESSING", label: "Processing" },
  { value: "SHIPPED", label: "Shipped" },
  { value: "DELIVERED", label: "Delivered" },
  { value: "CANCELLED", label: "Cancelled" },
  { value: "REFUNDED", label: "Refunded" },
];

const paymentStatuses = [
  { value: "all", label: "All Payment Statuses" },
  { value: "PENDING", label: "Pending" },
  { value: "PAID", label: "Paid" },
  { value: "FAILED", label: "Failed" },
  { value: "REFUNDED", label: "Refunded" },
  { value: "PARTIALLY_REFUNDED", label: "Partially Refunded" },
];

interface OrderFiltersProps {
  currentFilters: {
    search?: string;
    status?: string;
    paymentStatus?: string;
    dateFrom?: string;
    dateTo?: string;
    page?: string;
    perPage?: string;
    sort?: string;
    order?: string;
  };
}

export default function OrderFilters({ currentFilters }: OrderFiltersProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  // Local state for filters to enable live updates
  const [searchTerm, setSearchTerm] = useState(currentFilters.search || "");
  const [selectedStatus, setSelectedStatus] = useState(
    currentFilters.status || "all"
  );
  const [selectedPaymentStatus, setSelectedPaymentStatus] = useState(
    currentFilters.paymentStatus || "all"
  );
  const [dateFrom, setDateFrom] = useState<Date | undefined>(
    currentFilters.dateFrom ? new Date(currentFilters.dateFrom) : undefined
  );
  const [dateTo, setDateTo] = useState<Date | undefined>(
    currentFilters.dateTo ? new Date(currentFilters.dateTo) : undefined
  );

  // Update URL when filters change
  const updateFilters = () => {
    const params = new URLSearchParams(searchParams.toString());

    // Reset to page 1 when filters change
    params.set("page", "1");

    // Update search parameter
    if (searchTerm) {
      params.set("search", searchTerm);
    } else {
      params.delete("search");
    }

    // Update status parameter
    if (selectedStatus && selectedStatus !== "all") {
      params.set("status", selectedStatus);
    } else {
      params.delete("status");
    }

    // Update payment status parameter
    if (selectedPaymentStatus && selectedPaymentStatus !== "all") {
      params.set("paymentStatus", selectedPaymentStatus);
    } else {
      params.delete("paymentStatus");
    }

    // Update date filters
    if (dateFrom) {
      params.set("dateFrom", format(dateFrom, "yyyy-MM-dd"));
    } else {
      params.delete("dateFrom");
    }

    if (dateTo) {
      params.set("dateTo", format(dateTo, "yyyy-MM-dd"));
    } else {
      params.delete("dateTo");
    }

    router.push(`${pathname}?${params.toString()}`);
  };

  // Live search with debounce
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      updateFilters();
    }, 500); // 500ms debounce

    return () => clearTimeout(timeoutId);
  }, [searchTerm, selectedStatus, selectedPaymentStatus, dateFrom, dateTo]);

  // Clear all filters
  const clearFilters = () => {
    setSearchTerm("");
    setSelectedStatus("all");
    setSelectedPaymentStatus("all");
    setDateFrom(undefined);
    setDateTo(undefined);

    router.push(pathname);
  };

  const hasActiveFilters =
    searchTerm ||
    selectedStatus !== "all" ||
    selectedPaymentStatus !== "all" ||
    dateFrom ||
    dateTo;

  return (
    <div className="bg-gray-50 p-4 rounded-lg shadow-sm mb-6 space-y-4 border border-gray-200">
      <div className="flex flex-col md:flex-row gap-4">
        {/* Search */}
        <div className="flex-1">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <Input
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              placeholder="Search order number, customer..."
              className="pl-10 max-w-md text-gray-800"
            />
            {searchTerm && (
              <button
                onClick={() => setSearchTerm("")}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
        </div>

        {/* Status Filters */}
        <div className="flex flex-wrap gap-4 items-center">
          <Select value={selectedStatus} onValueChange={setSelectedStatus}>
            <SelectTrigger className="w-44 text-gray-800">
              <SelectValue placeholder="Order Status" />
            </SelectTrigger>
            <SelectContent>
              {orderStatuses.map((status) => (
                <SelectItem key={status.value} value={status.value}>
                  {status.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          <Select
            value={selectedPaymentStatus}
            onValueChange={setSelectedPaymentStatus}
          >
            <SelectTrigger className="w-44 text-gray-800">
              <SelectValue placeholder="Payment Status" />
            </SelectTrigger>
            <SelectContent>
              {paymentStatuses.map((status) => (
                <SelectItem key={status.value} value={status.value}>
                  {status.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          {/* Date filter */}
          <div className="flex gap-2">
            <Popover>
              <PopoverTrigger asChild>
                <Button variant="outline" className="flex gap-2 text-gray-700">
                  <CalendarIcon className="h-4 w-4 text-gray-500" />
                  {dateFrom ? format(dateFrom, "PP") : "From Date"}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0">
                <Calendar
                  mode="single"
                  selected={dateFrom}
                  onSelect={setDateFrom}
                  initialFocus
                />
              </PopoverContent>
            </Popover>

            <Popover>
              <PopoverTrigger asChild>
                <Button variant="outline" className="flex gap-2 text-gray-700">
                  <CalendarIcon className="h-4 w-4 text-gray-500" />
                  {dateTo ? format(dateTo, "PP") : "To Date"}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0">
                <Calendar
                  mode="single"
                  selected={dateTo}
                  onSelect={setDateTo}
                  initialFocus
                />
              </PopoverContent>
            </Popover>
          </div>

          {/* Clear filters button */}
          {hasActiveFilters && (
            <Button variant="outline" size="sm" onClick={clearFilters}>
              <X className="h-4 w-4 mr-2" />
              Clear Filters
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

File: ./src/components/admin/product-pagination.tsx
// src/components/admin/product-pagination.tsx
"use client";

import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  ChevronLeft,
  ChevronRight,
  ChevronsLeft,
  ChevronsRight,
} from "lucide-react";

interface ProductPaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
}

export default function ProductPagination({
  currentPage,
  totalPages,
  totalItems,
}: ProductPaginationProps) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const navigateToPage = (page: number) => {
    const params = new URLSearchParams(searchParams);
    params.set("page", page.toString());
    router.push(`${pathname}?${params.toString()}`);
  };

  const changePerPage = (perPage: string) => {
    const params = new URLSearchParams(searchParams);
    params.set("perPage", perPage);
    params.set("page", "1"); // Reset to page 1 when changing items per page
    router.push(`${pathname}?${params.toString()}`);
  };

  // Calculate start and end item numbers
  const perPage = parseInt(searchParams.get("perPage") || "10");
  const startItem = (currentPage - 1) * perPage + 1;
  const endItem = Math.min(currentPage * perPage, totalItems);

  return (
    <div className="flex flex-col sm:flex-row items-center justify-between gap-4 mt-4">
      <div className="text-sm text-gray-500">
        Showing {totalItems > 0 ? startItem : 0} to {endItem} of {totalItems}{" "}
        products
      </div>

      <div className="flex items-center gap-2">
        <div className="flex items-center">
          <Button
            variant="outline"
            size="icon"
            onClick={() => navigateToPage(1)}
            disabled={currentPage <= 1}
          >
            <ChevronsLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="icon"
            onClick={() => navigateToPage(currentPage - 1)}
            disabled={currentPage <= 1}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>

          <span className="mx-2 text-sm">
            Page {currentPage} of {totalPages || 1}
          </span>

          <Button
            variant="outline"
            size="icon"
            onClick={() => navigateToPage(currentPage + 1)}
            disabled={currentPage >= totalPages}
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="icon"
            onClick={() => navigateToPage(totalPages)}
            disabled={currentPage >= totalPages}
          >
            <ChevronsRight className="h-4 w-4" />
          </Button>
        </div>

        <Select
          value={searchParams.get("perPage") || "10"}
          onValueChange={changePerPage}
        >
          <SelectTrigger className="w-[120px]">
            <SelectValue placeholder="10 per page" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="10">10 per page</SelectItem>
            <SelectItem value="25">25 per page</SelectItem>
            <SelectItem value="50">50 per page</SelectItem>
            <SelectItem value="100">100 per page</SelectItem>
          </SelectContent>
        </Select>
      </div>
    </div>
  );
}

File: ./src/components/admin/product-tabs/variants-tab.tsx
// src/components/admin/product-tabs/variants-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FormControl, FormField, FormItem } from "@/components/ui/form";
import ProductVariantsForm from "../product-variants-form";
import { ProductFormValues } from "../product-form-types";

interface VariantsTabProps {
  control: Control<ProductFormValues>;
  onFormStateChange: (field: string, value: any) => void;
}

export default function VariantsTab({
  control,
  onFormStateChange,
}: VariantsTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Product Variants</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Add variants for different options like size, color, etc.
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        <FormField
          control={control}
          name="variants"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <ProductVariantsForm
                  variants={field.value}
                  onChange={(variants) => {
                    field.onChange(variants);
                    // Update the parent form state
                    onFormStateChange("variants", variants);
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/categories-tab.tsx
// src/components/admin/product-tabs/categories-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FormControl, FormField, FormItem } from "@/components/ui/form";
import ProductCategoriesSelect from "../product-categories-select";
import { ProductFormValues } from "../product-form-types";

interface CategoriesTabProps {
  control: Control<ProductFormValues>;
  categories: {
    id: string;
    name: string;
    level: number;
    parentId?: string | null;
  }[];
  onFormStateChange: (field: string, value: any) => void;
}

export default function CategoriesTab({
  control,
  categories,
  onFormStateChange,
}: CategoriesTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Categories</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Assign this product to categories to help customers find it.
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        <FormField
          control={control}
          name="categoryIds"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <ProductCategoriesSelect
                  categories={categories}
                  selectedCategories={field.value}
                  onChange={(selected) => {
                    field.onChange(selected);
                    // Update the parent form state
                    onFormStateChange("categoryIds", selected);
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/images-tab.tsx
// src/components/admin/product-tabs/images-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FormControl, FormField, FormItem } from "@/components/ui/form";
import ProductImagesUpload from "../product-images-upload";
import { ProductFormValues } from "../product-form-types";

interface ImagesTabProps {
  control: Control<ProductFormValues>;
  onFormStateChange: (field: string, value: any) => void;
}

export default function ImagesTab({
  control,
  onFormStateChange,
}: ImagesTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Product Images</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Upload images for your product. The first image will be used as the
          main image.
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        <FormField
          control={control}
          name="images"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <ProductImagesUpload
                  existingImages={field.value}
                  onImagesChange={(images) => {
                    field.onChange(images);
                    // Update the parent form state to preserve changes between tabs
                    onFormStateChange("images", images);
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/discount-codes-tab.tsx
// src/components/admin/product-tabs/discount-codes-tab.tsx
import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Plus, Trash, Edit, SearchIcon } from "lucide-react";
import { DiscountCode } from "../product-form-types";

interface DiscountCodesTabProps {
  shopId: string;
  productId?: string;
}

interface User {
  id: string;
  name: string;
  email: string;
}

export default function DiscountCodesTab({
  shopId,
  productId,
}: DiscountCodesTabProps) {
  const [discountCodes, setDiscountCodes] = useState<DiscountCode[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [editingCode, setEditingCode] = useState<DiscountCode | null>(null);
  const [users, setUsers] = useState<User[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);
  const [currentCode, setCurrentCode] = useState<Partial<DiscountCode>>({
    code: "",
    percentage: 10,
    shopId,
    productId: productId || null,
    userId: null,
    startDate: new Date().toISOString().split("T")[0],
    endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      .toISOString()
      .split("T")[0],
    isActive: true,
  });

  useEffect(() => {
    fetchDiscountCodes();
  }, [shopId, productId]);

  const fetchDiscountCodes = async () => {
    try {
      setIsLoading(true);
      let url = `/api/discount-codes?shopId=${shopId}`;
      if (productId) {
        url += `&productId=${productId}`;
      }

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        setDiscountCodes(data);
      }
    } catch (error) {
      console.error("Error fetching discount codes:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const searchUsers = async () => {
    if (!searchQuery || searchQuery.length < 2) return;

    try {
      setIsSearching(true);
      const response = await fetch(
        `/api/users/search?q=${searchQuery}&shopId=${shopId}`
      );
      if (response.ok) {
        const data = await response.json();
        setUsers(data);
      }
    } catch (error) {
      console.error("Error searching users:", error);
    } finally {
      setIsSearching(false);
    }
  };

  const handleCreateDiscountCode = async () => {
    try {
      const payload = {
        ...currentCode,
        shopId,
      };

      const url = editingCode
        ? `/api/discount-codes/${editingCode.id}`
        : "/api/discount-codes";
      const method = editingCode ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        await fetchDiscountCodes();
        setIsDialogOpen(false);
        resetCodeForm();
      }
    } catch (error) {
      console.error("Error saving discount code:", error);
    }
  };

  const handleDeleteDiscountCode = async (id: string) => {
    try {
      const response = await fetch(`/api/discount-codes/${id}`, {
        method: "DELETE",
      });

      if (response.ok) {
        await fetchDiscountCodes();
        setDeleteDialogOpen(false);
      }
    } catch (error) {
      console.error("Error deleting discount code:", error);
    }
  };

  const resetCodeForm = () => {
    setEditingCode(null);
    setCurrentCode({
      code: "",
      percentage: 10,
      shopId,
      productId: productId || null,
      userId: null,
      startDate: new Date().toISOString().split("T")[0],
      endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
        .toISOString()
        .split("T")[0],
      isActive: true,
    });
    setUsers([]);
    setSearchQuery("");
  };

  const handleEditDiscountCode = (code: DiscountCode) => {
    setEditingCode(code);
    setCurrentCode({
      ...code,
      startDate: new Date(code.startDate).toISOString().split("T")[0],
      endDate: new Date(code.endDate).toISOString().split("T")[0],
    });
    setIsDialogOpen(true);
  };

  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleDateString();
  };

  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Discount Codes</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Create promotional codes for your customers
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        {isLoading ? (
          <div className="text-center py-4">Loading discount codes...</div>
        ) : (
          <>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
                Available Discount Codes
              </h3>
              <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
                <DialogTrigger asChild>
                  <Button
                    style={{
                      backgroundColor: "#16a085",
                      color: "white",
                    }}
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Add Discount Code
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>
                      {editingCode
                        ? "Edit Discount Code"
                        : "Add New Discount Code"}
                    </DialogTitle>
                    <DialogDescription>
                      Create a discount code for customers to use at checkout.
                    </DialogDescription>
                  </DialogHeader>

                  <div className="grid gap-4 py-4">
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="code"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Code
                      </Label>
                      <Input
                        id="code"
                        value={currentCode.code}
                        onChange={(e) =>
                          setCurrentCode({
                            ...currentCode,
                            code: e.target.value.toUpperCase(),
                          })
                        }
                        placeholder="e.g., SUMMER10"
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="percentage"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Discount %
                      </Label>
                      <Input
                        id="percentage"
                        type="number"
                        min="1"
                        max="100"
                        value={currentCode.percentage}
                        onChange={(e) =>
                          setCurrentCode({
                            ...currentCode,
                            percentage: Number(e.target.value),
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>

                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="productSelection"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        For Product
                      </Label>
                      <div className="col-span-3">
                        <Select
                          value={currentCode.productId ? "specific" : "all"}
                          onValueChange={(value) =>
                            setCurrentCode({
                              ...currentCode,
                              productId:
                                value === "specific" ? productId : null,
                            })
                          }
                        >
                          <SelectTrigger
                            className="border-2"
                            style={{
                              borderColor: "#bdc3c7",
                              color: "#2c3e50",
                            }}
                          >
                            <SelectValue placeholder="Select product scope" />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="all">All Products</SelectItem>
                            {productId && (
                              <SelectItem value="specific">
                                This Product Only
                              </SelectItem>
                            )}
                          </SelectContent>
                        </Select>
                      </div>
                    </div>

                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="userSearch"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        For User
                      </Label>
                      <div className="col-span-3 space-y-2">
                        <div className="flex gap-2">
                          <Input
                            id="userSearch"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            placeholder="Search by name or email"
                            className="flex-1 border-2"
                            style={{
                              borderColor: "#bdc3c7",
                              color: "#2c3e50",
                              backgroundColor: "white",
                            }}
                          />
                          <Button
                            type="button"
                            variant="outline"
                            size="sm"
                            onClick={searchUsers}
                            disabled={isSearching}
                            className="border-2"
                            style={{
                              borderColor: "#bdc3c7",
                              color: "#2c3e50",
                            }}
                          >
                            <SearchIcon className="h-4 w-4" />
                          </Button>
                        </div>

                        {users.length > 0 && (
                          <Select
                            value={currentCode.userId || ""}
                            onValueChange={(value) =>
                              setCurrentCode({
                                ...currentCode,
                                userId: value === "" ? null : value,
                              })
                            }
                          >
                            <SelectTrigger
                              className="border-2"
                              style={{
                                borderColor: "#bdc3c7",
                                color: "#2c3e50",
                              }}
                            >
                              <SelectValue placeholder="Select user" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="">All Users</SelectItem>
                              {users.map((user) => (
                                <SelectItem key={user.id} value={user.id}>
                                  {user.name} ({user.email})
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                        )}

                        {!users.length && !isSearching && (
                          <p className="text-xs text-gray-500">
                            Search for a user or leave blank for all users
                          </p>
                        )}

                        {isSearching && (
                          <p className="text-xs text-gray-500">Searching...</p>
                        )}
                      </div>
                    </div>

                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="startDate"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Start Date
                      </Label>
                      <Input
                        id="startDate"
                        type="date"
                        value={currentCode.startDate}
                        onChange={(e) =>
                          setCurrentCode({
                            ...currentCode,
                            startDate: e.target.value,
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="endDate"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        End Date
                      </Label>
                      <Input
                        id="endDate"
                        type="date"
                        value={currentCode.endDate}
                        onChange={(e) =>
                          setCurrentCode({
                            ...currentCode,
                            endDate: e.target.value,
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="isActive"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Active
                      </Label>
                      <div className="flex items-center space-x-2 col-span-3">
                        <Switch
                          id="isActive"
                          checked={currentCode.isActive}
                          onCheckedChange={(checked) =>
                            setCurrentCode({
                              ...currentCode,
                              isActive: checked,
                            })
                          }
                        />
                        <Label htmlFor="isActive" style={{ color: "#2c3e50" }}>
                          {currentCode.isActive ? "Active" : "Inactive"}
                        </Label>
                      </div>
                    </div>
                  </div>

                  <DialogFooter>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => {
                        setIsDialogOpen(false);
                        resetCodeForm();
                      }}
                      style={{
                        borderColor: "#bdc3c7",
                        color: "#2c3e50",
                      }}
                    >
                      Cancel
                    </Button>
                    <Button
                      type="button"
                      onClick={handleCreateDiscountCode}
                      style={{
                        backgroundColor: "#16a085",
                        color: "white",
                      }}
                    >
                      {editingCode ? "Update" : "Create"}
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            </div>

            {discountCodes.length === 0 ? (
              <div className="bg-gray-50 border border-gray-200 rounded-lg p-6 text-center">
                <p style={{ color: "#2c3e50" }}>
                  No discount codes have been created yet.
                </p>
                <Button
                  onClick={() => setIsDialogOpen(true)}
                  type="button"
                  className="mt-4"
                  style={{
                    backgroundColor: "#16a085",
                    color: "white",
                  }}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Create Your First Discount Code
                </Button>
              </div>
            ) : (
              <div className="border border-gray-200 rounded-lg overflow-auto">
                <Table>
                  <TableHeader className="bg-gray-50">
                    <TableRow>
                      <TableHead>Code</TableHead>
                      <TableHead>Discount</TableHead>
                      <TableHead>Valid Period</TableHead>
                      <TableHead>Applied To</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead className="text-right">Actions</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {discountCodes.map((code) => (
                      <TableRow key={code.id}>
                        <TableCell className="font-medium uppercase">
                          {code.code}
                        </TableCell>
                        <TableCell>{code.percentage}% OFF</TableCell>
                        <TableCell>
                          {formatDate(code.startDate)} -{" "}
                          {formatDate(code.endDate)}
                        </TableCell>
                        <TableCell>
                          {code.productId ? "Specific Product" : "All Products"}
                          <br />
                          {code.userId ? "Specific User" : "All Users"}
                        </TableCell>
                        <TableCell>
                          <span
                            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                              code.isActive
                                ? "bg-green-100 text-green-800"
                                : "bg-gray-100 text-gray-800"
                            }`}
                          >
                            {code.isActive ? "Active" : "Inactive"}
                          </span>
                        </TableCell>
                        <TableCell className="text-right">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleEditDiscountCode(code)}
                            className="text-gray-500 hover:text-indigo-600"
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                          <AlertDialog
                            open={deleteDialogOpen}
                            onOpenChange={setDeleteDialogOpen}
                          >
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                setEditingCode(code);
                                setDeleteDialogOpen(true);
                              }}
                              className="text-gray-500 hover:text-red-600"
                            >
                              <Trash className="h-4 w-4" />
                            </Button>
                            <AlertDialogContent>
                              <AlertDialogHeader>
                                <AlertDialogTitle>
                                  Delete Discount Code
                                </AlertDialogTitle>
                                <AlertDialogDescription>
                                  Are you sure you want to delete this discount
                                  code? This action cannot be undone.
                                </AlertDialogDescription>
                              </AlertDialogHeader>
                              <AlertDialogFooter>
                                <AlertDialogCancel>Cancel</AlertDialogCancel>
                                <AlertDialogAction
                                  onClick={() => {
                                    if (editingCode?.id) {
                                      handleDeleteDiscountCode(editingCode.id);
                                    }
                                  }}
                                  className="bg-red-600 hover:bg-red-700"
                                >
                                  Delete
                                </AlertDialogAction>
                              </AlertDialogFooter>
                            </AlertDialogContent>
                          </AlertDialog>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/pricing-tab.tsx
// src/components/admin/product-tabs/pricing-tab.tsx
import { Control, useWatch } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { ProductFormValues } from "../product-form-types";
import { useMemo } from "react";

interface PricingTabProps {
  control: Control<ProductFormValues>;
}

export default function PricingTab({ control }: PricingTabProps) {
  // Watch values to calculate profit in real-time
  const price = useWatch({ control, name: "price" }) || 0;
  const cost = useWatch({ control, name: "cost" }) || 0;
  const tva = useWatch({ control, name: "tva" }) || 19;

  // Calculate profit and profit percentage
  const profitDetails = useMemo(() => {
    if (!cost || cost <= 0) {
      return { profit: price, profitPercentage: 0 };
    }

    // Calculate cost with TVA
    const costWithTVA = cost * (1 + tva / 100);

    // Calculate profit (price - (cost + TVA))
    const profit = price - costWithTVA;

    // Calculate profit percentage
    const profitPercentage = (profit / costWithTVA) * 100;

    return {
      profit: profit.toFixed(2),
      profitPercentage: profitPercentage.toFixed(2),
    };
  }, [price, cost, tva]);

  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">
          Pricing & Inventory
        </CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Set prices and manage inventory for this product.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6 pt-6 bg-white">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <FormField
            control={control}
            name="price"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  Selling Price *
                </FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    step="0.01"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    {...field}
                    value={field.value || ""}
                  />
                </FormControl>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />

          <FormField
            control={control}
            name="cost"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  Cost Price
                </FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    step="0.01"
                    placeholder="Product cost price"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    value={field.value === null ? "" : field.value}
                    onChange={(e) =>
                      field.onChange(
                        e.target.value ? Number(e.target.value) : null
                      )
                    }
                  />
                </FormControl>
                <FormDescription style={{ color: "#7f8c8d" }}>
                  Product cost (not visible to customers)
                </FormDescription>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />

          <FormField
            control={control}
            name="tva"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  TVA (%)
                </FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    min="0"
                    max="100"
                    step="0.1"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    {...field}
                    value={field.value || ""}
                  />
                </FormControl>
                <FormDescription style={{ color: "#7f8c8d" }}>
                  Tax percentage (default: 19%)
                </FormDescription>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />
        </div>

        {/* Profit Information */}
        {cost > 0 && (
          <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
            <h3
              className="text-md font-medium mb-2"
              style={{ color: "#2c3e50" }}
            >
              Profit Calculation
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <p className="text-sm text-gray-600">Profit per unit:</p>
                <p
                  className="text-lg font-semibold"
                  style={{
                    color:
                      Number(profitDetails.profit) > 0 ? "#16a085" : "#e74c3c",
                  }}
                >
                  ${profitDetails.profit}
                </p>
              </div>
              <div>
                <p className="text-sm text-gray-600">Profit margin:</p>
                <p
                  className="text-lg font-semibold"
                  style={{
                    color:
                      Number(profitDetails.profitPercentage) > 0
                        ? "#16a085"
                        : "#e74c3c",
                  }}
                >
                  {profitDetails.profitPercentage}%
                </p>
              </div>
            </div>
          </div>
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <FormField
            control={control}
            name="inventory"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  Inventory Quantity
                </FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    {...field}
                    value={field.value || ""}
                  />
                </FormControl>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />

          <FormField
            control={control}
            name="barcode"
            render={({ field }) => (
              <FormItem>
                <FormLabel
                  style={{ color: "#2c3e50" }}
                  className="font-medium text-base"
                >
                  Barcode
                </FormLabel>
                <FormControl>
                  <Input
                    placeholder="Optional"
                    className="border-2"
                    style={{
                      borderColor: "#bdc3c7",
                      color: "#2c3e50",
                      backgroundColor: "white",
                    }}
                    {...field}
                    value={field.value || ""}
                  />
                </FormControl>
                <FormDescription style={{ color: "#7f8c8d" }}>
                  UPC, EAN, ISBN, etc.
                </FormDescription>
                <FormMessage className="text-red-600" />
              </FormItem>
            )}
          />
        </div>

        <FormField
          control={control}
          name="expiryDate"
          render={({ field }) => (
            <FormItem>
              <FormLabel
                style={{ color: "#2c3e50" }}
                className="font-medium text-base"
              >
                Expiry Date
              </FormLabel>
              <FormControl>
                <Input
                  type="date"
                  className="border-2"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#2c3e50",
                    backgroundColor: "white",
                  }}
                  value={field.value || ""}
                  onChange={field.onChange}
                />
              </FormControl>
              <FormDescription style={{ color: "#7f8c8d" }}>
                Set if product has an expiration date
              </FormDescription>
              <FormMessage className="text-red-600" />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/custom-fields-tab.tsx
// src/components/admin/product-tabs/custom-fields-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { FormControl, FormField, FormItem } from "@/components/ui/form";
import ProductCustomFields from "../product-custom-fields";
import { ProductFormValues } from "../product-form-types";

interface CustomField {
  id: string;
  name: string;
  type: string;
  required: boolean;
}

interface CustomFieldsTabProps {
  control: Control<ProductFormValues>;
  customFields: CustomField[];
  onFormStateChange: (field: string, value: any) => void;
}

export default function CustomFieldsTab({
  control,
  customFields,
  onFormStateChange,
}: CustomFieldsTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Custom Fields</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Add additional information specific to this product.
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        <FormField
          control={control}
          name="customFieldValues"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <ProductCustomFields
                  customFieldValues={field.value}
                  availableCustomFields={customFields}
                  onChange={(fields) => {
                    field.onChange(fields);
                    // Update the parent form state
                    onFormStateChange("customFieldValues", fields);
                  }}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/basic-info-tab.tsx
// src/components/admin/product-tabs/basic-info-tab.tsx
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { ProductFormValues } from "../product-form-types";

interface BasicInfoTabProps {
  control: Control<ProductFormValues>;
}

export default function BasicInfoTab({ control }: BasicInfoTabProps) {
  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Basic Information</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Enter the basic details about your product.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6 pt-6 bg-white">
        <FormField
          control={control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel
                style={{ color: "#2c3e50" }}
                className="font-medium text-base"
              >
                Product Name *
              </FormLabel>
              <FormControl>
                <Input
                  placeholder="Enter product name"
                  className="border-2"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#2c3e50",
                    backgroundColor: "white",
                  }}
                  {...field}
                />
              </FormControl>
              <FormDescription style={{ color: "#7f8c8d" }}>
                A slug will be automatically generated from the name.
              </FormDescription>
              <FormMessage className="text-red-600" />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel
                style={{ color: "#2c3e50" }}
                className="font-medium text-base"
              >
                Description
              </FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Enter product description"
                  className="min-h-[150px] border-2"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#2c3e50",
                    backgroundColor: "white",
                  }}
                  {...field}
                />
              </FormControl>
              <FormMessage className="text-red-600" />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-tabs/discounts-tab.tsx
// src/components/admin/product-tabs/discounts-tab.tsx
import { useState, useEffect } from "react";
import { Control } from "react-hook-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Plus, Trash, Edit } from "lucide-react";
import { ProductFormValues, Discount } from "../product-form-types";

interface DiscountsTabProps {
  control: Control<ProductFormValues>;
  productId?: string;
  shopId: string;
}

export default function DiscountsTab({
  control,
  productId,
  shopId,
}: DiscountsTabProps) {
  const [discounts, setDiscounts] = useState<Discount[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [editingDiscount, setEditingDiscount] = useState<Discount | null>(null);
  const [currentDiscount, setCurrentDiscount] = useState<Discount>({
    percentage: 0,
    enabled: true,
    startDate: new Date().toISOString().split("T")[0],
    endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      .toISOString()
      .split("T")[0],
    productId: productId || "",
  });

  // Fetch discounts for this product when component mounts
  useEffect(() => {
    if (productId) {
      fetchDiscounts();
    } else {
      setIsLoading(false);
    }
  }, [productId]);

  const fetchDiscounts = async () => {
    try {
      setIsLoading(true);
      const response = await fetch(`/api/discounts?productId=${productId}`);
      if (response.ok) {
        const data = await response.json();
        setDiscounts(data);
      }
    } catch (error) {
      console.error("Error fetching discounts:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleCreateDiscount = async () => {
    try {
      const payload = {
        ...currentDiscount,
        productId,
      };

      const url = editingDiscount
        ? `/api/discounts/${editingDiscount.id}`
        : "/api/discounts";
      const method = editingDiscount ? "PUT" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        await fetchDiscounts();
        setIsDialogOpen(false);
        resetDiscountForm();
      }
    } catch (error) {
      console.error("Error saving discount:", error);
    }
  };

  const handleDeleteDiscount = async (id: string) => {
    try {
      const response = await fetch(`/api/discounts/${id}`, {
        method: "DELETE",
      });

      if (response.ok) {
        await fetchDiscounts();
        setDeleteDialogOpen(false);
      }
    } catch (error) {
      console.error("Error deleting discount:", error);
    }
  };

  const resetDiscountForm = () => {
    setEditingDiscount(null);
    setCurrentDiscount({
      percentage: 0,
      enabled: true,
      startDate: new Date().toISOString().split("T")[0],
      endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
        .toISOString()
        .split("T")[0],
      productId: productId || "",
    });
  };

  const handleEditDiscount = (discount: Discount) => {
    setEditingDiscount(discount);
    setCurrentDiscount({
      ...discount,
      startDate: new Date(discount.startDate).toISOString().split("T")[0],
      endDate: new Date(discount.endDate).toISOString().split("T")[0],
    });
    setIsDialogOpen(true);
  };

  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleDateString();
  };

  return (
    <Card className="border-0 shadow">
      <CardHeader
        style={{ backgroundColor: "#2c3e50" }}
        className="text-white rounded-t-lg"
      >
        <CardTitle className="text-xl font-medium">Product Discounts</CardTitle>
        <CardDescription
          style={{ color: "#bdc3c7" }}
          className="mt-1 text-base"
        >
          Manage price discounts for this product
        </CardDescription>
      </CardHeader>
      <CardContent className="pt-6 bg-white">
        {isLoading ? (
          <div className="text-center py-4">Loading discounts...</div>
        ) : (
          <>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
                Active Discounts
              </h3>
              <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
                <DialogTrigger asChild>
                  <Button
                    style={{
                      backgroundColor: "#16a085",
                      color: "white",
                    }}
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Add Discount
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>
                      {editingDiscount ? "Edit Discount" : "Add New Discount"}
                    </DialogTitle>
                    <DialogDescription>
                      Create a discount for this product.
                    </DialogDescription>
                  </DialogHeader>

                  <div className="grid gap-4 py-4">
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="percentage"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Discount %
                      </Label>
                      <Input
                        id="percentage"
                        type="number"
                        step="0.01"
                        min="0"
                        max="100"
                        value={currentDiscount.percentage}
                        onChange={(e) =>
                          setCurrentDiscount({
                            ...currentDiscount,
                            percentage: Number(e.target.value),
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="startDate"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Start Date
                      </Label>
                      <Input
                        id="startDate"
                        type="date"
                        value={currentDiscount.startDate}
                        onChange={(e) =>
                          setCurrentDiscount({
                            ...currentDiscount,
                            startDate: e.target.value,
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="endDate"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        End Date
                      </Label>
                      <Input
                        id="endDate"
                        type="date"
                        value={currentDiscount.endDate}
                        onChange={(e) =>
                          setCurrentDiscount({
                            ...currentDiscount,
                            endDate: e.target.value,
                          })
                        }
                        className="col-span-3 border-2"
                        style={{
                          borderColor: "#bdc3c7",
                          color: "#2c3e50",
                          backgroundColor: "white",
                        }}
                      />
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                      <Label
                        htmlFor="enabled"
                        className="text-right"
                        style={{ color: "#2c3e50" }}
                      >
                        Enabled
                      </Label>
                      <div className="flex items-center space-x-2 col-span-3">
                        <Switch
                          id="enabled"
                          checked={currentDiscount.enabled}
                          onCheckedChange={(checked) =>
                            setCurrentDiscount({
                              ...currentDiscount,
                              enabled: checked,
                            })
                          }
                        />
                        <Label htmlFor="enabled" style={{ color: "#2c3e50" }}>
                          {currentDiscount.enabled ? "Active" : "Inactive"}
                        </Label>
                      </div>
                    </div>
                  </div>

                  <DialogFooter>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => {
                        setIsDialogOpen(false);
                        resetDiscountForm();
                      }}
                      style={{
                        borderColor: "#bdc3c7",
                        color: "#2c3e50",
                      }}
                    >
                      Cancel
                    </Button>
                    <Button
                      type="button"
                      onClick={handleCreateDiscount}
                      style={{
                        backgroundColor: "#16a085",
                        color: "white",
                      }}
                    >
                      {editingDiscount ? "Update" : "Create"}
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>
            </div>

            {discounts.length === 0 ? (
              <div className="bg-gray-50 border border-gray-200 rounded-lg p-6 text-center">
                <p style={{ color: "#2c3e50" }}>
                  No discounts have been created for this product yet.
                </p>
                <Button
                  onClick={() => setIsDialogOpen(true)}
                  type="button"
                  className="mt-4"
                  style={{
                    backgroundColor: "#16a085",
                    color: "white",
                  }}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Add Your First Discount
                </Button>
              </div>
            ) : (
              <div className="border border-gray-200 rounded-lg overflow-auto">
                <Table>
                  <TableHeader className="bg-gray-50">
                    <TableRow>
                      <TableHead>Percentage</TableHead>
                      <TableHead>Start Date</TableHead>
                      <TableHead>End Date</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead className="text-right">Actions</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {discounts.map((discount) => (
                      <TableRow key={discount.id}>
                        <TableCell className="font-medium">
                          {discount.percentage}%
                        </TableCell>
                        <TableCell>{formatDate(discount.startDate)}</TableCell>
                        <TableCell>{formatDate(discount.endDate)}</TableCell>
                        <TableCell>
                          <span
                            className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                              discount.enabled
                                ? "bg-green-100 text-green-800"
                                : "bg-gray-100 text-gray-800"
                            }`}
                          >
                            {discount.enabled ? "Active" : "Inactive"}
                          </span>
                        </TableCell>
                        <TableCell className="text-right">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleEditDiscount(discount)}
                            className="text-gray-500 hover:text-indigo-600"
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                          <AlertDialog
                            open={deleteDialogOpen}
                            onOpenChange={setDeleteDialogOpen}
                          >
                            <Button
                              variant="ghost"
                              size="sm"
                              onClick={() => {
                                setEditingDiscount(discount);
                                setDeleteDialogOpen(true);
                              }}
                              className="text-gray-500 hover:text-red-600"
                            >
                              <Trash className="h-4 w-4" />
                            </Button>
                            <AlertDialogContent>
                              <AlertDialogHeader>
                                <AlertDialogTitle>
                                  Delete Discount
                                </AlertDialogTitle>
                                <AlertDialogDescription>
                                  Are you sure you want to delete this discount?
                                  This action cannot be undone.
                                </AlertDialogDescription>
                              </AlertDialogHeader>
                              <AlertDialogFooter>
                                <AlertDialogCancel>Cancel</AlertDialogCancel>
                                <AlertDialogAction
                                  onClick={() => {
                                    if (editingDiscount?.id) {
                                      handleDeleteDiscount(editingDiscount.id);
                                    }
                                  }}
                                  className="bg-red-600 hover:bg-red-700"
                                >
                                  Delete
                                </AlertDialogAction>
                              </AlertDialogFooter>
                            </AlertDialogContent>
                          </AlertDialog>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
}

File: ./src/components/admin/product-custom-fields.tsx
// src/components/admin/product-custom-fields.tsx
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Trash, Plus, ChevronDown, ChevronUp, Calendar } from "lucide-react";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";

// Structure matching the database model
interface CustomFieldValue {
  id?: string;
  customFieldId: string; // This links to the custom field definition
  value: string;
}

// This represents the available custom fields from the database
interface AvailableCustomField {
  id: string;
  name: string;
  type: string;
  required: boolean;
}

interface ProductCustomFieldsProps {
  customFieldValues: CustomFieldValue[];
  availableCustomFields: AvailableCustomField[];
  onChange: (fields: CustomFieldValue[]) => void;
}

export default function ProductCustomFields({
  customFieldValues = [],
  availableCustomFields = [],
  onChange,
}: ProductCustomFieldsProps) {
  const [localFieldValues, setLocalFieldValues] =
    useState<CustomFieldValue[]>(customFieldValues);
  const [selectedCustomFieldId, setSelectedCustomFieldId] =
    useState<string>("");
  const [isOpen, setIsOpen] = useState<boolean>(true); // Open by default

  // Sync with parent component when props change
  useEffect(() => {
    setLocalFieldValues(customFieldValues);
  }, [customFieldValues]);

  // Add a custom field value
  const handleAddCustomField = () => {
    if (!selectedCustomFieldId) return;

    // Check if field already exists for this product
    if (
      localFieldValues.some(
        (field) => field.customFieldId === selectedCustomFieldId
      )
    ) {
      // Could show an error "This field has already been added"
      return;
    }

    const newFieldValues = [
      ...localFieldValues,
      {
        customFieldId: selectedCustomFieldId,
        value: "",
      },
    ];

    setLocalFieldValues(newFieldValues);
    onChange(newFieldValues);
    setSelectedCustomFieldId("");
  };

  // Update a custom field value
  const handleUpdateField = (index: number, value: string) => {
    const updatedFields = [...localFieldValues];
    updatedFields[index].value = value;
    setLocalFieldValues(updatedFields);
    onChange(updatedFields);
  };

  // Remove a custom field value
  const handleRemoveField = (index: number) => {
    const updatedFields = [...localFieldValues];
    updatedFields.splice(index, 1);
    setLocalFieldValues(updatedFields);
    onChange(updatedFields);
  };

  // Filter out already added custom fields
  const availableFieldsToAdd = availableCustomFields.filter(
    (field) =>
      !localFieldValues.some((value) => value.customFieldId === field.id)
  );

  // Get field name from ID
  const getFieldNameById = (fieldId: string): string => {
    const field = availableCustomFields.find((f) => f.id === fieldId);
    return field ? field.name : "Unknown Field";
  };

  // Get field type from ID
  const getFieldTypeById = (fieldId: string): string => {
    const field = availableCustomFields.find((f) => f.id === fieldId);
    return field ? field.type : "TEXT";
  };

  // Is field required
  const isFieldRequired = (fieldId: string): boolean => {
    const field = availableCustomFields.find((f) => f.id === fieldId);
    return field ? field.required : false;
  };

  // Render custom field input based on type
  const renderFieldInput = (
    fieldType: string,
    value: string,
    onChange: (value: string) => void
  ) => {
    switch (fieldType) {
      case "TEXT":
        return (
          <Input
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          />
        );

      case "TEXTAREA":
        return (
          <Textarea
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="border-2 min-h-[100px]"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          />
        );

      case "NUMBER":
        return (
          <Input
            type="number"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          />
        );

      case "DATE":
        return (
          <div className="relative">
            <Input
              type="date"
              value={value}
              onChange={(e) => onChange(e.target.value)}
              className="border-2"
              style={{
                borderColor: "#bdc3c7",
                color: "#2c3e50",
                backgroundColor: "white",
              }}
            />
            <Calendar className="absolute right-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400 pointer-events-none" />
          </div>
        );

      case "BOOLEAN":
        return (
          <div className="flex items-center space-x-2">
            <Switch
              checked={value === "true"}
              onCheckedChange={(checked) =>
                onChange(checked ? "true" : "false")
              }
            />
            <span className="text-sm text-gray-500">
              {value === "true" ? "Yes" : "No"}
            </span>
          </div>
        );

      case "SELECT":
        // In a real app, you'd get options from somewhere
        const options = ["Option 1", "Option 2", "Option 3"];
        return (
          <Select value={value} onValueChange={onChange}>
            <SelectTrigger
              className="border-2"
              style={{ borderColor: "#bdc3c7", color: "#2c3e50" }}
            >
              <SelectValue placeholder="Select an option" />
            </SelectTrigger>
            <SelectContent>
              {options.map((option) => (
                <SelectItem key={option} value={option}>
                  {option}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      default:
        return (
          <Input
            value={value}
            onChange={(e) => onChange(e.target.value)}
            className="border-2"
            style={{
              borderColor: "#bdc3c7",
              color: "#2c3e50",
              backgroundColor: "white",
            }}
          />
        );
    }
  };

  return (
    <div className="space-y-6">
      {/* Custom field values list */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
          Product Custom Fields
        </h3>

        {localFieldValues.length === 0 ? (
          <div className="bg-gray-50 border border-gray-200 rounded-lg p-6 text-center">
            <p style={{ color: "#2c3e50" }}>
              No custom fields added yet. Add fields below to provide additional
              product information.
            </p>
            <Button
              onClick={() => setIsOpen(true)}
              type="button"
              className="mt-4"
              style={{
                backgroundColor: "#16a085",
                color: "white",
              }}
            >
              <Plus className="h-4 w-4 mr-2" />
              Add Custom Field
            </Button>
          </div>
        ) : (
          <div className="space-y-4">
            {localFieldValues.map((fieldValue, index) => (
              <Card
                key={index}
                className="border rounded-lg overflow-hidden"
                style={{ borderColor: "#bdc3c7" }}
              >
                <CardHeader className="p-4 pb-2 flex flex-row items-center justify-between">
                  <div>
                    <CardTitle
                      className="text-base font-medium"
                      style={{ color: "#2c3e50" }}
                    >
                      {getFieldNameById(fieldValue.customFieldId)}
                      {isFieldRequired(fieldValue.customFieldId) && (
                        <span className="text-red-500 ml-1">*</span>
                      )}
                    </CardTitle>
                    <CardDescription>
                      <span
                        className="text-xs px-2 py-0.5 rounded-full"
                        style={{
                          backgroundColor: "#f5f7fa",
                          color: "#2c3e50",
                        }}
                      >
                        {getFieldTypeById(fieldValue.customFieldId)}
                      </span>
                    </CardDescription>
                  </div>
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={() => handleRemoveField(index)}
                    className="text-gray-500 hover:text-red-600"
                  >
                    <Trash className="h-4 w-4" />
                  </Button>
                </CardHeader>
                <CardContent className="p-4 pt-2">
                  {renderFieldInput(
                    getFieldTypeById(fieldValue.customFieldId),
                    fieldValue.value,
                    (value) => handleUpdateField(index, value)
                  )}
                </CardContent>
              </Card>
            ))}
          </div>
        )}
      </div>

      {/* Add custom fields section */}
      <Collapsible
        open={isOpen || localFieldValues.length === 0}
        onOpenChange={setIsOpen}
        className="border rounded-lg overflow-hidden"
        style={{ borderColor: "#bdc3c7" }}
      >
        <CollapsibleTrigger asChild>
          <div className="p-4 flex items-center justify-between cursor-pointer bg-gray-50">
            <h3 className="text-lg font-medium" style={{ color: "#2c3e50" }}>
              Add Custom Field
            </h3>
            {isOpen ? (
              <ChevronUp className="h-5 w-5 text-gray-500" />
            ) : (
              <ChevronDown className="h-5 w-5 text-gray-500" />
            )}
          </div>
        </CollapsibleTrigger>
        <CollapsibleContent
          className="p-4 border-t"
          style={{ borderColor: "#bdc3c7" }}
        >
          {availableFieldsToAdd.length === 0 ? (
            <div className="text-center p-4 bg-gray-50 rounded-lg">
              <p className="text-sm" style={{ color: "#7f8c8d" }}>
                All available custom fields have been added to this product.
                Create more custom fields in the Custom Fields section.
              </p>
              <Button
                type="button"
                className="mt-3"
                variant="outline"
                onClick={() => window.open("/admin/custom-fields", "_blank")}
                style={{
                  borderColor: "#16a085",
                  color: "#16a085",
                }}
              >
                <Plus className="h-4 w-4 mr-2" />
                Manage Custom Fields
              </Button>
            </div>
          ) : (
            <div className="space-y-4">
              <p className="text-sm" style={{ color: "#7f8c8d" }}>
                Select a custom field to add additional information to this
                product.
              </p>
              <div className="flex gap-2">
                <div className="flex-1">
                  <Select
                    value={selectedCustomFieldId}
                    onValueChange={setSelectedCustomFieldId}
                  >
                    <SelectTrigger
                      className="border-2"
                      style={{
                        borderColor: "#bdc3c7",
                        color: "#2c3e50",
                        backgroundColor: "white",
                      }}
                    >
                      <SelectValue placeholder="Select a custom field to add" />
                    </SelectTrigger>
                    <SelectContent>
                      {availableFieldsToAdd.map((field) => (
                        <SelectItem
                          key={field.id}
                          value={field.id}
                          style={{ color: "#2c3e50" }}
                        >
                          {field.name}
                          {field.required && " (Required)"}
                          <span className="ml-2 text-xs text-gray-500">
                            ({field.type})
                          </span>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <Button
                  type="button"
                  onClick={handleAddCustomField}
                  disabled={!selectedCustomFieldId}
                  style={{
                    backgroundColor: selectedCustomFieldId
                      ? "#16a085"
                      : "#f5f7fa",
                    color: selectedCustomFieldId ? "white" : "#bdc3c7",
                  }}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Add Field
                </Button>
              </div>

              <div className="mt-4">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => window.open("/admin/custom-fields", "_blank")}
                  size="sm"
                  className="text-sm"
                  style={{
                    borderColor: "#bdc3c7",
                    color: "#7f8c8d",
                  }}
                >
                  <Plus className="h-3 w-3 mr-1" />
                  Create New Custom Field
                </Button>
              </div>
            </div>
          )}
        </CollapsibleContent>
      </Collapsible>
    </div>
  );
}

File: ./src/components/ui/label.tsx
// src/components/ui/label.tsx
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cn } from "@/lib/utils";

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(
      "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
      className
    )}
    {...props}
  />
));

Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

File: ./src/components/ui/select.tsx
// src/components/ui/select.tsx
import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown } from "lucide-react";
import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;
const SelectGroup = SelectPrimitive.Group;
const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-white placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:border-gray-700 dark:bg-gray-950 dark:ring-offset-gray-950 dark:placeholder:text-gray-400 dark:focus:ring-indigo-400",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 min-w-[8rem] overflow-hidden rounded-md border border-gray-200 bg-white text-gray-900 shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-gray-800 dark:bg-gray-950 dark:text-gray-50",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-gray-100 focus:text-gray-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-gray-800 dark:focus:text-gray-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-gray-100 dark:bg-gray-800", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
};

File: ./src/components/ui/dropdown-menu.tsx
// src/components/ui/dropdown-menu.tsx
import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  HTMLButtonElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-gray-100 data-[state=open]:bg-gray-100 dark:focus:bg-gray-800 dark:data-[state=open]:bg-gray-800",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border border-gray-200 bg-white p-1 text-gray-900 shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-gray-800 dark:bg-gray-950 dark:text-gray-50",
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border border-gray-200 bg-white p-1 text-gray-900 shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-gray-800 dark:bg-gray-950 dark:text-gray-50",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-gray-100 focus:text-gray-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-gray-800 dark:focus:text-gray-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-gray-100 focus:text-gray-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-gray-800 dark:focus:text-gray-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-gray-100 focus:text-gray-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-gray-800 dark:focus:text-gray-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  HTMLLabelElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-gray-900 dark:text-gray-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  HTMLHRElement,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-gray-200 dark:bg-gray-800", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-gray-500 dark:text-gray-400",
        className
      )}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

File: ./src/components/ui/form.tsx
// src/components/ui/form.tsx
import * as React from "react";
import {
  Controller,
  FormProvider,
  useFormContext,
  type UseFormReturn,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form";
import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = <TFormValues extends FieldValues>({
  children,
  ...props
}: React.PropsWithChildren<
  { className?: string } & React.ComponentProps<
    typeof FormProvider<TFormValues>
  >
>) => <FormProvider {...props}>{children}</FormProvider>;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof Label>,
  React.ComponentPropsWithoutRef<typeof Label>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && "text-red-500 dark:text-red-400", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <div
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-gray-500 dark:text-gray-400", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn(
        "text-sm font-medium text-red-500 dark:text-red-400",
        className
      )}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};

File: ./src/components/ui/collapsible.tsx
"use client";

import * as React from "react";
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";
import { cn } from "@/lib/utils";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.Trigger;

const CollapsibleContent = React.forwardRef<
  React.ElementRef<typeof CollapsiblePrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof CollapsiblePrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <CollapsiblePrimitive.Content
    ref={ref}
    className={cn(
      "data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down overflow-hidden transition-all",
      className
    )}
    {...props}
  >
    {children}
  </CollapsiblePrimitive.Content>
));
CollapsibleContent.displayName = "CollapsibleContent";

export { Collapsible, CollapsibleTrigger, CollapsibleContent };

File: ./src/components/ui/button.tsx
// src/components/ui/button.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-indigo-600 text-white hover:bg-indigo-700 dark:bg-indigo-600 dark:hover:bg-indigo-700",
        destructive:
          "bg-red-600 text-white hover:bg-red-700 dark:bg-red-600 dark:hover:bg-red-700",
        outline:
          "border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 dark:border-gray-700 dark:bg-gray-950 dark:text-gray-300 dark:hover:bg-gray-900",
        secondary:
          "bg-gray-100 text-gray-900 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-100 dark:hover:bg-gray-700",
        ghost:
          "text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-800",
        link: "text-indigo-600 underline-offset-4 hover:underline dark:text-indigo-400",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-8 px-3 text-xs",
        lg: "h-12 px-6 text-base",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  isLoading?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, isLoading = false, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        disabled={isLoading || props.disabled}
        {...props}
      >
        {isLoading && (
          <svg
            className="mr-2 h-4 w-4 animate-spin"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            ></circle>
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
        )}
        {props.children}
      </button>
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };

File: ./src/components/ui/popover.tsx
"use client";

import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border border-gray-200 bg-white p-4 shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-gray-800 dark:bg-gray-950 dark:text-gray-50",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };

File: ./src/components/ui/use-toast.ts
// src/components/ui/use-toast.ts
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 5;
const TOAST_REMOVE_DELAY = 5000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_VALUE;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: string;
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: string;
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case actionTypes.ADD_TOAST:
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case actionTypes.UPDATE_TOAST:
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case actionTypes.DISMISS_TOAST: {
      const { toastId } = action;

      // Dismiss all toasts
      if (toastId === undefined) {
        return {
          ...state,
          toasts: state.toasts.map((t) => ({
            ...t,
            open: false,
          })),
        };
      }

      // Dismiss specific toast
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }

    case actionTypes.REMOVE_TOAST: {
      const { toastId } = action;

      // Remove all toasts
      if (toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }

      // Remove specific toast
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== toastId),
      };
    }
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => listener(memoryState));
}

interface Toast extends Omit<ToasterToast, "id"> {}

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: Toast) =>
    dispatch({
      type: actionTypes.UPDATE_TOAST,
      toast: { ...props, id },
    });

  const dismiss = () =>
    dispatch({ type: actionTypes.DISMISS_TOAST, toastId: id });

  dispatch({
    type: actionTypes.ADD_TOAST,
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) {
          dismiss();
        }
      },
    },
  });

  return {
    id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) =>
      dispatch({ type: actionTypes.DISMISS_TOAST, toastId }),
  };
}

export { useToast, toast };

File: ./src/components/ui/dialog.tsx
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-200 bg-white p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-white transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-gray-100 data-[state=open]:text-gray-500">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-500", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

File: ./src/components/ui/tabs.tsx
// src/components/ui/tabs.tsx
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-gray-100 p-1 text-gray-600 dark:bg-gray-800 dark:text-gray-400",
      className
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  HTMLButtonElement,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium ring-offset-white transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-white data-[state=active]:text-indigo-600 data-[state=active]:shadow-sm dark:ring-offset-gray-950 dark:focus-visible:ring-indigo-400 dark:data-[state=active]:bg-gray-950 dark:data-[state=active]:text-indigo-400",
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 dark:ring-offset-gray-950 dark:focus-visible:ring-indigo-400",
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

File: ./src/components/ui/card.tsx
// src/components/ui/card.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border border-gray-200 bg-white shadow-sm dark:border-gray-800 dark:bg-gray-950",
      className
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight text-gray-900 dark:text-gray-50",
      className
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-gray-600 dark:text-gray-400", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};

File: ./src/components/ui/separator.tsx
"use client";

import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-gray-200 dark:bg-gray-800",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };

File: ./src/components/ui/badge.tsx
// src/components/ui/badge.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "bg-red-500 text-white hover:bg-red-600",
        outline: "border border-gray-200 text-gray-700 hover:bg-gray-100",
        success: "bg-green-500 text-white hover:bg-green-600",
        warning: "bg-amber-500 text-white hover:bg-amber-600",
        info: "bg-blue-500 text-white hover:bg-blue-600",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

File: ./src/components/ui/textarea.tsx
// src/components/ui/textarea.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-white placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:border-gray-700 dark:bg-gray-950 dark:ring-offset-gray-950 dark:placeholder:text-gray-400 dark:focus-visible:ring-indigo-400",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = "Textarea";

export { Textarea };

File: ./src/components/ui/calendar.tsx
"use client";

import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium text-gray-800",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-gray-500 rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-gray-100/50 [&:has([aria-selected])]:bg-gray-100 first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100 text-gray-700"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-indigo-600 text-white hover:bg-indigo-600 hover:text-white focus:bg-indigo-600 focus:text-white",
        day_today: "bg-gray-100 text-gray-800",
        day_outside:
          "day-outside text-gray-400 opacity-50 aria-selected:bg-gray-100/50 aria-selected:text-gray-500 aria-selected:opacity-30",
        day_disabled: "text-gray-400 opacity-50",
        day_range_middle:
          "aria-selected:bg-gray-100 aria-selected:text-gray-800",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };

File: ./src/components/ui/table.tsx
// src/components/ui/table.tsx - Update colors for better visibility
import * as React from "react";
import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="w-full overflow-auto">
    <table
      ref={ref}
      className={cn(
        "w-full caption-bottom text-sm text-gray-900 dark:text-gray-100",
        className
      )}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead
    ref={ref}
    className={cn("[&_tr]:border-b bg-gray-200 dark:bg-gray-800", className)}
    {...props}
  />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn(
      "[&_tr:last-child]:border-0 bg-white dark:bg-gray-900",
      className
    )}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "bg-gray-100 font-medium text-gray-900 dark:bg-gray-700 dark:text-gray-200",
      className
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-gray-100 dark:border-gray-700 dark:hover:bg-gray-800",
      className
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-gray-800 dark:text-gray-300 bg-gray-100 dark:bg-gray-700",
      className
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-4 align-middle text-gray-800 dark:text-gray-200",
      className
    )}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-gray-700 dark:text-gray-400", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};

File: ./src/components/ui/toast.tsx
// src/components/ui/toast.tsx
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-white text-gray-900",
        destructive: "destructive group border-red-500 bg-red-50 text-red-900",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border border-gray-200 bg-transparent px-3 text-sm font-medium ring-offset-white transition-colors hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-red-100 group-[.destructive]:hover:border-red-200 group-[.destructive]:hover:bg-red-100 group-[.destructive]:hover:text-red-900 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-50",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-gray-500 opacity-0 transition-opacity hover:text-gray-900 focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-500 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-50",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

File: ./src/components/ui/switch.tsx
// src/components/ui/switch.tsx
"use client";

import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";
import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-gray-400 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-green-500 data-[state=unchecked]:bg-gray-200",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-white shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

File: ./src/components/ui/alert-dialog.tsx
import * as React from "react";
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/50 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-gray-200 bg-white p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg md:w-full dark:border-gray-800 dark:bg-gray-950",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold text-gray-900 dark:text-gray-50",
      className
    )}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-500 dark:text-gray-400", className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  HTMLButtonElement,
  React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ className, ...props }, ref) => (
  <button ref={ref} className={cn(buttonVariants(), className)} {...props} />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};

File: ./src/components/ui/input.tsx
// src/components/ui/input.tsx
import * as React from "react";
import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  error?: string;
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, error, ...props }, ref) => {
    return (
      <div className="relative">
        <input
          type={type}
          className={cn(
            "flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm ring-offset-white file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 dark:border-gray-700 dark:bg-gray-950 dark:ring-offset-gray-950 dark:placeholder:text-gray-400 dark:focus-visible:ring-indigo-400",
            error && "border-red-500 focus-visible:ring-red-500",
            className
          )}
          ref={ref}
          {...props}
        />
        {error && <p className="mt-1 text-xs text-red-500">{error}</p>}
      </div>
    );
  }
);
Input.displayName = "Input";

export { Input };

File: ./src/components/ui/checkbox.tsx
// src/components/ui/checkbox.tsx
import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";
import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-gray-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-indigo-600 data-[state=checked]:text-white dark:border-gray-700 dark:data-[state=checked]:bg-indigo-500",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className="flex items-center justify-center">
      <Check className="h-3 w-3" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));

Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

File: ./src/components/ui/alert.tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-red-500/50 text-red-700 dark:border-red-500 [&>svg]:text-red-500 bg-red-50",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
);

export interface AlertProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof alertVariants> {}

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(
  ({ className, variant, ...props }, ref) => (
    <div
      ref={ref}
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
);
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };

File: ./src/lib/feature-authorization.ts
import { PlanType, Role } from "@prisma/client";

// Define all available features
export enum Feature {
  // Standard features - available to all plans
  PRODUCTS_MANAGEMENT = "products_management",
  CATEGORIES_MANAGEMENT = "categories_management",
  ORDERS_VIEW = "orders_view",
  CUSTOMERS_VIEW = "customers_view",
  SHOP_SETTINGS = "shop_settings",

  // Advanced features - available to ADVANCED and PREMIUM plans
  INVOICE_GENERATION = "invoice_generation",
  ADVANCED_ANALYTICS = "advanced_analytics",
  INVENTORY_ALERTS = "inventory_alerts",
  NOTIFICATIONS = "notifications",
  CUSTOM_DOMAIN = "custom_domain",

  // Premium features - available only to PREMIUM plan
  AI_PREDICTIONS = "ai_predictions",
  API_ACCESS = "api_access",
  CUSTOM_BRANDING = "custom_branding",
  PRIORITY_SUPPORT = "priority_support",
  BULK_OPERATIONS = "bulk_operations",
}

// Define feature availability by plan
const PLAN_FEATURES: Record<string, Set<Feature>> = {
  STANDARD: new Set([
    Feature.PRODUCTS_MANAGEMENT,
    Feature.CATEGORIES_MANAGEMENT,
    Feature.ORDERS_VIEW,
    Feature.CUSTOMERS_VIEW,
    Feature.SHOP_SETTINGS,
  ]),

  ADVANCED: new Set([
    // Include all STANDARD features
    Feature.PRODUCTS_MANAGEMENT,
    Feature.CATEGORIES_MANAGEMENT,
    Feature.ORDERS_VIEW,
    Feature.CUSTOMERS_VIEW,
    Feature.SHOP_SETTINGS,

    // Add ADVANCED features
    Feature.INVOICE_GENERATION,
    Feature.ADVANCED_ANALYTICS,
    Feature.INVENTORY_ALERTS,
    Feature.NOTIFICATIONS,
    Feature.CUSTOM_DOMAIN,
  ]),

  PREMIUM: new Set([
    // Include all STANDARD and ADVANCED features
    Feature.PRODUCTS_MANAGEMENT,
    Feature.CATEGORIES_MANAGEMENT,
    Feature.ORDERS_VIEW,
    Feature.CUSTOMERS_VIEW,
    Feature.SHOP_SETTINGS,
    Feature.INVOICE_GENERATION,
    Feature.ADVANCED_ANALYTICS,
    Feature.INVENTORY_ALERTS,
    Feature.NOTIFICATIONS,
    Feature.CUSTOM_DOMAIN,

    // Add PREMIUM features
    Feature.AI_PREDICTIONS,
    Feature.API_ACCESS,
    Feature.CUSTOM_BRANDING,
    Feature.PRIORITY_SUPPORT,
    Feature.BULK_OPERATIONS,
  ]),
};

// Define feature limits by plan
export const PLAN_LIMITS = {
  STANDARD: {
    maxProducts: 100,
    maxCategories: 20,
    maxVariantsPerProduct: 10,
  },
  ADVANCED: {
    maxProducts: 1000,
    maxCategories: 100,
    maxVariantsPerProduct: 30,
  },
  PREMIUM: {
    maxProducts: -1, // Unlimited
    maxCategories: -1, // Unlimited
    maxVariantsPerProduct: -1, // Unlimited
  },
};

// Define role features
const ROLE_ACCESS: Record<string, Record<Feature, boolean>> = {
  SHOP_ADMIN: {
    // Shop admins can access all features available to their plan
    [Feature.PRODUCTS_MANAGEMENT]: true,
    [Feature.CATEGORIES_MANAGEMENT]: true,
    [Feature.ORDERS_VIEW]: true,
    [Feature.CUSTOMERS_VIEW]: true,
    [Feature.SHOP_SETTINGS]: true,
    [Feature.INVOICE_GENERATION]: true,
    [Feature.ADVANCED_ANALYTICS]: true,
    [Feature.INVENTORY_ALERTS]: true,
    [Feature.NOTIFICATIONS]: true,
    [Feature.CUSTOM_DOMAIN]: true,
    [Feature.AI_PREDICTIONS]: true,
    [Feature.API_ACCESS]: true,
    [Feature.CUSTOM_BRANDING]: true,
    [Feature.PRIORITY_SUPPORT]: true,
    [Feature.BULK_OPERATIONS]: true,
  },

  SHOP_STAFF: {
    // Staff have limited access
    [Feature.PRODUCTS_MANAGEMENT]: true,
    [Feature.CATEGORIES_MANAGEMENT]: true,
    [Feature.ORDERS_VIEW]: true,
    [Feature.CUSTOMERS_VIEW]: true,
    [Feature.SHOP_SETTINGS]: false, // Cannot modify shop settings
    [Feature.INVOICE_GENERATION]: true,
    [Feature.ADVANCED_ANALYTICS]: true,
    [Feature.INVENTORY_ALERTS]: true,
    [Feature.NOTIFICATIONS]: true,
    [Feature.CUSTOM_DOMAIN]: false, // Cannot modify domain settings
    [Feature.AI_PREDICTIONS]: true,
    [Feature.API_ACCESS]: false, // Cannot access API
    [Feature.CUSTOM_BRANDING]: false, // Cannot modify branding
    [Feature.PRIORITY_SUPPORT]: true,
    [Feature.BULK_OPERATIONS]: true,
  },

  CUSTOMER: {
    // Customers have no access to these features
    [Feature.PRODUCTS_MANAGEMENT]: false,
    [Feature.CATEGORIES_MANAGEMENT]: false,
    [Feature.ORDERS_VIEW]: false,
    [Feature.CUSTOMERS_VIEW]: false,
    [Feature.SHOP_SETTINGS]: false,
    [Feature.INVOICE_GENERATION]: false,
    [Feature.ADVANCED_ANALYTICS]: false,
    [Feature.INVENTORY_ALERTS]: false,
    [Feature.NOTIFICATIONS]: false,
    [Feature.CUSTOM_DOMAIN]: false,
    [Feature.AI_PREDICTIONS]: false,
    [Feature.API_ACCESS]: false,
    [Feature.CUSTOM_BRANDING]: false,
    [Feature.PRIORITY_SUPPORT]: false,
    [Feature.BULK_OPERATIONS]: false,
  },

  SUPER_ADMIN: {
    // Super admins have access to everything
    [Feature.PRODUCTS_MANAGEMENT]: true,
    [Feature.CATEGORIES_MANAGEMENT]: true,
    [Feature.ORDERS_VIEW]: true,
    [Feature.CUSTOMERS_VIEW]: true,
    [Feature.SHOP_SETTINGS]: true,
    [Feature.INVOICE_GENERATION]: true,
    [Feature.ADVANCED_ANALYTICS]: true,
    [Feature.INVENTORY_ALERTS]: true,
    [Feature.NOTIFICATIONS]: true,
    [Feature.CUSTOM_DOMAIN]: true,
    [Feature.AI_PREDICTIONS]: true,
    [Feature.API_ACCESS]: true,
    [Feature.CUSTOM_BRANDING]: true,
    [Feature.PRIORITY_SUPPORT]: true,
    [Feature.BULK_OPERATIONS]: true,
  },
};

interface User {
  role: string;
  planType?: string | null;
  shopId?: string | null;
}

/**
 * Check if a user has access to a specific feature
 */
export function hasFeatureAccess(
  user: User | null | undefined,
  feature: Feature
): boolean {
  if (!user) return false;

  // Super admins always have access to every feature
  if (user.role === "SUPER_ADMIN") {
    return true;
  }

  // Check if user has a shop, except for SUPER_ADMIN
  if (!user.shopId && user.role !== "SUPER_ADMIN") {
    return false;
  }

  // Check if the user's role has access to the feature
  const roleAccess = ROLE_ACCESS[user.role]?.[feature] || false;

  // If role doesn't have access, deny immediately
  if (!roleAccess) {
    return false;
  }

  // Check if the feature is included in the user's plan
  const planType = user.planType || "STANDARD"; // Default to STANDARD if not specified
  const planFeatures = PLAN_FEATURES[planType];

  // Return whether the feature is available in the user's plan
  return planFeatures?.has(feature) || false;
}

/**
 * Check if user is within plan limits
 */
export function isWithinPlanLimits(
  user: User | null | undefined,
  limit: keyof typeof PLAN_LIMITS.STANDARD,
  currentCount: number
): boolean {
  if (!user || !user.planType) return false;

  const planLimits =
    PLAN_LIMITS[user.planType as keyof typeof PLAN_LIMITS] ||
    PLAN_LIMITS.STANDARD;
  const maxLimit = planLimits[limit];

  // -1 means unlimited
  if (maxLimit === -1) return true;

  return currentCount < maxLimit;
}

/**
 * Get features available to a user
 */
export function getAvailableFeatures(user: User | null | undefined): Feature[] {
  if (!user) return [];

  // Super admins have access to all features
  if (user.role === "SUPER_ADMIN") {
    return Object.values(Feature);
  }

  // Get features based on plan and filter by role access
  const planType = user.planType || "STANDARD";
  const planFeatures = Array.from(
    PLAN_FEATURES[planType] || PLAN_FEATURES.STANDARD
  );

  // Filter by role access
  return planFeatures.filter(
    (feature) => ROLE_ACCESS[user.role]?.[feature] || false
  );
}

/**
 * Get plan limit for a specific limit type
 */
export function getPlanLimit(
  user: User | null | undefined,
  limit: keyof typeof PLAN_LIMITS.STANDARD
): number {
  if (!user || !user.planType) return PLAN_LIMITS.STANDARD[limit];

  const planLimits =
    PLAN_LIMITS[user.planType as keyof typeof PLAN_LIMITS] ||
    PLAN_LIMITS.STANDARD;

  return planLimits[limit];
}

File: ./src/lib/authorization.ts
// src/lib/authorization.ts
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { PlanType } from "@prisma/client";
import { authOptions } from "./auth";
import { hasFeature } from "./plan-features";
import { db } from "./prisma";

export async function requireAuth(redirectTo = "/login") {
  const session = await getServerSession(authOptions);

  if (!session?.user) {
    redirect(
      `${redirectTo}?callbackUrl=${encodeURIComponent(
        window.location.pathname
      )}`
    );
  }

  return session;
}

export async function requireShopAdmin(redirectTo = "/login") {
  const session = await getServerSession(authOptions);

  if (!session?.user) {
    redirect(
      `${redirectTo}?callbackUrl=${encodeURIComponent(
        window.location.pathname
      )}`
    );
  }

  if (
    !session.user.shopId ||
    (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
  ) {
    redirect("/");
  }

  return session;
}

export async function requireFeature(feature: string, redirectTo = "/admin") {
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login");
  }

  // Get shop to check plan type
  const shop = await db.shop.findUnique({
    where: { id: session.user.shopId },
  });

  if (!shop) {
    redirect("/login");
  }

  // Check if the plan includes this feature
  if (!hasFeature(shop.planType as PlanType, feature as any)) {
    redirect(redirectTo);
  }

  return session;
}

File: ./src/lib/utils.ts
// src/lib/utils.ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatCurrency(amount: number, currency = "USD"): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(amount);
}

export function formatDate(date: Date | string): string {
  const d = typeof date === "string" ? new Date(date) : date;
  return new Intl.DateTimeFormat("en-US", {
    year: "numeric",
    month: "short",
    day: "numeric",
  }).format(d);
}

export function slugify(text: string): string {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .replace(/\s+/g, "-")
    .replace(/&/g, "-and-")
    .replace(/[^\w\-]+/g, "")
    .replace(/\-\-+/g, "-");
}

export function generateOrderNumber(): string {
  const date = new Date();
  const year = date.getFullYear().toString().slice(-2);
  const month = (date.getMonth() + 1).toString().padStart(2, "0");
  const day = date.getDate().toString().padStart(2, "0");
  const random = Math.floor(Math.random() * 10000)
    .toString()
    .padStart(4, "0");

  return `ORD-${year}${month}${day}-${random}`;
}

export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + "...";
}

export function capitalizeFirstLetter(string: string): string {
  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
}

export function getInitials(name: string): string {
  if (!name) return "";

  return name
    .split(" ")
    .map((part) => part.charAt(0).toUpperCase())
    .slice(0, 2)
    .join("");
}

File: ./src/lib/plan-features.ts
import { PlanType } from "@prisma/client";

export interface PlanFeatures {
  maxProducts: number;
  maxCategories: number;
  analytics: boolean;
  advancedReporting: boolean;
  invoiceGeneration: boolean;
  inventoryAlerts: boolean;
  aiPredictions: boolean;
  customDomain: boolean;
  apiAccess: boolean;
  customBranding: boolean;
  prioritySupport: boolean;
}

export const PLAN_FEATURES: Record<PlanType, PlanFeatures> = {
  STANDARD: {
    maxProducts: 100,
    maxCategories: 20,
    analytics: false,
    advancedReporting: false,
    invoiceGeneration: false,
    inventoryAlerts: false,
    aiPredictions: false,
    customDomain: false,
    apiAccess: false,
    customBranding: false,
    prioritySupport: false,
  },
  ADVANCED: {
    maxProducts: 1000,
    maxCategories: 100,
    analytics: true,
    advancedReporting: true,
    invoiceGeneration: true,
    inventoryAlerts: true,
    aiPredictions: false,
    customDomain: true,
    apiAccess: false,
    customBranding: false,
    prioritySupport: false,
  },
  PREMIUM: {
    maxProducts: -1, // Unlimited
    maxCategories: -1, // Unlimited
    analytics: true,
    advancedReporting: true,
    invoiceGeneration: true,
    inventoryAlerts: true,
    aiPredictions: true,
    customDomain: true,
    apiAccess: true,
    customBranding: true,
    prioritySupport: true,
  },
};

export function hasFeature(
  planType: PlanType,
  feature: keyof PlanFeatures
): boolean {
  return PLAN_FEATURES[planType][feature];
}

export function getMaxLimit(
  planType: PlanType,
  limit: "maxProducts" | "maxCategories"
): number {
  return PLAN_FEATURES[planType][limit];
}

export function isWithinLimits(
  planType: PlanType,
  feature: "maxProducts" | "maxCategories",
  currentCount: number
): boolean {
  const limit = getMaxLimit(planType, feature);

  // -1 means unlimited
  if (limit === -1) return true;

  return currentCount < limit;
}

File: ./src/lib/prisma.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const db =
  globalForPrisma.prisma ||
  new PrismaClient({
    log:
      process.env.NODE_ENV === "development"
        ? ["query", "error", "warn"]
        : ["error"],
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = db;

File: ./src/lib/services/categories.service.ts
import { db } from "@/lib/prisma";

export const categoriesService = {
  /**
   * Get all categories for a shop with hierarchy information
   */
  async getCategoriesWithHierarchy(shopId: string) {
    // Get all categories for the shop
    const allCategories = await db.category.findMany({
      where: { shopId },
      select: {
        id: true,
        name: true,
        parentId: true,
      },
    });

    // Function to add level information to categories
    const addLevelToCategories = (
      categories: any[],
      parentId: string | null = null,
      level = 0
    ) => {
      return categories
        .filter((category) => category.parentId === parentId)
        .map((category) => ({
          id: category.id,
          name: category.name,
          level,
          parentId: category.parentId,
        }));
    };

    // Function to create flat array with correct level
    const createFlatCategoriesWithLevels = (categories: any[]) => {
      // First get all root categories (those with no parent)
      let result = addLevelToCategories(categories);

      // For each root category, recursively add its children
      for (let i = 0; i < result.length; i++) {
        const category = result[i];
        const children = addLevelToCategories(
          categories,
          category.id,
          category.level + 1
        );

        // Insert children after their parent
        if (children.length > 0) {
          result.splice(i + 1, 0, ...children);
          // Skip the children we just added
          i += children.length;
        }
      }
      return result;
    };

    return createFlatCategoriesWithLevels(allCategories);
  },

  /**
   * Get simple list of categories for a shop (for filtering)
   */
  async getCategories(shopId: string) {
    return await db.category.findMany({
      where: { shopId },
      select: {
        id: true,
        name: true,
      },
    });
  },

  /**
   * Get a category by ID with product count
   */
  async getCategoryById(categoryId: string, shopId: string) {
    const category = await db.category.findFirst({
      where: {
        id: categoryId,
        shopId,
      },
      include: {
        _count: {
          select: {
            products: true,
            children: true,
          },
        },
      },
    });
    return category;
  },

  /**
   * Get the total product count for a category including all its subcategories
   */
  async getCategoryProductCount(categoryId: string, shopId: string) {
    // First, we need to get all subcategories (recursively)
    const getAllChildCategoryIds = async (
      parentId: string
    ): Promise<string[]> => {
      const childCategories = await db.category.findMany({
        where: { parentId, shopId },
        select: { id: true },
      });

      if (childCategories.length === 0) return [];

      const childIds = childCategories.map((c) => c.id);
      const grandChildIds = await Promise.all(
        childIds.map((id) => getAllChildCategoryIds(id))
      );

      return [...childIds, ...grandChildIds.flat()];
    };

    // Get all category IDs in the hierarchy
    const childCategoryIds = await getAllChildCategoryIds(categoryId);
    const allCategoryIds = [categoryId, ...childCategoryIds];

    // Count products in all those categories
    const totalProducts = await db.product.count({
      where: {
        categories: {
          some: {
            id: {
              in: allCategoryIds,
            },
          },
        },
        shopId,
      },
    });

    return totalProducts;
  },

  /**
   * Create a new category
   */
  async createCategory(data: any, shopId: string) {
    // Add shop ID to the data
    const categoryData = { ...data, shopId };

    // Check if slug already exists
    const existingCategory = await db.category.findFirst({
      where: {
        shopId,
        slug: data.slug,
      },
    });

    if (existingCategory) {
      throw new Error("A category with this slug already exists");
    }

    // Check if we're not exceeding nesting levels (max 3 levels)
    if (data.parentId) {
      const parentCategory = await db.category.findFirst({
        where: {
          id: data.parentId,
          shopId,
        },
        include: {
          parent: true,
        },
      });

      if (parentCategory?.parent?.parent) {
        throw new Error("Maximum category nesting level (3) exceeded");
      }
    }

    return await db.category.create({
      data: categoryData,
    });
  },

  /**
   * Update an existing category
   */
  async updateCategory(categoryId: string, shopId: string, data: any) {
    // Verify the category exists and belongs to this shop
    const category = await db.category.findFirst({
      where: {
        id: categoryId,
        shopId,
      },
    });

    if (!category) {
      throw new Error("Category not found");
    }

    // Check if slug already exists (except for this category)
    if (data.slug !== category.slug) {
      const existingCategory = await db.category.findFirst({
        where: {
          shopId,
          slug: data.slug,
          id: {
            not: categoryId,
          },
        },
      });

      if (existingCategory) {
        throw new Error("A category with this slug already exists");
      }
    }

    // Check for circular reference
    if (data.parentId && data.parentId !== category.parentId) {
      // Check if the new parent is not a child of this category
      const isCircular = await this.isCircularReference(
        shopId,
        categoryId,
        data.parentId
      );

      if (isCircular) {
        throw new Error(
          "Cannot set a subcategory as the parent (circular reference)"
        );
      }

      // Check nesting level
      const parentCategory = await db.category.findFirst({
        where: {
          id: data.parentId,
          shopId,
        },
        include: {
          parent: true,
        },
      });

      if (parentCategory?.parent?.parent) {
        throw new Error("Maximum category nesting level (3) exceeded");
      }
    }

    return await db.category.update({
      where: { id: categoryId },
      data,
    });
  },

  /**
   * Delete a category
   */
  async deleteCategory(categoryId: string, shopId: string) {
    // Verify the category exists and belongs to this shop
    const category = await db.category.findFirst({
      where: {
        id: categoryId,
        shopId,
      },
      include: {
        _count: {
          select: {
            children: true,
            products: true,
          },
        },
      },
    });

    if (!category) {
      throw new Error("Category not found");
    }

    // Check if it has children
    if (category._count.children > 0) {
      throw new Error("Cannot delete a category that has subcategories");
    }

    // Check if it has products
    if (category._count.products > 0) {
      throw new Error("Cannot delete a category that has products");
    }

    // Delete the category
    return await db.category.delete({
      where: { id: categoryId },
    });
  },

  /**
   * Check if setting parentId would create a circular reference
   */
  async isCircularReference(
    shopId: string,
    categoryId: string,
    newParentId: string
  ): Promise<boolean> {
    let currentParentId = newParentId;

    // Navigate up the tree until we either find the category or reach a root
    while (currentParentId) {
      // If we find the category ID, it's a circular reference
      if (currentParentId === categoryId) {
        return true;
      }

      // Get the next parent up the tree
      const parent = await db.category.findFirst({
        where: {
          id: currentParentId,
          shopId,
        },
        select: { parentId: true },
      });

      // If we reached a root or the parent doesn't exist, stop
      if (!parent || !parent.parentId) {
        break;
      }

      // Move up the tree
      currentParentId = parent.parentId;
    }

    // If we got here, no circular reference was found
    return false;
  },

  /**
   * Get categories with full data including product counts
   */
  async getCategoriesWithCounts(shopId: string, withProductCount = false) {
    // Get all categories with basic counts
    const categories = await db.category.findMany({
      where: { shopId },
      include: {
        _count: {
          select: {
            children: true,
            products: true,
          },
        },
      },
      orderBy: {
        name: "asc",
      },
    });

    // Add level information
    const withLevels = await this.addLevelsToCategories(categories);

    // If total product counts are requested, add them for each category
    if (withProductCount) {
      const withTotalCounts = await Promise.all(
        withLevels.map(async (category) => {
          const totalProducts = await this.getCategoryProductCount(
            category.id,
            shopId
          );
          return {
            ...category,
            totalProducts,
          };
        })
      );

      return withTotalCounts;
    }

    return withLevels;
  },

  /**
   * Add level information to all categories based on their hierarchy
   */
  async addLevelsToCategories(categories: any[]) {
    try {
      // Create a map for quick lookups
      const categoryMap = new Map();
      categories.forEach((category) => {
        categoryMap.set(category.id, category);
      });

      // Assign levels based on parent relationships
      const result = categories.map((category) => {
        let level = 0;
        let current = category;
        let parentId = current.parentId;

        // Navigate up the tree to determine level
        while (parentId) {
          level++;
          const parent = categoryMap.get(parentId);
          // Handle case where parent doesn't exist in our map
          if (!parent) break;
          parentId = parent.parentId;
        }

        return {
          ...category,
          level,
        };
      });

      // Sort hierarchically for display
      const sortedResult = [...result].sort((a, b) => {
        // First by level (root categories first)
        if (a.level !== b.level) return a.level - b.level;

        // Then by parent ID for same level categories
        if (a.parentId !== b.parentId) {
          if (a.parentId === null) return -1;
          if (b.parentId === null) return 1;
          return a.parentId.localeCompare(b.parentId);
        }

        // Finally by name for categories with the same parent
        return a.name.localeCompare(b.name);
      });

      return sortedResult;
    } catch (error) {
      console.error("Error adding levels to categories:", error);
      // Return the original array if something goes wrong
      return categories.map((category) => ({
        ...category,
        level: 0, // Default to level 0
      }));
    }
  },
};

File: ./src/lib/services/index.ts
export * from "./categories.service";
export * from "./products.service";
export * from "./shop.service";
export * from "./orders.service";
export * from "./users.service";

File: ./src/lib/services/users.service.ts
// src/lib/services/users.service.ts
import { db } from "@/lib/prisma";

export const usersService = {
  /**
   * Get a user by ID with validation that they belong to a shop
   */
  async getUserById(userId: string, shopId: string) {
    return await db.user.findUnique({
      where: {
        id: userId,
        shopId, // Ensure it belongs to this shop
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
      },
    });
  },

  /**
   * Search users by name or email within a shop
   */
  async searchUsers(query: string, shopId: string, limit = 10) {
    return await db.user.findMany({
      where: {
        shopId,
        OR: [
          { name: { contains: query, mode: "insensitive" } },
          { email: { contains: query, mode: "insensitive" } },
        ],
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
      },
      take: limit,
    });
  },

  /**
   * Get total users count for a shop
   */
  async getTotalUsers(shopId: string, role?: string) {
    return await db.user.count({
      where: {
        shopId,
        ...(role ? { role } : {}),
      },
    });
  },

  /**
   * Get users with pagination and filtering
   */
  async getUsers(
    shopId: string,
    {
      page = 1,
      perPage = 10,
      search = "",
      role = "",
      sortBy = "createdAt",
      sortOrder = "desc",
    }: {
      page: number;
      perPage: number;
      search?: string;
      role?: string;
      sortBy?: string;
      sortOrder?: "asc" | "desc";
    }
  ) {
    const skip = (page - 1) * perPage;

    const where: any = { shopId };

    // Add search filter
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
      ];
    }

    // Add role filter
    if (role) {
      where.role = role;
    }

    return await db.user.findMany({
      where,
      orderBy: {
        [sortBy]: sortOrder,
      },
      skip,
      take: perPage,
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
        orders: {
          select: {
            id: true,
          },
          take: 1,
        },
        _count: {
          select: {
            orders: true,
          },
        },
      },
    });
  },
};

File: ./src/lib/services/orders.service.ts
import { db } from "@/lib/prisma";

export type OrdersFilter = {
  shopId: string;
  search?: string;
  status?: string;
  paymentStatus?: string;
  dateFrom?: Date;
  dateTo?: Date;
  customerId?: string;
  productId?: string;
};

export type OrdersSortOptions = {
  sortField: string;
  sortOrder: "asc" | "desc";
};

export type OrdersPagination = {
  page: number;
  perPage: number;
};

export const ordersService = {
  /**
   * Get total orders count based on filters
   */
  async getTotalOrders(filters: OrdersFilter): Promise<number> {
    const where: any = { shopId: filters.shopId };

    if (filters.search) {
      where.OR = [
        { orderNumber: { contains: filters.search, mode: "insensitive" } },
        { user: { name: { contains: filters.search, mode: "insensitive" } } },
        { user: { email: { contains: filters.search, mode: "insensitive" } } },
      ];
    }

    if (filters.status) {
      where.status = filters.status;
    }

    if (filters.paymentStatus) {
      where.paymentStatus = filters.paymentStatus;
    }

    if (filters.customerId) {
      where.userId = filters.customerId;
    }

    if (filters.productId) {
      where.items = {
        some: { productId: filters.productId },
      };
    }

    if (filters.dateFrom) {
      where.createdAt = {
        ...(where.createdAt || {}),
        gte: filters.dateFrom,
      };
    }

    if (filters.dateTo) {
      where.createdAt = {
        ...(where.createdAt || {}),
        lte: filters.dateTo,
      };
    }

    return await db.order.count({ where });
  },

  /**
   * Get orders with pagination, filtering and sorting
   */
  async getOrders(
    filters: OrdersFilter,
    pagination: OrdersPagination = { page: 1, perPage: 10 },
    sort: OrdersSortOptions = { sortField: "createdAt", sortOrder: "desc" }
  ) {
    const page =
      Number.isFinite(pagination?.page) && pagination.page > 0
        ? pagination.page
        : 1;
    const perPage =
      Number.isFinite(pagination?.perPage) && pagination.perPage > 0
        ? pagination.perPage
        : 10;

    const skip = (page - 1) * perPage;
    const take = perPage;

    const where: any = { shopId: filters.shopId };

    if (filters.search) {
      where.OR = [
        { orderNumber: { contains: filters.search, mode: "insensitive" } },
        { user: { name: { contains: filters.search, mode: "insensitive" } } },
        { user: { email: { contains: filters.search, mode: "insensitive" } } },
      ];
    }

    if (filters.status) {
      where.status = filters.status;
    }

    if (filters.paymentStatus) {
      where.paymentStatus = filters.paymentStatus;
    }

    if (filters.customerId) {
      where.userId = filters.customerId;
    }

    if (filters.productId) {
      where.items = {
        some: { productId: filters.productId },
      };
    }

    if (filters.dateFrom) {
      where.createdAt = {
        ...(where.createdAt || {}),
        gte: filters.dateFrom,
      };
    }

    if (filters.dateTo) {
      where.createdAt = {
        ...(where.createdAt || {}),
        lte: filters.dateTo,
      };
    }

    return await db.order.findMany({
      where,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                images: true,
              },
            },
          },
          take: 5,
        },
        address: true,
        invoice: {
          select: {
            id: true,
            invoiceNumber: true,
          },
        },
        _count: {
          select: {
            items: true,
          },
        },
      },
      orderBy: {
        [sort.sortField]: sort.sortOrder,
      },
      skip,
      take,
    });
  },

  /**
   * Get order by id
   */
  async getOrderById(orderId: string, shopId: string) {
    return await db.order.findFirst({
      where: {
        id: orderId,
        shopId, // Ensure it belongs to this shop
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                images: true,
                slug: true,
              },
            },
            variant: {
              select: {
                id: true,
                name: true,
                options: true,
              },
            },
          },
        },
        address: true,
        invoice: true,
      },
    });
  },

  /**
   * Get order statistics
   */
  async getOrderStats(shopId: string) {
    // Get count of orders by status
    const statusCounts = await db.$queryRaw`
      SELECT status, COUNT(*) as count
      FROM "Order"
      WHERE "shopId" = ${shopId}
      GROUP BY status
    `;

    // Get count of orders by payment status
    const paymentStatusCounts = await db.$queryRaw`
      SELECT "paymentStatus", COUNT(*) as count
      FROM "Order"
      WHERE "shopId" = ${shopId}
      GROUP BY "paymentStatus"
    `;

    // Get total revenue
    const revenueResult = await db.$queryRaw`
      SELECT SUM(total) as totalRevenue
      FROM "Order"
      WHERE "shopId" = ${shopId}
      AND status != 'CANCELLED'
      AND status != 'REFUNDED'
    `;

    // Get revenue for current month
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    const monthlyRevenueResult = await db.$queryRaw`
      SELECT SUM(total) as monthlyRevenue
      FROM "Order"
      WHERE "shopId" = ${shopId}
      AND status != 'CANCELLED'
      AND status != 'REFUNDED'
      AND "createdAt" >= ${firstDayOfMonth}
    `;

    return {
      statusCounts: statusCounts || [],
      paymentStatusCounts: paymentStatusCounts || [],
      totalRevenue: revenueResult[0]?.totalrevenue || 0,
      monthlyRevenue: monthlyRevenueResult[0]?.monthlyrevenue || 0,
    };
  },

  /**
   * Update order status
   */
  async updateOrderStatus(
    orderId: string,
    shopId: string,
    data: {
      status?: string;
      paymentStatus?: string;
      shippingStatus?: string;
      notes?: string;
    }
  ) {
    // First check if order exists and belongs to shop
    const order = await db.order.findFirst({
      where: {
        id: orderId,
        shopId,
      },
      select: {
        id: true,
        status: true,
        paymentStatus: true,
        shippingStatus: true,
        userId: true,
        orderNumber: true,
      },
    });

    if (!order) {
      throw new Error("Order not found");
    }

    // Validate status values against enums
    if (
      data.status &&
      ![
        "PENDING",
        "PROCESSING",
        "SHIPPED",
        "DELIVERED",
        "CANCELLED",
        "REFUNDED",
      ].includes(data.status)
    ) {
      throw new Error("Invalid order status");
    }

    if (
      data.paymentStatus &&
      !["PENDING", "PAID", "FAILED", "REFUNDED", "PARTIALLY_REFUNDED"].includes(
        data.paymentStatus
      )
    ) {
      throw new Error("Invalid payment status");
    }

    if (
      data.shippingStatus &&
      !["PENDING", "PROCESSING", "SHIPPED", "DELIVERED", "RETURNED"].includes(
        data.shippingStatus
      )
    ) {
      throw new Error("Invalid shipping status");
    }

    // Update the order
    const updatedOrder = await db.order.update({
      where: { id: orderId },
      data: {
        status: (data.status as any) || undefined,
        paymentStatus: (data.paymentStatus as any) || undefined,
        shippingStatus: (data.shippingStatus as any) || undefined,
        notes: data.notes !== undefined ? data.notes : undefined,
        updatedAt: new Date(),
      },
    });

    // Create notification if status changed
    if (data.status && data.status !== order.status) {
      await db.notification.create({
        data: {
          title: `Order ${order.orderNumber} Updated`,
          message: `Your order status has been updated to ${data.status}`,
          type: "ORDER_UPDATE",
          userId: order.userId,
          shopId,
        },
      });
    }

    // Handle inventory updates when order status changes to CANCELLED or REFUNDED
    if (
      (data.status === "CANCELLED" || data.status === "REFUNDED") &&
      order.status !== "CANCELLED" &&
      order.status !== "REFUNDED"
    ) {
      // Fetch order items to restore inventory
      const orderItems = await db.orderItem.findMany({
        where: { orderId },
        select: {
          productId: true,
          variantId: true,
          quantity: true,
        },
      });

      // Restore inventory for each item
      for (const item of orderItems) {
        if (item.variantId) {
          // Restore variant inventory
          await db.productVariant.update({
            where: { id: item.variantId },
            data: {
              inventory: {
                increment: item.quantity,
              },
            },
          });
        } else if (item.productId) {
          // Restore product inventory
          await db.product.update({
            where: { id: item.productId },
            data: {
              inventory: {
                increment: item.quantity,
              },
            },
          });
        }
      }
    }

    return updatedOrder;
  },
};

File: ./src/lib/services/s3-image.service.ts
// src/lib/services/s3-image.service.ts
import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

// Configure S3 client
const s3Client = new S3Client({
  region: process.env.AWS_REGION || "eu-west-3",
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || "",
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || "",
  },
});

const bucketName = process.env.AWS_S3_BUCKET_NAME || "your-store-bucket";

export interface UploadedImage {
  key: string; // S3 object key/filename
  url: string; // Full URL to access the image
  originalName: string; // Original filename
}

export const s3ImageService = {
  /**
   * Generates a unique filename for S3
   * @param originalName Original file name
   * @param prefix Optional prefix for organization (e.g., 'categories', 'products')
   */
  generateImageName(originalName: string, prefix?: string): string {
    // Get file extension
    const fileExt = originalName.split(".").pop() || "jpg";

    // Create unique ID
    const uniqueId = `${Date.now()}-${Math.random()
      .toString(36)
      .substring(2, 15)}`;

    // Create final filename
    return prefix
      ? `${prefix}/${uniqueId}.${fileExt}`
      : `${uniqueId}.${fileExt}`;
  },

  /**
   * Uploads a base64 image to S3
   * @param base64Image Base64 encoded image data
   * @param originalName Original filename
   * @param prefix Optional prefix for organization
   */
  async uploadImage(
    base64Image: string,
    originalName: string,
    prefix?: string
  ): Promise<UploadedImage> {
    // Remove data URL prefix if present
    const base64Data = base64Image.replace(/^data:image\/\w+;base64,/, "");

    // Convert base64 to buffer
    const buffer = Buffer.from(base64Data, "base64");

    // Generate unique key/filename
    const key = this.generateImageName(originalName, prefix);

    // Determine content type from base64 string or fall back to jpeg
    const contentType = base64Image.match(/^data:image\/(\w+);base64,/)?.[1]
      ? `image/${base64Image.match(/^data:image\/(\w+);base64,/)?.[1]}`
      : "image/jpeg";

    // Upload to S3
    const command = new PutObjectCommand({
      Bucket: bucketName,
      Key: key,
      Body: buffer,
      ContentType: contentType,
      ContentEncoding: "base64",
    });

    await s3Client.send(command);

    // Generate URL
    const url = `https://${bucketName}.s3.amazonaws.com/${key}`;

    return {
      key,
      url,
      originalName,
    };
  },

  /**
   * Get a presigned URL for an image (URLs valid for limited time)
   * @param key S3 object key
   * @param expiresIn Expiration time in seconds (default: 3600)
   */
  async getImageUrl(key: string, expiresIn = 3600): Promise<string> {
    try {
      const command = new GetObjectCommand({
        Bucket: bucketName,
        Key: key,
      });

      return await getSignedUrl(s3Client, command, { expiresIn });
    } catch (error) {
      console.error("Error generating presigned URL:", error);
      // Return a fallback URL if there's an error
      return `https://${bucketName}.s3.amazonaws.com/${key}`;
    }
  },

  /**
   * Delete an image from S3
   * @param key S3 object key
   */
  async deleteImage(key: string): Promise<boolean> {
    try {
      const command = new DeleteObjectCommand({
        Bucket: bucketName,
        Key: key,
      });

      await s3Client.send(command);
      return true;
    } catch (error) {
      console.error("Error deleting image from S3:", error);
      return false;
    }
  },

  /**
   * Get public URL for an image (no expiration)
   * @param key S3 object key
   */
  getPublicImageUrl(key: string): string {
    return `https://${bucketName}.s3.amazonaws.com/${key}`;
  },

  /**
   * Checks if a string is a valid S3 key
   * @param key Possible S3 key to check
   */
  isS3Key(key: string): boolean {
    // Simple validation - check if it's not a full URL and doesn't start with data:
    return !!key && !key.startsWith("data:") && !key.startsWith("http");
  },

  /**
   * Extracts the key from a full S3 URL
   * @param url Full S3 URL
   */
  extractKeyFromUrl(url: string): string | null {
    // Extract the key from a URL like https://bucket-name.s3.amazonaws.com/key
    const match = url.match(/https?:\/\/[^/]+\/(.+)/);
    return match ? match[1] : null;
  },
};

// Export default instance
export default s3ImageService;

File: ./src/lib/services/shop.service.ts
// src/lib/services/shop.service.ts
import { db } from "@/lib/prisma";

export const shopService = {
  /**
   * Get shop by subdomain
   */
  async getShopBySubdomain(subdomain: string) {
    return await db.shop.findUnique({
      where: { subdomain },
      include: {
        settings: true,
      },
    });
  },

  /**
   * Get shop by ID
   */
  async getShopById(shopId: string) {
    return await db.shop.findUnique({
      where: { id: shopId },
      include: {
        settings: true,
      },
    });
  },

  /**
   * Get shop settings
   */
  async getShopSettings(shopId: string) {
    return await db.shopSettings.findUnique({
      where: { shopId },
    });
  },

  /**
   * Check if shop exists
   */
  async shopExists(shopId: string): Promise<boolean> {
    const count = await db.shop.count({
      where: { id: shopId },
    });
    return count > 0;
  },
};

File: ./src/lib/services/products.service.ts
// src/lib/services/products.service.ts (Updated with getProductById)
import { db } from "@/lib/prisma";
import { s3ImageService } from "@/lib/services/s3-image.service";

export interface ProductsFilter {
  shopId: string;
  search?: string;
  categoryId?: string;
  inStock?: boolean;
  lowStock?: boolean;
  expiringSoon?: boolean;
  lowStockThreshold?: number;
}

export interface ProductsSortOptions {
  sortField: string;
  sortOrder: "asc" | "desc";
}

export interface ProductsPagination {
  page: number;
  perPage: number;
}

export const productsService = {
  /**
   * Get total products count based on filters
   */
  async getTotalProducts(filters: ProductsFilter): Promise<number> {
    const where: any = { shopId: filters.shopId };

    if (filters.search) {
      where.OR = [
        { name: { contains: filters.search, mode: "insensitive" } },
        { description: { contains: filters.search, mode: "insensitive" } },
        { sku: { contains: filters.search, mode: "insensitive" } },
        { barcode: { contains: filters.search, mode: "insensitive" } },
      ];
    }

    if (filters.categoryId) {
      where.categories = {
        some: { id: filters.categoryId },
      };
    }

    if (filters.inStock) {
      where.inventory = { gt: 0 };
    }

    if (filters.lowStock) {
      where.inventory = { lte: filters.lowStockThreshold || 5 };
    }

    if (filters.expiringSoon) {
      // Products expiring in the next 30 days
      const today = new Date();
      const thirtyDaysLater = new Date();
      thirtyDaysLater.setDate(today.getDate() + 30);

      where.expiryDate = {
        gte: today,
        lte: thirtyDaysLater,
      };
    }

    return await db.product.count({ where });
  },

  /**
   * Get products with pagination, filtering and sorting
   */
  async getProducts(
    filters: ProductsFilter,
    pagination: ProductsPagination,
    sort: ProductsSortOptions
  ) {
    const where: any = { shopId: filters.shopId };

    if (filters.search) {
      where.OR = [
        { name: { contains: filters.search, mode: "insensitive" } },
        { description: { contains: filters.search, mode: "insensitive" } },
        { sku: { contains: filters.search, mode: "insensitive" } },
        { barcode: { contains: filters.search, mode: "insensitive" } },
      ];
    }

    if (filters.categoryId) {
      where.categories = {
        some: { id: filters.categoryId },
      };
    }

    if (filters.inStock) {
      where.inventory = { gt: 0 };
    }

    if (filters.lowStock) {
      where.inventory = { lte: filters.lowStockThreshold || 5 };
    }

    if (filters.expiringSoon) {
      // Products expiring in the next 30 days
      const today = new Date();
      const thirtyDaysLater = new Date();
      thirtyDaysLater.setDate(today.getDate() + 30);

      where.expiryDate = {
        gte: today,
        lte: thirtyDaysLater,
      };
    }

    const products = await db.product.findMany({
      where,
      include: {
        categories: {
          select: {
            id: true,
            name: true,
            slug: true,
          },
        },
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
        _count: {
          select: {
            variants: true,
            orderItems: true,
          },
        },
        discounts: {
          where: {
            enabled: true,
            startDate: { lte: new Date() },
            endDate: { gte: new Date() },
          },
          select: {
            id: true,
            percentage: true,
          },
          take: 1, // Just get the first active discount
        },
      },
      orderBy: {
        [sort.sortField]: sort.sortOrder,
      },
      skip: (pagination.page - 1) * pagination.perPage,
      take: pagination.perPage,
    });

    // Process images - convert S3 keys to URLs
    const productsWithImageUrls = await Promise.all(
      products.map(async (product) => {
        if (product.images && product.images.length > 0) {
          const processedImages = await Promise.all(
            product.images.map(async (image) => {
              if (s3ImageService.isS3Key(image)) {
                try {
                  return await s3ImageService.getImageUrl(image);
                } catch (error) {
                  console.error(`Error getting image URL for ${image}:`, error);
                  return image; // Return original key if URL generation fails
                }
              }
              return image; // Return original URL if not an S3 key
            })
          );

          return {
            ...product,
            images: processedImages,
            s3Keys: product.images, // Store original keys for reference
          };
        }
        return product;
      })
    );

    return productsWithImageUrls;
  },

  /**
   * Get categories for a shop
   */
  async getCategories(shopId: string) {
    return await db.category.findMany({
      where: { shopId },
      select: {
        id: true,
        name: true,
      },
    });
  },

  /**
   * Get shop settings including low stock threshold
   */
  async getShopSettings(shopId: string) {
    return await db.shopSettings.findUnique({
      where: { shopId },
      select: { lowStockThreshold: true },
    });
  },

  /**
   * Get product statistics
   */
  async getProductStats(shopId: string, lowStockThreshold: number) {
    try {
      // Use a safer approach that doesn't return BigInt directly
      const products = await db.product.findMany({
        where: { shopId },
        select: { inventory: true },
      });

      // Calculate statistics manually
      let totalInventory = 0;
      let lowStockCount = 0;
      let outOfStockCount = 0;

      products.forEach((product) => {
        totalInventory += product.inventory;
        if (product.inventory <= lowStockThreshold) lowStockCount++;
        if (product.inventory === 0) outOfStockCount++;
      });

      return {
        totalInventory,
        lowStockCount,
        outOfStockCount,
      };
    } catch (error) {
      console.error("Error getting product stats:", error);
      // Return safe default values
      return {
        totalInventory: 0,
        lowStockCount: 0,
        outOfStockCount: 0,
      };
    }
  },

  /**
   * Get a product by ID with validation that it belongs to a shop
   */
  async getProductById(productId: string, shopId: string) {
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId, // Ensure it belongs to this shop
      },
      include: {
        categories: true,
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
      },
    });

    if (!product) {
      return null;
    }

    // Process S3 image URLs
    let productWithUrls = { ...product };
    if (product.images && product.images.length > 0) {
      try {
        const processedImages = await Promise.all(
          product.images.map(async (image) => {
            if (s3ImageService.isS3Key(image)) {
              try {
                return await s3ImageService.getImageUrl(image);
              } catch (error) {
                console.error(`Error getting image URL for ${image}:`, error);
                return image; // Return original key if URL generation fails
              }
            }
            return image; // Return original URL if not an S3 key
          })
        );

        productWithUrls = {
          ...product,
          images: processedImages,
          s3Keys: product.images, // Store original keys for reference
        };
      } catch (error) {
        console.error("Error processing product images:", error);
        // Continue with original product if image processing fails
      }
    }

    return productWithUrls;
  },

  /**
   * Process images for a product - handles S3 uploads and URL generation
   */
  async processProductImages(
    images: string[],
    productSlug: string
  ): Promise<string[]> {
    const processedImages = [];

    if (images && images.length > 0) {
      for (const image of images) {
        if (image.startsWith("data:")) {
          try {
            // Upload base64 image to S3
            const fileName = `${productSlug}-${Date.now()}`;
            const uploadResult = await s3ImageService.uploadImage(
              image,
              `${fileName}.jpg`,
              "products"
            );
            processedImages.push(uploadResult.key);
          } catch (error) {
            console.error("Error uploading image to S3:", error);
            // Skip this image if upload fails
          }
        } else {
          // Keep existing image URLs or S3 keys
          processedImages.push(image);
        }
      }
    }

    return processedImages;
  },

  /**
   * Delete product images from S3
   */
  async deleteProductImages(images: string[]): Promise<void> {
    if (!images || images.length === 0) return;

    const s3Images = images.filter((image) => s3ImageService.isS3Key(image));

    for (const imageKey of s3Images) {
      try {
        await s3ImageService.deleteImage(imageKey);
        console.log(`Deleted product image from S3: ${imageKey}`);
      } catch (error) {
        console.error(
          `Error deleting product image ${imageKey} from S3:`,
          error
        );
        // Continue with next image even if deletion fails
      }
    }
  },

  /**
   * Generate S3 image URLs for product images
   */
  async getProductImageUrls(images: string[]): Promise<string[]> {
    if (!images || images.length === 0) return [];

    const processedImages = await Promise.all(
      images.map(async (image) => {
        if (s3ImageService.isS3Key(image)) {
          try {
            return await s3ImageService.getImageUrl(image);
          } catch (error) {
            console.error(`Error getting image URL for ${image}:`, error);
            return image; // Return original key if URL generation fails
          }
        }
        return image; // Return original URL if not an S3 key
      })
    );

    return processedImages;
  },
};

File: ./src/lib/subdomain.ts
import { NextRequest } from "next/server";

export function getSubdomain(req: NextRequest): string | null {
  // For local development, always use the environment variable
  if (process.env.NODE_ENV === "development") {
    return process.env.SHOP_SUBDOMAIN || null;
  }

  // Get host from request headers
  const host = req.headers.get("host");
  if (!host) return null;

  // Extract subdomain from host
  const parts = host.split(".");
  if (parts.length > 2) {
    return parts[0];
  }

  return null;
}

File: ./src/lib/auth.ts
// src/lib/auth.ts
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import { compare } from "bcrypt";
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { db } from "@/lib/prisma";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(db),
  session: {
    strategy: "jwt",
  },
  pages: {
    signIn: "/login",
  },
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
        shopSubdomain: { label: "Shop Subdomain", type: "text" }, // Hidden field for subdomain
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        // Determine which shop to check based on subdomain (if provided)
        const shopQuery = credentials.shopSubdomain
          ? { subdomain: credentials.shopSubdomain }
          : undefined;

        // Find the user with optional shop filtering
        const user = await db.user.findUnique({
          where: {
            email: credentials.email,
          },
          include: {
            shop: {
              select: {
                id: true,
                name: true,
                subdomain: true,
                planType: true,
                active: true,
              },
            },
          },
        });

        if (!user) {
          return null;
        }

        // If a specific shop subdomain was requested, verify the user belongs to that shop
        if (
          credentials.shopSubdomain &&
          user.shop?.subdomain !== credentials.shopSubdomain
        ) {
          return null;
        }

        // Verify password
        const isPasswordValid = await compare(
          credentials.password,
          user.password
        );

        if (!isPasswordValid) {
          return null;
        }

        // Check if the shop is active
        if (user.shop && !user.shop.active) {
          return null; // Shop is inactive, don't allow login
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          shopId: user.shopId,
          shopName: user.shop?.name || null,
          shopSubdomain: user.shop?.subdomain || null,
          planType: user.shop?.planType || null,
        };
      },
    }),
  ],
  callbacks: {
    async session({ session, token }) {
      if (token) {
        session.user.id = token.id as string;
        session.user.name = token.name as string;
        session.user.email = token.email as string;
        session.user.role = token.role as string;
        session.user.shopId = token.shopId as string | null;
        session.user.shopName = token.shopName as string | null;
        session.user.shopSubdomain = token.shopSubdomain as string | null;
        session.user.planType = token.planType as string | null;
      }
      return session;
    },
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
        token.shopId = user.shopId;
        token.shopName = user.shopName;
        token.shopSubdomain = user.shopSubdomain;
        token.planType = user.planType;
      }

      return token;
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};

// Extend next-auth types
declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      name: string;
      email: string;
      role: string;
      shopId: string | null;
      shopName: string | null;
      shopSubdomain: string | null;
      planType: string | null;
    };
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string;
    role: string;
    shopId: string | null;
    shopName: string | null;
    shopSubdomain: string | null;
    planType: string | null;
  }
}

File: ./src/lib/api-client.ts
// src/lib/api-client.ts
/**
 * API Client for making API calls to the backend
 */
export const apiClient = {
  /**
   * Make a GET request to the API
   */
  async get(endpoint: string, params: Record<string, any> = {}) {
    // Build URL with query parameters
    const url = new URL(`/api${endpoint}`, window.location.origin);

    // Add query parameters to URL
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== "") {
        url.searchParams.append(key, String(value));
      }
    });

    // Make request
    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "An error occurred");
    }

    return response.json();
  },

  /**
   * Make a POST request to the API
   */
  async post(endpoint: string, data: any) {
    const response = await fetch(`/api${endpoint}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "An error occurred");
    }

    return response.json();
  },

  /**
   * Make a PUT request to the API
   */
  async put(endpoint: string, data: any) {
    const response = await fetch(`/api${endpoint}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "An error occurred");
    }

    return response.json();
  },

  /**
   * Make a DELETE request to the API
   */
  async delete(endpoint: string) {
    const response = await fetch(`/api${endpoint}`, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "An error occurred");
    }

    return response.json();
  },

  products: {
    /**
     * Get products with filtering, sorting, and pagination
     */
    async getProducts(params: any = {}) {
      return apiClient.get("/products", params);
    },

    /**
     * Create a new product
     */
    async createProduct(data: any) {
      return apiClient.post("/products", data);
    },

    /**
     * Get a product by ID
     */
    async getProduct(id: string) {
      return apiClient.get(`/products/${id}`);
    },

    /**
     * Update a product
     */
    async updateProduct(id: string, data: any) {
      return apiClient.put(`/products/${id}`, data);
    },

    /**
     * Delete a product
     */
    async deleteProduct(id: string) {
      return apiClient.delete(`/products/${id}`);
    },
  },

  // Categories API
  categories: {
    /**
     * Get all categories
     */
    async getCategories() {
      return apiClient.get("/categories");
    },
  },

  // Shop API
  shop: {
    /**
     * Get shop information
     */
    async getShopInfo() {
      return apiClient.get("/shop");
    },
  },
};

File: ./src/lib/permissions.ts
import { PlanType, Role } from "@prisma/client";

interface User {
  id: string;
  role: string;
  planType?: string | null;
}

export function canViewSubscription(user: User | null | undefined): boolean {
  // Only SHOP_ADMIN can view subscription details
  return user?.role === "SHOP_ADMIN";
}

export function canViewAdvancedStats(user: User | null | undefined): boolean {
  // Advanced stats are available to SHOP_ADMIN and SHOP_STAFF with ADVANCED or PREMIUM plans
  if (!user) return false;

  const hasPremiumPlan =
    user.planType === "ADVANCED" || user.planType === "PREMIUM";
  return (
    (user.role === "SHOP_ADMIN" || user.role === "SHOP_STAFF") && hasPremiumPlan
  );
}

export function formatPlanName(planType: string): string {
  // Format plan type for display
  switch (planType) {
    case "STANDARD":
      return "Standard Plan";
    case "ADVANCED":
      return "Advanced Plan";
    case "PREMIUM":
      return "Premium Plan";
    default:
      return planType;
  }
}

export function formatSubscriptionPeriod(period: string): string {
  // Format subscription period for display
  switch (period) {
    case "SIX_MONTHS":
      return "6 Months";
    case "ONE_YEAR":
      return "1 Year";
    case "THREE_YEARS":
      return "3 Years";
    default:
      return period;
  }
}

export function getDiscountByPeriod(period: string): number {
  // Return discount percentage based on period
  switch (period) {
    case "SIX_MONTHS":
      return 0;
    case "ONE_YEAR":
      return 12;
    case "THREE_YEARS":
      return 20;
    default:
      return 0;
  }
}

File: ./src/lib/serializer.ts
// src/lib/serializer.ts

/**
 * Recursively transforms BigInt values to strings or numbers in an object
 * to make it safe for JSON serialization
 *
 * @param obj The object to transform
 * @returns A new object with BigInt values converted to strings or numbers
 */
export function serializeBigInt(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  // Handle BigInt
  if (typeof obj === "bigint") {
    // Convert to number if it's within safe integer range, otherwise to string
    return Number.isSafeInteger(Number(obj)) ? Number(obj) : obj.toString();
  }

  // Handle Date
  if (obj instanceof Date) {
    return obj.toISOString();
  }

  // Handle arrays
  if (Array.isArray(obj)) {
    return obj.map(serializeBigInt);
  }

  // Handle objects
  if (typeof obj === "object") {
    const result: Record<string, any> = {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        result[key] = serializeBigInt(obj[key]);
      }
    }
    return result;
  }

  // Return primitive values as is
  return obj;
}

File: ./src/middleware.ts
import { NextRequest, NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const hostname = request.headers.get("host") || "";

  // For development environment, use the environment variable
  const subdomain =
    process.env.NODE_ENV === "development"
      ? process.env.SHOP_SUBDOMAIN || "para"
      : getSubdomainFromHostname(hostname);

  // Add the current subdomain to headers for backend use
  const requestHeaders = new Headers(request.headers);
  if (subdomain) {
    requestHeaders.set("x-shop-subdomain", subdomain);
  }

  // Main store.tn domain handling
  if (!subdomain || subdomain === "www") {
    // This is for the main store.tn site
    if (pathname.startsWith("/admin") && !(await isAuthenticated(request))) {
      return redirectToLogin(request);
    }
    // Continue to the main store application
    return NextResponse.next({
      request: {
        headers: requestHeaders,
      },
    });
  }

  // Subdomain handling (e.g., para.store.tn)
  // Admin routes for shop owners
  if (pathname.startsWith("/admin")) {
    const token = await getToken({ req: request });

    // If not authenticated, redirect to login
    if (!token) {
      return redirectToLogin(request, subdomain);
    }

    // Check if user belongs to this shop
    if (token.shopSubdomain !== subdomain) {
      // User is authenticated but trying to access another shop's admin
      return NextResponse.redirect(new URL("/unauthorized", request.url));
    }

    // User is authenticated and authorized for this shop's admin
    return NextResponse.next({
      request: {
        headers: requestHeaders,
      },
    });
  }

  // API routes
  if (pathname.startsWith("/api/")) {
    return NextResponse.next({
      request: {
        headers: requestHeaders,
      },
    });
  }

  // All other routes are for the storefront
  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });
}

// Helper function to extract subdomain from hostname
function getSubdomainFromHostname(hostname: string): string | null {
  // Handle localhost for development
  if (hostname.includes("localhost")) {
    return process.env.SHOP_SUBDOMAIN || null;
  }

  // Extract subdomain from hostname
  const parts = hostname.split(".");
  if (parts.length > 2) {
    return parts[0];
  }
  return null;
}

// Helper function to redirect to login
function redirectToLogin(
  request: NextRequest,
  subdomain?: string | null
): NextResponse {
  const url = new URL("/login", request.url);
  url.searchParams.set("callbackUrl", request.nextUrl.pathname);

  // If we have a subdomain, ensure we're redirecting to that shop's login page
  if (subdomain) {
    // In production, this would be something like `https://${subdomain}.store.tn/login`
    // For development, we use the same URL but keep track of the subdomain
    url.searchParams.set("shop", subdomain);
  }

  return NextResponse.redirect(url);
}

// Check if the request is authenticated (simplified, actual implementation would use getToken)
async function isAuthenticated(request: NextRequest): Promise<boolean> {
  const token = await getToken({ req: request });
  return !!token;
}

// Match all pathnames except for assets, public routes, etc.
export const config = {
  matcher: [
    /**
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    "/((?!_next/static|_next/image|favicon.ico|public|assets).*)",
    "/api/:path*",
    "/admin/:path*",
  ],
};

File: ./src/app/globals.css
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

File: ./src/app/register/page.tsx
// src/app/register/page.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ExclamationTriangleIcon } from "@heroicons/react/24/outline";

export default function RegisterPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    password: "",
    confirmPassword: "",
  });
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);

    // Validate password match
    if (formData.password !== formData.confirmPassword) {
      setError("Passwords don't match");
      setIsLoading(false);
      return;
    }

    try {
      // Register the user
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: formData.name,
          email: formData.email,
          password: formData.password,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Registration failed");
      }

      // Automatically sign in after successful registration
      const signInResult = await signIn("credentials", {
        redirect: false,
        email: formData.email,
        password: formData.password,
      });

      if (signInResult?.error) {
        throw new Error("Failed to sign in after registration");
      }

      // Redirect to dashboard
      router.push("/admin");
    } catch (error: any) {
      setError(error.message || "Something went wrong");
      setIsLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold">
            Create an account
          </CardTitle>
          <CardDescription>
            Enter your information to register for an account
          </CardDescription>
        </CardHeader>
        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <ExclamationTriangleIcon className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="name">Full Name</Label>
              <Input
                id="name"
                name="name"
                placeholder="John Doe"
                value={formData.name}
                onChange={handleChange}
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="you@example.com"
                value={formData.email}
                onChange={handleChange}
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                name="password"
                type="password"
                placeholder="••••••••"
                value={formData.password}
                onChange={handleChange}
                required
                minLength={8}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="confirmPassword">Confirm Password</Label>
              <Input
                id="confirmPassword"
                name="confirmPassword"
                type="password"
                placeholder="••••••••"
                value={formData.confirmPassword}
                onChange={handleChange}
                required
              />
            </div>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? "Creating account..." : "Create account"}
            </Button>
          </form>
        </CardContent>
        <CardFooter className="flex flex-col space-y-4">
          <div className="text-sm text-center">
            Already have an account?{" "}
            <Link
              href="/login"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              Sign in
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}

File: ./src/app/login/page.tsx
// src/app/login/page.tsx
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { signIn } from "next-auth/react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ExclamationTriangleIcon } from "@heroicons/react/24/outline";

export default function LoginPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get("callbackUrl") || "/admin";
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");

    try {
      const result = await signIn("credentials", {
        redirect: false,
        email,
        password,
      });

      if (result?.error) {
        setError("Invalid email or password");
        setIsLoading(false);
        return;
      }

      router.push(callbackUrl);
    } catch (error) {
      setError("An error occurred during login");
      setIsLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold">Login</CardTitle>
          <CardDescription>
            Enter your credentials to access your shop dashboard
          </CardDescription>
        </CardHeader>
        <CardContent>
          {error && (
            <Alert variant="destructive" className="mb-4">
              <ExclamationTriangleIcon className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="you@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
            </div>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="password">Password</Label>
                <Link
                  href="/forgot-password"
                  className="text-sm font-medium text-indigo-600 hover:text-indigo-500"
                >
                  Forgot password?
                </Link>
              </div>
              <Input
                id="password"
                type="password"
                placeholder="••••••••"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
              />
            </div>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? "Signing in..." : "Sign in"}
            </Button>
          </form>
        </CardContent>
        <CardFooter className="flex flex-col space-y-4">
          <div className="text-sm text-center">
            Don't have an account?{" "}
            <Link
              href="/register"
              className="font-medium text-indigo-600 hover:text-indigo-500"
            >
              Sign up
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}

File: ./src/app/page.tsx
// src/app/page.tsx
import { Metadata } from "next";
import Link from "next/link";
import Image from "next/image";
import { db } from "@/lib/prisma";

export const metadata: Metadata = {
  title: "Welcome to Para Shop",
  description: "The best online shopping experience",
};

async function getFeaturedProducts() {
  const subdomain = process.env.SHOP_SUBDOMAIN || "para";

  // Get shop ID first
  const shop = await db.shop.findUnique({
    where: {
      subdomain: subdomain,
    },
    select: {
      id: true,
    },
  });

  if (!shop) return [];

  // Get featured products
  const products = await db.product.findMany({
    where: {
      shopId: shop.id,
      inventory: {
        gt: 0,
      },
    },
    select: {
      id: true,
      name: true,
      slug: true,
      price: true,
      images: true,
    },
    orderBy: {
      createdAt: "desc",
    },
    take: 8,
  });

  return products;
}

async function getCategories() {
  const subdomain = process.env.SHOP_SUBDOMAIN || "para";

  // Get shop ID first
  const shop = await db.shop.findUnique({
    where: {
      subdomain: subdomain,
    },
    select: {
      id: true,
    },
  });

  if (!shop) return [];

  // Get top level categories
  const categories = await db.category.findMany({
    where: {
      shopId: shop.id,
      parentId: null,
    },
    select: {
      id: true,
      name: true,
      slug: true,
      image: true,
    },
  });

  return categories;
}

export default async function HomePage() {
  const products = await getFeaturedProducts();
  const categories = await getCategories();

  return (
    <div className="bg-white">
      {/* Hero section */}
      <div className="relative">
        <div className="mx-auto max-w-7xl">
          <div className="relative z-10 pt-14 lg:w-full lg:max-w-2xl">
            <div className="relative px-6 py-32 sm:py-40 lg:px-8 lg:py-56 lg:pr-0">
              <div className="mx-auto max-w-2xl lg:mx-0 lg:max-w-xl">
                <h1 className="text-4xl font-bold tracking-tight text-gray-900 sm:text-6xl">
                  Welcome to Para Shop
                </h1>
                <p className="mt-6 text-lg leading-8 text-gray-600">
                  Discover amazing products at great prices. Shop with
                  confidence and enjoy our fast delivery and customer service.
                </p>
                <div className="mt-10 flex items-center gap-x-6">
                  <Link
                    href="/products"
                    className="rounded-md bg-indigo-600 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600"
                  >
                    Shop Now
                  </Link>
                  <Link
                    href="/categories"
                    className="text-sm font-semibold leading-6 text-gray-900"
                  >
                    Browse Categories <span aria-hidden="true">→</span>
                  </Link>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Categories section */}
      <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
        <div className="mx-auto max-w-2xl py-16 sm:py-24 lg:max-w-none lg:py-12">
          <h2 className="text-2xl font-bold text-gray-900">Categories</h2>

          <div className="mt-6 space-y-12 lg:grid lg:grid-cols-3 lg:gap-x-6 lg:space-y-0">
            {categories.map((category) => (
              <div key={category.id} className="group relative">
                <div className="relative h-80 w-full overflow-hidden rounded-lg bg-white sm:aspect-h-1 sm:aspect-w-2 lg:aspect-h-1 lg:aspect-w-1 group-hover:opacity-75 sm:h-64">
                  {category.image ? (
                    <Image
                      src={category.image}
                      alt={category.name}
                      className="h-full w-full object-cover object-center"
                      width={500}
                      height={500}
                    />
                  ) : (
                    <div className="h-full w-full bg-gray-200 flex items-center justify-center">
                      <span className="text-gray-500">{category.name}</span>
                    </div>
                  )}
                </div>
                <h3 className="mt-6 text-sm text-gray-500">
                  <Link href={`/categories/${category.slug}`}>
                    <span className="absolute inset-0" />
                    {category.name}
                  </Link>
                </h3>
                <p className="text-base font-semibold text-gray-900">
                  Browse collection
                </p>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Featured products section */}
      <div className="bg-white">
        <div className="mx-auto max-w-2xl px-4 py-16 sm:px-6 sm:py-24 lg:max-w-7xl lg:px-8">
          <h2 className="text-2xl font-bold tracking-tight text-gray-900">
            Featured Products
          </h2>

          <div className="mt-6 grid grid-cols-1 gap-x-6 gap-y-10 sm:grid-cols-2 lg:grid-cols-4 xl:gap-x-8">
            {products.map((product) => (
              <div key={product.id} className="group relative">
                <div className="aspect-h-1 aspect-w-1 w-full overflow-hidden rounded-md bg-gray-200 lg:aspect-none group-hover:opacity-75 lg:h-80">
                  {product.images?.[0] ? (
                    <Image
                      src={product.images[0]}
                      alt={product.name}
                      className="h-full w-full object-cover object-center lg:h-full lg:w-full"
                      width={300}
                      height={300}
                    />
                  ) : (
                    <div className="h-full w-full bg-gray-200 flex items-center justify-center">
                      <span className="text-gray-500">No image</span>
                    </div>
                  )}
                </div>
                <div className="mt-4 flex justify-between">
                  <div>
                    <h3 className="text-sm text-gray-700">
                      <Link href={`/products/${product.slug}`}>
                        <span aria-hidden="true" className="absolute inset-0" />
                        {product.name}
                      </Link>
                    </h3>
                  </div>
                  <p className="text-sm font-medium text-gray-900">
                    ${product.price.toFixed(2)}
                  </p>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

File: ./src/app/layout.tsx
// src/app/layout.tsx
import "./globals.css";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { cn } from "@/lib/utils";
import { ShopProvider } from "@/components/providers/shop-provider";
import { SessionProvider } from "@/components/providers/session-provider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Para Shop",
  description: "Your online store",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body
        className={cn(
          "min-h-screen bg-white font-sans antialiased",
          inter.className
        )}
      >
        <SessionProvider>
          <ShopProvider>{children}</ShopProvider>
        </SessionProvider>
      </body>
    </html>
  );
}

File: ./src/app/admin/page.tsx
// src/app/admin/page.tsx
import { getServerSession } from "next-auth/next";
import { db } from "@/lib/prisma";
import { authOptions } from "@/lib/auth";
import { formatCurrency } from "@/lib/utils";
import { canViewAdvancedStats } from "@/lib/permissions";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  ArrowUp,
  ArrowDown,
  ShoppingCart,
  Users,
  DollarSign,
  Package,
} from "lucide-react";
import { SubscriptionInfo } from "@/components/admin/subscription-info";

export default async function AdminDashboardPage() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    return <div>Shop not found</div>;
  }

  const shopId = session.user.shopId;

  // Get shop data with subscription
  const shop = await db.shop.findUnique({
    where: { id: shopId },
    include: {
      settings: true,
      subscription: {
        include: {
          payments: true,
        },
      },
    },
  });

  if (!shop) {
    return <div>Shop not found</div>;
  }

  // Get count of products
  const productCount = await db.product.count({
    where: { shopId },
  });

  // Get count of customers
  const customerCount = await db.user.count({
    where: {
      shopId,
      role: "CUSTOMER",
    },
  });

  // Get count of orders
  const orderCount = await db.order.count({
    where: { shopId },
  });

  // Get total revenue
  const ordersWithTotal = await db.order.findMany({
    where: {
      shopId,
      status: { notIn: ["CANCELLED", "REFUNDED"] },
    },
    select: { total: true },
  });

  const totalRevenue = ordersWithTotal.reduce(
    (sum, order) => sum + order.total,
    0
  );

  // Get recent orders
  const recentOrders = await db.order.findMany({
    where: { shopId },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
    orderBy: { createdAt: "desc" },
    take: 5,
  });

  // Get low stock products
  const lowStockProducts = await db.product.findMany({
    where: {
      shopId,
      lowStockAlert: true,
    },
    take: 5,
  });

  // Prepare subscription data for the component
  let subscriptionData = null;
  if (shop.subscription) {
    const sub = shop.subscription;

    // Calculate total paid amount
    const paidAmount = sub.payments
      .filter((payment) => payment.status === "COMPLETED")
      .reduce((sum, payment) => sum + payment.amount, 0);

    // Calculate days remaining
    const now = new Date();
    const endDate = new Date(sub.endDate);
    const daysRemaining = Math.max(
      0,
      Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
    );

    subscriptionData = {
      id: sub.id,
      planType: shop.planType,
      period: sub.period,
      startDate: sub.startDate.toISOString(),
      endDate: sub.endDate.toISOString(),
      status: sub.status,
      totalAmount: sub.totalAmount,
      appliedDiscount: sub.appliedDiscount,
      paidAmount,
      remainingAmount: Math.max(0, sub.totalAmount - paidAmount),
      daysRemaining,
      isActive: sub.status === "ACTIVE" && endDate > now,
    };
  }

  // Check if the user can view advanced stats
  const showAdvancedStats = canViewAdvancedStats(session.user);

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold tracking-tight text-gray-700">
        Dashboard
      </h1>

      {/* Subscription Information (only for SHOP_ADMIN) */}
      <SubscriptionInfo subscription={subscriptionData} />

      {/* Basic Stats - available to all */}
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Products</CardTitle>
            <Package className="h-4 w-4 text-gray-500" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{productCount}</div>
            <p className="text-xs text-gray-500">
              {lowStockProducts.length} with low stock
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Customers</CardTitle>
            <Users className="h-4 w-4 text-gray-500" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{customerCount}</div>
            <p className="text-xs text-gray-500">Active customers</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Orders</CardTitle>
            <ShoppingCart className="h-4 w-4 text-gray-500" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{orderCount}</div>
            <p className="text-xs text-gray-500">Total orders</p>
          </CardContent>
        </Card>

        {/* Revenue - Only shown for ADVANCED/PREMIUM */}
        {showAdvancedStats && (
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">
                Total Revenue
              </CardTitle>
              <DollarSign className="h-4 w-4 text-gray-500" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">
                {formatCurrency(totalRevenue)}
              </div>
              <p className="text-xs text-gray-500">
                Total from {orderCount} orders
              </p>
            </CardContent>
          </Card>
        )}
      </div>

      {/* Advanced stats - Only shown for ADVANCED/PREMIUM */}
      {showAdvancedStats && (
        <div className="grid gap-6 md:grid-cols-2">
          <Card>
            <CardHeader>
              <CardTitle>Recent Orders</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {recentOrders.length > 0 ? (
                  recentOrders.map((order) => (
                    <div key={order.id} className="flex items-center">
                      <div className="ml-4 space-y-1">
                        <p className="text-sm font-medium leading-none">
                          {order.orderNumber}
                        </p>
                        <p className="text-sm text-gray-500">
                          {order.user.name || order.user.email}
                        </p>
                      </div>
                      <div className="ml-auto font-medium">
                        {formatCurrency(order.total)}
                      </div>
                    </div>
                  ))
                ) : (
                  <p className="text-sm text-gray-500">No orders yet</p>
                )}
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Low Stock Products</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {lowStockProducts.length > 0 ? (
                  lowStockProducts.map((product) => (
                    <div key={product.id} className="flex items-center">
                      <div className="ml-4 space-y-1">
                        <p className="text-sm font-medium leading-none">
                          {product.name}
                        </p>
                        <p className="text-sm text-gray-500">
                          {product.inventory} units left
                        </p>
                      </div>
                      <div className="ml-auto font-medium">
                        {formatCurrency(product.price)}
                      </div>
                    </div>
                  ))
                ) : (
                  <p className="text-sm text-gray-500">No low stock products</p>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      )}
    </div>
  );
}

File: ./src/app/admin/discount-codes/page.tsx
// src/app/admin/discount-codes/page.tsx
import { getServerSession } from "next-auth/next";
import Link from "next/link";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Plus } from "lucide-react";
import DiscountCodeListActions from "@/components/admin/discount-code-list-actions";
import Pagination from "@/components/admin/pagination";

interface DiscountCodesPageProps {
  searchParams: {
    [key: string]: string | string[] | undefined;
  };
}

export default async function DiscountCodesPage({
  searchParams,
}: DiscountCodesPageProps) {
  // Check authentication
  const session = await getServerSession(authOptions);
  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/discount-codes");
  }
  const shopId = session.user.shopId;

  // Parse pagination params safely
  const page = parseInt(String(searchParams.page) || "1");
  const perPage = parseInt(String(searchParams.perPage) || "10");
  const productId = searchParams.product
    ? String(searchParams.product)
    : undefined;
  const userId = searchParams.user ? String(searchParams.user) : undefined;

  // Build where clause for filtering
  const where: any = { shopId };

  // Filter by specific product if requested
  if (productId) {
    where.productId = productId;
  }

  // Filter by specific user if requested
  if (userId) {
    where.userId = userId;
  }

  // Count total discount codes for pagination
  const totalDiscountCodes = await db.discountCode.count({
    where,
  });

  // Calculate total pages
  const totalPages = Math.ceil(totalDiscountCodes / perPage);

  // Get discount codes with pagination
  const discountCodes = await db.discountCode.findMany({
    where,
    include: {
      product: {
        select: {
          id: true,
          name: true,
        },
      },
      user: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
    orderBy: {
      createdAt: "desc",
    },
    skip: (page - 1) * perPage,
    take: perPage,
  });

  // Format dates for display
  const formatDate = (date: Date | string) => {
    return new Date(date).toLocaleDateString();
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            Discount Codes
          </h1>
          <p className="text-gray-500 mt-1">
            Manage promotional codes for your customers
          </p>
        </div>
        <Link href="/admin/discount-codes/new">
          <Button>
            <Plus className="mr-2 h-4 w-4" />
            Add Discount Code
          </Button>
        </Link>
      </div>

      <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
        <Table>
          <TableHeader className="bg-gray-50">
            <TableRow>
              <TableHead className="text-gray-700">Code</TableHead>
              <TableHead className="text-gray-700">Discount</TableHead>
              <TableHead className="text-gray-700">Valid Period</TableHead>
              <TableHead className="text-gray-700">Applied To</TableHead>
              <TableHead className="text-gray-700">Status</TableHead>
              <TableHead className="text-right text-gray-700">
                Actions
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {discountCodes.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={6}
                  className="text-center py-8 text-gray-600"
                >
                  No discount codes found.{" "}
                  <Link
                    href="/admin/discount-codes/new"
                    className="text-indigo-600 hover:underline"
                  >
                    Add your first discount code
                  </Link>
                  .
                </TableCell>
              </TableRow>
            ) : (
              discountCodes.map((code) => (
                <TableRow key={code.id}>
                  <TableCell className="font-medium uppercase">
                    {code.code}
                  </TableCell>
                  <TableCell>{code.percentage}% OFF</TableCell>
                  <TableCell>
                    {formatDate(code.startDate)} to {formatDate(code.endDate)}
                  </TableCell>
                  <TableCell>
                    {code.product ? (
                      <Link
                        href={`/admin/products/${code.product.id}`}
                        className="text-indigo-600 hover:underline"
                      >
                        {code.product.name}
                      </Link>
                    ) : (
                      <span>All Products</span>
                    )}
                    <br />
                    {code.user ? (
                      <Link
                        href={`/admin/customers/${code.user.id}`}
                        className="text-indigo-600 hover:underline"
                      >
                        {code.user.name || code.user.email}
                      </Link>
                    ) : (
                      <span>All Users</span>
                    )}
                  </TableCell>
                  <TableCell>
                    <span
                      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                        code.isActive
                          ? "bg-green-100 text-green-800"
                          : "bg-gray-100 text-gray-800"
                      }`}
                    >
                      {code.isActive ? "Active" : "Inactive"}
                    </span>
                  </TableCell>
                  <TableCell className="text-right">
                    <DiscountCodeListActions discountCodeId={code.id} />
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination using client component */}
      <Pagination
        currentPage={page}
        totalPages={totalPages}
        totalItems={totalDiscountCodes}
      />
    </div>
  );
}

File: ./src/app/admin/orders/[id]/page.tsx
// src/app/admin/orders/[id]/page.tsx
import { getServerSession } from "next-auth/next";
import Link from "next/link";
import Image from "next/image";
import { notFound, redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { ordersService } from "@/lib/services/orders.service";
import { formatCurrency, formatDate } from "@/lib/utils";
import { FeatureGuard } from "@/components/authorization/feature-guard";
import { Feature } from "@/lib/feature-authorization";

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TableFooter,
} from "@/components/ui/table";
import { Separator } from "@/components/ui/separator";
import OrderStatusBadge from "@/components/admin/order-status-badge";
import OrderStatusUpdateForm from "@/components/admin/order-status-update-form";
import {
  Truck,
  CreditCard,
  User,
  ShoppingBag,
  Banknote,
  FileText,
  ArrowLeft,
} from "lucide-react";

interface OrderDetailsPageProps {
  params: {
    id: string;
  };
}

export default async function OrderDetailsPage({
  params,
}: OrderDetailsPageProps) {
  // Check authentication
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/orders");
  }

  const shopId = session.user.shopId;
  const orderId = params.id;

  // Get the order
  const order = await ordersService.getOrderById(orderId, shopId);

  if (!order) {
    notFound();
  }

  // Calculate summary values
  const totalItems = order.items.length;
  const totalQuantity = order.items.reduce(
    (sum, item) => sum + item.quantity,
    0
  );

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <Link
            href="/admin/orders"
            className="flex items-center text-gray-600 hover:text-indigo-600 text-sm mb-2"
          >
            <ArrowLeft className="h-4 w-4 mr-1" /> Back to all orders
          </Link>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            Order {order.orderNumber}
          </h1>
          <p className="text-gray-500 mt-1">
            Placed on {formatDate(order.createdAt)} at{" "}
            {new Date(order.createdAt).toLocaleTimeString()}
          </p>
        </div>
        <div className="flex items-center gap-4">
          <FeatureGuard feature={Feature.INVOICE_GENERATION}>
            {order.invoice ? (
              <Button asChild variant="outline">
                <Link href={`/api/orders/${order.id}/invoice`} target="_blank">
                  <FileText className="h-4 w-4 mr-2" />
                  View Invoice
                </Link>
              </Button>
            ) : (
              <Button asChild>
                <Link href={`/api/orders/${order.id}/invoice/generate`}>
                  <FileText className="h-4 w-4 mr-2" />
                  Generate Invoice
                </Link>
              </Button>
            )}
          </FeatureGuard>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* Main order details */}
        <div className="md:col-span-2 space-y-6">
          {/* Order Items Card */}
          <Card>
            <CardHeader className="bg-gray-50 border-b">
              <div className="flex justify-between items-center">
                <CardTitle className="text-lg text-gray-800">
                  <ShoppingBag className="h-4 w-4 inline-block mr-2" />
                  Order Items ({totalItems})
                </CardTitle>
                <div className="text-sm text-gray-600">
                  Total Quantity:{" "}
                  <span className="font-semibold">{totalQuantity}</span>
                </div>
              </div>
            </CardHeader>
            <CardContent className="p-0">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Product</TableHead>
                    <TableHead>Unit Price</TableHead>
                    <TableHead>Quantity</TableHead>
                    <TableHead className="text-right">Total</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {order.items.map((item) => (
                    <TableRow key={item.id}>
                      <TableCell>
                        <div className="flex items-center space-x-3">
                          <div className="flex-shrink-0 h-10 w-10 rounded bg-gray-100 flex items-center justify-center overflow-hidden">
                            {item.productImage ? (
                              <Image
                                src={item.productImage}
                                alt={item.productName}
                                width={40}
                                height={40}
                                className="object-cover"
                              />
                            ) : (
                              <div className="text-gray-400 text-xs">
                                No image
                              </div>
                            )}
                          </div>
                          <div>
                            <Link
                              href={`/admin/products/${item.productId}`}
                              className="font-medium text-gray-800 hover:text-indigo-600 hover:underline"
                            >
                              {item.productName}
                            </Link>
                            {item.productOptions &&
                              Object.keys(item.productOptions).length > 0 && (
                                <div className="text-xs text-gray-500 mt-0.5">
                                  {Object.entries(item.productOptions)
                                    .map(([key, value]) => `${key}: ${value}`)
                                    .join(", ")}
                                </div>
                              )}
                          </div>
                        </div>
                      </TableCell>
                      <TableCell className="text-gray-700">
                        {formatCurrency(item.unitPrice)}
                        {item.discountPercentage && (
                          <div className="text-xs text-green-600">
                            ({item.discountPercentage}% off)
                          </div>
                        )}
                      </TableCell>
                      <TableCell className="text-gray-700">
                        {item.quantity}
                      </TableCell>
                      <TableCell className="text-right font-medium text-gray-800">
                        {formatCurrency(item.total)}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
                <TableFooter>
                  <TableRow>
                    <TableCell colSpan={3} className="text-right font-medium">
                      Subtotal
                    </TableCell>
                    <TableCell className="text-right font-medium">
                      {formatCurrency(order.subtotal)}
                    </TableCell>
                  </TableRow>
                  {order.shipping > 0 && (
                    <TableRow>
                      <TableCell colSpan={3} className="text-right font-medium">
                        Shipping
                      </TableCell>
                      <TableCell className="text-right font-medium">
                        {formatCurrency(order.shipping)}
                      </TableCell>
                    </TableRow>
                  )}
                  {order.tax > 0 && (
                    <TableRow>
                      <TableCell colSpan={3} className="text-right font-medium">
                        Tax
                      </TableCell>
                      <TableCell className="text-right font-medium">
                        {formatCurrency(order.tax)}
                      </TableCell>
                    </TableRow>
                  )}
                  {order.discount > 0 && (
                    <TableRow>
                      <TableCell
                        colSpan={3}
                        className="text-right font-medium text-green-600"
                      >
                        Discount
                      </TableCell>
                      <TableCell className="text-right font-medium text-green-600">
                        -{formatCurrency(order.discount)}
                      </TableCell>
                    </TableRow>
                  )}
                  <TableRow>
                    <TableCell
                      colSpan={3}
                      className="text-right font-bold text-lg"
                    >
                      Total
                    </TableCell>
                    <TableCell className="text-right font-bold text-lg">
                      {formatCurrency(order.total)}
                    </TableCell>
                  </TableRow>
                </TableFooter>
              </Table>
            </CardContent>
          </Card>

          {/* Order Notes */}
          {order.notes && (
            <Card>
              <CardHeader className="bg-gray-50 border-b">
                <CardTitle className="text-lg text-gray-800">
                  Order Notes
                </CardTitle>
              </CardHeader>
              <CardContent className="p-4">
                <p className="text-gray-700 whitespace-pre-wrap">
                  {order.notes}
                </p>
              </CardContent>
            </Card>
          )}

          {/* Order Status Update Form */}
          <Card>
            <CardHeader className="bg-gray-50 border-b">
              <CardTitle className="text-lg text-gray-800">
                Update Order Status
              </CardTitle>
              <CardDescription>Change the status of this order</CardDescription>
            </CardHeader>
            <CardContent className="p-4 pt-6">
              <OrderStatusUpdateForm
                orderId={order.id}
                currentStatus={order.status}
                currentPaymentStatus={order.paymentStatus}
                currentShippingStatus={order.shippingStatus}
              />
            </CardContent>
          </Card>
        </div>

        {/* Sidebar with Customer, Shipping, Payment info */}
        <div className="space-y-6">
          {/* Order Summary Card */}
          <Card>
            <CardHeader className="bg-gray-50 border-b">
              <CardTitle className="text-lg text-gray-800">
                Order Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="p-4 divide-y divide-gray-200">
              <div className="py-3 flex justify-between">
                <span className="text-gray-500">Status</span>
                <OrderStatusBadge status={order.status} />
              </div>
              <div className="py-3 flex justify-between">
                <span className="text-gray-500">Payment</span>
                <OrderStatusBadge status={order.paymentStatus} type="payment" />
              </div>
              <div className="py-3 flex justify-between">
                <span className="text-gray-500">Shipping</span>
                <OrderStatusBadge
                  status={order.shippingStatus || "PENDING"}
                  type="shipping"
                />
              </div>
              <div className="py-3 flex justify-between">
                <span className="text-gray-500">Date Placed</span>
                <span className="text-gray-700">
                  {formatDate(order.createdAt)}
                </span>
              </div>
              {order.updatedAt && order.updatedAt !== order.createdAt && (
                <div className="py-3 flex justify-between">
                  <span className="text-gray-500">Last Updated</span>
                  <span className="text-gray-700">
                    {formatDate(order.updatedAt)}
                  </span>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Customer Info */}
          <Card>
            <CardHeader className="bg-gray-50 border-b px-4 py-3">
              <div className="flex items-center">
                <User className="h-4 w-4 mr-2 text-gray-500" />
                <CardTitle className="text-base text-gray-800">
                  Customer
                </CardTitle>
              </div>
            </CardHeader>
            <CardContent className="p-4">
              <div className="space-y-2">
                <div className="font-medium text-gray-800">
                  {order.user.name || "Guest Customer"}
                </div>
                <div className="text-gray-600">{order.user.email}</div>
                <div className="pt-2">
                  <Button variant="outline" size="sm" asChild>
                    <Link href={`/admin/customers/${order.userId}`}>
                      View Customer
                    </Link>
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Shipping Address */}
          {order.address && (
            <Card>
              <CardHeader className="bg-gray-50 border-b px-4 py-3">
                <div className="flex items-center">
                  <Truck className="h-4 w-4 mr-2 text-gray-500" />
                  <CardTitle className="text-base text-gray-800">
                    Shipping Address
                  </CardTitle>
                </div>
              </CardHeader>
              <CardContent className="p-4">
                <div className="space-y-1 text-gray-700">
                  <div>{order.address.line1}</div>
                  {order.address.line2 && <div>{order.address.line2}</div>}
                  <div>
                    {order.address.city}, {order.address.state}{" "}
                    {order.address.postalCode}
                  </div>
                  <div>{order.address.country}</div>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Payment Info */}
          <Card>
            <CardHeader className="bg-gray-50 border-b px-4 py-3">
              <div className="flex items-center">
                <CreditCard className="h-4 w-4 mr-2 text-gray-500" />
                <CardTitle className="text-base text-gray-800">
                  Payment Info
                </CardTitle>
              </div>
            </CardHeader>
            <CardContent className="p-4">
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-gray-600">Payment Method</span>
                  <span className="text-gray-800 font-medium">
                    {order.paymentMethod || "Standard Payment"}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600">Payment Status</span>
                  <OrderStatusBadge
                    status={order.paymentStatus}
                    type="payment"
                  />
                </div>
                <Separator className="my-2" />
                <div className="flex justify-between font-medium">
                  <span className="text-gray-800">Total Paid</span>
                  <span className="text-gray-800">
                    {formatCurrency(order.total)}
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Invoice Status - Only for Advanced/Premium plans */}
          <FeatureGuard feature={Feature.INVOICE_GENERATION}>
            <Card>
              <CardHeader className="bg-gray-50 border-b px-4 py-3">
                <div className="flex items-center">
                  <FileText className="h-4 w-4 mr-2 text-gray-500" />
                  <CardTitle className="text-base text-gray-800">
                    Invoice
                  </CardTitle>
                </div>
              </CardHeader>
              <CardContent className="p-4">
                {order.invoice ? (
                  <div className="space-y-3">
                    <div className="flex justify-between">
                      <span className="text-gray-600">Invoice Number</span>
                      <span className="text-gray-800 font-medium">
                        {order.invoice.invoiceNumber}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-600">Created On</span>
                      <span className="text-gray-800">
                        {formatDate(order.invoice.createdAt)}
                      </span>
                    </div>
                    <Button size="sm" className="w-full mt-2" asChild>
                      <Link
                        href={`/api/orders/${order.id}/invoice`}
                        target="_blank"
                      >
                        View Invoice
                      </Link>
                    </Button>
                  </div>
                ) : (
                  <div className="text-center py-2">
                    <p className="text-gray-600 mb-3">
                      No invoice generated yet
                    </p>
                    <Button size="sm" className="w-full" asChild>
                      <Link href={`/api/orders/${order.id}/invoice/generate`}>
                        Generate Invoice
                      </Link>
                    </Button>
                  </div>
                )}
              </CardContent>
            </Card>
          </FeatureGuard>
        </div>
      </div>
    </div>
  );
}

File: ./src/app/admin/orders/page.tsx
import { getServerSession } from "next-auth/next";
import Link from "next/link";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { ordersService } from "@/lib/services/orders.service";
import { productsService } from "@/lib/services/products.service";
import { usersService } from "@/lib/services/users.service";
import { formatCurrency, formatDate } from "@/lib/utils";
import { FeatureGuard } from "@/components/authorization/feature-guard";
import { Feature } from "@/lib/feature-authorization";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import OrderFilters from "@/components/admin/order-filters";
import Pagination from "@/components/admin/pagination";
import OrderStatusBadge from "@/components/admin/order-status-badge";
import OrderListActions from "@/components/admin/order-list-actions";
import { serializeBigInt } from "@/lib/serializer";

interface OrdersPageProps {
  searchParams?: { [key: string]: string | string[] | undefined };
}

export default async function OrdersPage(props: OrdersPageProps) {
  // Check authentication
  const session = await getServerSession(authOptions);
  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/orders");
  }
  const shopId = session.user.shopId;

  // Use a more direct approach that doesn't access searchParams properties directly
  // Extract the needed values from the URL manually
  const url = new URL("http://dummy.com"); // Just a placeholder

  // Copy all search params to this URL object
  if (props.searchParams) {
    for (const [key, value] of Object.entries(props.searchParams)) {
      if (Array.isArray(value)) {
        value.forEach((v) => url.searchParams.append(key, v));
      } else if (value !== undefined) {
        url.searchParams.append(key, value);
      }
    }
  }

  // Now extract each parameter safely from the URL object
  const page = parseInt(url.searchParams.get("page") || "1");
  const perPage = parseInt(url.searchParams.get("perPage") || "10");
  const sort = url.searchParams.get("sort") || "createdAt";
  const order = url.searchParams.get("order") || "desc";
  const search = url.searchParams.get("search") || "";
  const status = url.searchParams.get("status") || undefined;
  const paymentStatus = url.searchParams.get("paymentStatus") || undefined;
  const product = url.searchParams.get("product") || undefined;
  const customer = url.searchParams.get("customer") || undefined;
  const dateFrom = url.searchParams.get("dateFrom") || undefined;
  const dateTo = url.searchParams.get("dateTo") || undefined;

  // Parse date filters safely
  let dateFromObj = undefined;
  let dateToObj = undefined;

  if (dateFrom) {
    dateFromObj = new Date(dateFrom);
  }

  if (dateTo) {
    dateToObj = new Date(dateTo);
    // Set to end of day
    dateToObj.setHours(23, 59, 59, 999);
  }

  // Prepare filters
  const filters = {
    shopId,
    search,
    status,
    paymentStatus,
    dateFrom: dateFromObj,
    dateTo: dateToObj,
    customerId: customer,
    productId: product,
  };

  // Prepare pagination
  const pagination = {
    page,
    perPage,
  };

  // Prepare sorting
  const sortOptions = {
    sortField: sort,
    sortOrder: order as "asc" | "desc",
  };

  // Get total orders count for pagination
  const totalOrders = await ordersService.getTotalOrders(filters);

  // Calculate total pages
  const totalPages = Math.ceil(totalOrders / perPage);

  // Get orders with pagination and sorting
  const orders = await ordersService.getOrders(
    filters,
    pagination,
    sortOptions
  );

  // Get order statistics
  const orderStats = await ordersService.getOrderStats(shopId);

  // Get product info if filtering by product
  let productInfo = null;
  if (product) {
    productInfo = await productsService.getProductById(product, shopId);
  }

  // Get customer info if filtering by customer
  let customerInfo = null;
  if (customer) {
    customerInfo = await usersService.getUserById(customer, shopId);
  }

  // Prepare safe filter parameters for passing to client components
  const currentFilters = {
    search: search || undefined,
    status: status || undefined,
    paymentStatus: paymentStatus || undefined,
    dateFrom: dateFromObj ? dateFromObj.toISOString().split("T")[0] : undefined,
    dateTo: dateToObj ? dateToObj.toISOString().split("T")[0] : undefined,
    page: page.toString(),
    perPage: perPage.toString(),
    sort,
    order,
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            {productInfo
              ? `Orders for ${productInfo.name}`
              : customerInfo
              ? `Orders for ${customerInfo.name || customerInfo.email}`
              : "Orders"}
          </h1>
          <p className="text-gray-500 mt-1">
            {(productInfo || customerInfo) && (
              <Link
                href="/admin/orders"
                className="text-indigo-600 hover:underline"
              >
                View all orders
              </Link>
            )}
          </p>
        </div>
      </div>

      {/* Statistics Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium text-gray-700">
              Total Orders
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-gray-800">
              {totalOrders}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium text-gray-700">
              Total Revenue
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-emerald-600">
              {formatCurrency(orderStats.totalRevenue)}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium text-gray-700">
              Monthly Revenue
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-indigo-600">
              {formatCurrency(orderStats.monthlyRevenue)}
            </div>
          </CardContent>
        </Card>
        {/* Invoice Generation - only for Advanced and Premium plans */}
        <FeatureGuard
          feature={Feature.INVOICE_GENERATION}
          fallback={
            <Card>
              <CardHeader className="flex flex-row items-center justify-between pb-2">
                <CardTitle className="text-sm font-medium text-gray-700">
                  Pending Orders
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold text-orange-500">
                  {serializeBigInt(orderStats.statusCounts).find(
                    (s: any) => s.status === "PENDING"
                  )?.count || 0}
                </div>
              </CardContent>
            </Card>
          }
        >
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-gray-700">
                Invoice Generation
              </CardTitle>
            </CardHeader>
            <CardContent className="flex flex-col">
              <div className="text-lg font-bold text-gray-800">Available</div>
              <Button variant="outline" size="sm" className="mt-2">
                <Link href="/admin/orders/export-invoices">
                  Export All Invoices
                </Link>
              </Button>
            </CardContent>
          </Card>
        </FeatureGuard>
      </div>

      {/* Filters */}
      <OrderFilters currentFilters={currentFilters} />

      {/* Orders Table */}
      <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
        <Table>
          <TableHeader className="bg-gray-50">
            <TableRow>
              <TableHead className="text-gray-700 w-[180px]">Order</TableHead>
              <TableHead className="text-gray-700">Customer</TableHead>
              <TableHead className="text-gray-700">Items</TableHead>
              <TableHead className="text-gray-700">Date</TableHead>
              <TableHead className="text-gray-700">Total</TableHead>
              <TableHead className="text-gray-700">Status</TableHead>
              <TableHead className="text-gray-700">Payment</TableHead>
              <TableHead className="text-right text-gray-700">
                Actions
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {orders.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={8}
                  className="text-center py-8 text-gray-600"
                >
                  No orders found matching your criteria.
                </TableCell>
              </TableRow>
            ) : (
              orders.map((order) => (
                <TableRow key={order.id}>
                  <TableCell className="font-medium text-gray-800">
                    <Link
                      href={`/admin/orders/${order.id}`}
                      className="text-indigo-600 hover:underline font-medium"
                    >
                      {order.orderNumber}
                    </Link>
                    <div className="text-xs text-gray-500 mt-1">
                      {order._count.items} items
                    </div>
                  </TableCell>
                  <TableCell>
                    <Link
                      href={`/admin/customers/${order.userId}`}
                      className="text-gray-700 hover:text-indigo-600 hover:underline font-medium"
                    >
                      {order.user.name || "Unnamed Customer"}
                    </Link>
                    <div className="text-xs text-gray-500 truncate">
                      {order.user.email}
                    </div>
                  </TableCell>
                  <TableCell>
                    <div className="flex flex-col gap-1">
                      {order.items.slice(0, 2).map((item, i) => (
                        <div
                          key={i}
                          className="text-sm text-gray-600 flex items-center"
                        >
                          <span className="w-6 text-gray-500">
                            {item.quantity}×
                          </span>
                          <Link
                            href={`/admin/products/${item.productId}`}
                            className="truncate hover:underline max-w-[150px]"
                          >
                            {item.productName ||
                              item.product?.name ||
                              "Product"}
                          </Link>
                        </div>
                      ))}
                      {order._count.items > 2 && (
                        <div className="text-xs text-gray-500">
                          +{order._count.items - 2} more items
                        </div>
                      )}
                    </div>
                  </TableCell>
                  <TableCell>
                    <div className="text-sm text-gray-600">
                      {formatDate(order.createdAt)}
                    </div>
                    <div className="text-xs text-gray-500">
                      {new Date(order.createdAt).toLocaleTimeString()}
                    </div>
                  </TableCell>
                  <TableCell className="font-medium">
                    {formatCurrency(order.total)}
                  </TableCell>
                  <TableCell>
                    <OrderStatusBadge status={order.status} />
                  </TableCell>
                  <TableCell>
                    <OrderStatusBadge
                      status={order.paymentStatus}
                      type="payment"
                    />
                  </TableCell>
                  <TableCell className="text-right">
                    <OrderListActions
                      orderId={order.id}
                      hasInvoice={!!order.invoice}
                    />
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      <Pagination
        currentPage={page}
        totalPages={totalPages}
        totalItems={totalOrders}
      />
    </div>
  );
}

File: ./src/app/admin/layout.tsx
// src/app/admin/layout.tsx
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import AdminSidebar from "@/components/admin/sidebar";
import AdminHeader from "@/components/admin/header";
import { ToastsProvider } from "@/components/providers/toast-provider";

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession(authOptions);

  // Check if user is authenticated and has proper role
  if (
    !session ||
    (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
  ) {
    redirect("/login?callbackUrl=/admin");
  }

  return (
    <div className="flex h-screen bg-gray-100">
      <AdminSidebar />
      <div className="flex-1 flex flex-col overflow-hidden">
        <AdminHeader />
        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100 p-6">
          {children}
        </main>
        <ToastsProvider />
      </div>
    </div>
  );
}

File: ./src/app/admin/products/[id]/page.tsx
// src/app/admin/products/[id]/page.tsx
import { getServerSession } from "next-auth/next";
import { redirect, notFound } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import ProductForm from "@/components/admin/product-form";

interface EditProductPageProps {
  params: {
    id: string;
  };
}

export default async function EditProductPage({
  params,
}: EditProductPageProps) {
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/products");
  }

  const shopId = session.user.shopId;

  // Get the product
  const product = await db.product.findUnique({
    where: {
      id: params.id,
      shopId, // Ensure it belongs to this shop
    },
    include: {
      categories: true,
      variants: true,
      customFields: {
        include: {
          customField: true,
        },
      },
    },
  });

  if (!product) {
    notFound();
  }

  // Get all categories for the shop with hierarchy information
  const allCategories = await db.category.findMany({
    where: { shopId },
    select: {
      id: true,
      name: true,
      parentId: true,
    },
  });

  // Map categories with level information
  // This recursive function determines the depth level of each category
  const addLevelToCategories = (
    categories: any[],
    parentId: string | null = null,
    level = 0
  ) => {
    return categories
      .filter((category) => category.parentId === parentId)
      .map((category) => ({
        id: category.id,
        name: category.name,
        level,
        parentId: category.parentId,
      }));
  };

  // Function to create flat array with correct level
  const createFlatCategoriesWithLevels = (categories: any[]) => {
    // First get all root categories (those with no parent)
    let result = addLevelToCategories(categories);

    // For each root category, recursively add its children
    for (let i = 0; i < result.length; i++) {
      const category = result[i];
      const children = addLevelToCategories(
        categories,
        category.id,
        category.level + 1
      );

      // Insert children after their parent
      if (children.length > 0) {
        result.splice(i + 1, 0, ...children);
        // Skip the children we just added
        i += children.length;
      }
    }

    return result;
  };

  const flatCategories = createFlatCategoriesWithLevels(allCategories);

  // Get all custom fields for the shop
  const customFields = await db.customField.findMany({
    where: { shopId },
    orderBy: { name: "asc" },
  });

  return (
    <div>
      <div className="text-2xl font-bold tracking-tight text-gray-800 mb-6">
        Edit Product: {product.name}
      </div>

      <ProductForm
        product={product}
        categories={flatCategories}
        customFields={customFields}
        shopId={shopId}
        isEditing
      />
    </div>
  );
}

File: ./src/app/admin/products/new/page.tsx
// src/app/admin/products/new/page.tsx
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import ProductForm from "@/components/admin/product-form";

export default async function NewProductPage() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/products/new");
  }

  const shopId = session.user.shopId;

  // Get all categories for the shop with hierarchy information
  const allCategories = await db.category.findMany({
    where: { shopId },
    select: {
      id: true,
      name: true,
      parentId: true,
    },
  });

  // Map categories with level information
  // This recursive function determines the depth level of each category
  const addLevelToCategories = (
    categories: any[],
    parentId: string | null = null,
    level = 0
  ) => {
    return categories
      .filter((category) => category.parentId === parentId)
      .map((category) => ({
        id: category.id,
        name: category.name,
        level,
        parentId: category.parentId,
      }));
  };

  // Function to create flat array with correct level
  const createFlatCategoriesWithLevels = (categories: any[]) => {
    // First get all root categories (those with no parent)
    let result = addLevelToCategories(categories);

    // For each root category, recursively add its children
    for (let i = 0; i < result.length; i++) {
      const category = result[i];
      const children = addLevelToCategories(
        categories,
        category.id,
        category.level + 1
      );

      // Insert children after their parent
      if (children.length > 0) {
        result.splice(i + 1, 0, ...children);
        // Skip the children we just added
        i += children.length;
      }
    }

    return result;
  };

  const flatCategories = createFlatCategoriesWithLevels(allCategories);

  // Get all custom fields for the shop
  const customFields = await db.customField.findMany({
    where: { shopId },
    orderBy: { name: "asc" },
  });

  return (
    <div>
      <div className="text-2xl font-bold tracking-tight text-gray-800 mb-6">
        Add New Product
      </div>

      <ProductForm
        categories={flatCategories}
        customFields={customFields}
        shopId={shopId}
      />
    </div>
  );
}

File: ./src/app/admin/products/page.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import Link from "next/link";
import Image from "next/image";
import { useSession } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";
import { formatCurrency } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Card, CardContent } from "@/components/ui/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Plus,
  LayoutGrid,
  List,
  SlidersHorizontal,
  FileDown,
  FilePlus,
  Tag,
  ShoppingBag,
  Loader2,
  ImageIcon,
} from "lucide-react";
import ProductListActions from "@/components/admin/product-list-actions";
import ProductPagination from "@/components/admin/product-pagination";
import ProductFilters from "@/components/admin/product-filters";
import { Badge } from "@/components/ui/badge";
import { apiClient } from "@/lib/api-client";
import { useToast } from "@/components/ui/use-toast";

// Define types for Product and category
interface Category {
  id: string;
  name: string;
  slug?: string;
  level?: number;
  parentId?: string | null;
}

interface ProductCounts {
  variants: number;
  orderItems: number;
}

interface Product {
  id: string;
  name: string;
  description?: string;
  price: number;
  sku?: string;
  barcode?: string;
  inventory: number;
  images: string[];
  categories: Category[];
  _count: ProductCounts;
  discounts: Array<{
    id: string;
    percentage: number;
  }>;
}

export default function ProductsPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const searchParams = useSearchParams();
  const { toast } = useToast();

  // Store the previous search params to prevent unnecessary refetching
  const prevSearchParamsRef = useRef<string>("");

  // State variables
  const [isLoading, setIsLoading] = useState(true);
  const [products, setProducts] = useState<Product[]>([]);
  const [categories, setCategories] = useState<Category[]>([]);
  const [totalProducts, setTotalProducts] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [lowStockThreshold, setLowStockThreshold] = useState(5);
  const [productStats, setProductStats] = useState({
    totalInventory: 0,
    lowStockCount: 0,
    outOfStockCount: 0,
  });
  const [fetchAttempted, setFetchAttempted] = useState(false);

  // Parse query parameters
  const page = parseInt(searchParams.get("page") || "1");
  const perPage = parseInt(searchParams.get("perPage") || "10");
  const sort = searchParams.get("sort") || "createdAt";
  const order = searchParams.get("order") || "desc";
  const search = searchParams.get("search") || "";
  const categoryId = searchParams.get("category") || "";
  const inStock = searchParams.get("inStock") === "true";
  const lowStock = searchParams.get("lowStock") === "true";
  const viewMode = searchParams.get("view") || "list";

  // Create a serialized string of the current search params
  const currentSearchParams = JSON.stringify({
    page,
    perPage,
    sort,
    order,
    search,
    categoryId,
    inStock,
    lowStock,
    viewMode,
  });

  // Fetch data effect
  useEffect(() => {
    // Only run if we have an active session and search params have changed
    if (status === "loading" || !session?.user?.shopId || fetchAttempted) {
      return;
    }

    // Compare with previous search params
    if (prevSearchParamsRef.current === currentSearchParams) {
      return;
    }
    setFetchAttempted(true);

    const fetchData = async () => {
      setIsLoading(true);
      try {
        // Fetch categories only once
        if (categories.length === 0) {
          try {
            const categoriesResponse = await fetch("/api/categories");
            if (categoriesResponse.ok) {
              const categoriesData = await categoriesResponse.json();
              setCategories(categoriesData);
            } else {
              console.error(
                "Failed to fetch categories:",
                categoriesResponse.statusText
              );
              setCategories([]);
            }
          } catch (error) {
            console.error("Error fetching categories:", error);
            setCategories([]);
          }
        }

        // Fetch products
        const productsResponse = await apiClient.products.getProducts({
          page,
          perPage,
          sort,
          order,
          search,
          category: categoryId,
          inStock: inStock ? "true" : undefined,
          lowStock: lowStock ? "true" : undefined,
          view: viewMode,
        });

        setProducts(productsResponse.products);
        setTotalProducts(productsResponse.pagination.total);
        setTotalPages(productsResponse.pagination.totalPages);
        setLowStockThreshold(productsResponse.filter.lowStockThreshold);
        setProductStats(productsResponse.stats);

        // Update previous search params
        prevSearchParamsRef.current = currentSearchParams;
      } catch (error) {
        console.error("Error fetching products:", error);
        toast({
          title: "Error",
          description: "Failed to load products",
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
        setFetchAttempted(false);
      }
    };

    fetchData();
  }, [
    session,
    status,
    currentSearchParams,
    categories.length,
    fetchAttempted,
    toast,
  ]);

  // If loading or not authenticated
  if (status === "loading" || !session) {
    return (
      <div className="flex items-center justify-center h-96">
        <Loader2 className="h-8 w-8 animate-spin text-indigo-500" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            Products
          </h1>
          <p className="text-sm text-gray-500 mt-1">
            Manage your products, inventory, and categories
          </p>
        </div>
        <div className="flex gap-2">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline">
                <SlidersHorizontal className="h-4 w-4 mr-2" />
                Actions
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Product Management</DropdownMenuLabel>
              <DropdownMenuItem asChild>
                <Link
                  href="/admin/products/import"
                  className="flex items-center cursor-pointer"
                >
                  <FileDown className="h-4 w-4 mr-2" />
                  Import Products
                </Link>
              </DropdownMenuItem>
              <DropdownMenuItem asChild>
                <Link
                  href="/admin/products/export"
                  className="flex items-center cursor-pointer"
                >
                  <FilePlus className="h-4 w-4 mr-2" />
                  Export Products
                </Link>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuLabel>View</DropdownMenuLabel>
              <DropdownMenuItem asChild>
                <Link
                  href={`/admin/products?view=list&${searchParams
                    .toString()
                    .replace(/^\?/, "&")
                    .replace(/view=[^&]*&?/, "")}`}
                  className="flex items-center cursor-pointer"
                >
                  <List className="h-4 w-4 mr-2" />
                  List View
                </Link>
              </DropdownMenuItem>
              <DropdownMenuItem asChild>
                <Link
                  href={`/admin/products?view=grid&${searchParams
                    .toString()
                    .replace(/^\?/, "&")
                    .replace(/view=[^&]*&?/, "")}`}
                  className="flex items-center cursor-pointer"
                >
                  <LayoutGrid className="h-4 w-4 mr-2" />
                  Grid View
                </Link>
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
          <Link href="/admin/products/new">
            <Button>
              <Plus className="h-4 w-4 mr-2" />
              Add Product
            </Button>
          </Link>
        </div>
      </div>

      {/* Statistics summary */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
          <div className="text-sm text-gray-500">Total Products</div>
          <div className="text-2xl font-bold text-gray-800 mt-1">
            {totalProducts}
          </div>
        </div>
        <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
          <div className="text-sm text-gray-500">Total Inventory</div>
          <div className="text-2xl font-bold text-gray-800 mt-1">
            {productStats.totalInventory || 0} units
          </div>
        </div>
        <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm">
          <div className="text-sm text-gray-500">Inventory Status</div>
          <div className="flex gap-2 mt-1">
            <Badge
              variant="outline"
              className="bg-amber-50 text-amber-700 border-amber-200"
            >
              {productStats.lowStockCount || 0} Low Stock
            </Badge>
            <Badge
              variant="outline"
              className="bg-red-50 text-red-700 border-red-200"
            >
              {productStats.outOfStockCount || 0} Out of Stock
            </Badge>
          </div>
        </div>
      </div>

      <ProductFilters
        categories={categories}
        currentFilters={{
          search,
          category: categoryId,
          inStock: inStock ? "true" : undefined,
          lowStock: lowStock ? "true" : undefined,
          page: page.toString(),
          perPage: perPage.toString(),
          sort,
          order,
        }}
        lowStockThreshold={lowStockThreshold}
      />

      {isLoading ? (
        <div className="flex items-center justify-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-indigo-500" />
        </div>
      ) : (
        <>
          {/* List View */}
          {viewMode === "list" && (
            <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
              <Table>
                <TableHeader className="bg-gray-50">
                  <TableRow>
                    <TableHead className="text-gray-700">Product</TableHead>
                    <TableHead className="text-gray-700">Price</TableHead>
                    <TableHead className="text-gray-700">Inventory</TableHead>
                    <TableHead className="text-gray-700">Categories</TableHead>
                    <TableHead className="text-gray-700">Variants</TableHead>
                    <TableHead className="text-gray-700">Barcode/SKU</TableHead>
                    <TableHead className="text-gray-700">Discount</TableHead>
                    <TableHead className="text-gray-700">Orders</TableHead>
                    <TableHead className="text-right text-gray-700">
                      Actions
                    </TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {products.length === 0 ? (
                    <TableRow>
                      <TableCell
                        colSpan={9}
                        className="text-center py-8 text-gray-600"
                      >
                        No products found.{" "}
                        <Link
                          href="/admin/products/new"
                          className="text-indigo-600 hover:underline"
                        >
                          Create your first product
                        </Link>
                        .
                      </TableCell>
                    </TableRow>
                  ) : (
                    products.map((product) => (
                      <TableRow key={product.id} className="hover:bg-gray-50">
                        <TableCell>
                          <div className="flex items-center space-x-3">
                            <div className="flex-shrink-0 h-10 w-10 rounded bg-gray-100 flex items-center justify-center overflow-hidden">
                              {product.images && product.images[0] ? (
                                <div className="relative h-full w-full">
                                  <Image
                                    src={product.images[0]}
                                    alt={product.name}
                                    width={40}
                                    height={40}
                                    className="object-cover"
                                    unoptimized
                                    onError={(e) =>
                                      (e.currentTarget.src = "/placeholder.jpg")
                                    }
                                  />
                                </div>
                              ) : (
                                <div className="text-gray-400 text-xs">
                                  No image
                                </div>
                              )}
                            </div>
                            <div>
                              <Link
                                href={`/admin/products/${product.id}`}
                                className="font-medium text-gray-800 hover:text-indigo-600 hover:underline"
                              >
                                {product.name}
                              </Link>
                              {product.description && (
                                <div className="text-xs text-gray-500 mt-0.5 max-w-xs truncate">
                                  {product.description}
                                </div>
                              )}
                            </div>
                          </div>
                        </TableCell>
                        <TableCell className="text-gray-700">
                          {formatCurrency(product.price)}
                          {product.discounts &&
                            product.discounts.length > 0 && (
                              <div className="text-xs text-green-500">
                                {product.discounts[0].percentage}% OFF
                              </div>
                            )}
                        </TableCell>
                        <TableCell>
                          <span
                            className={
                              product.inventory <= 0
                                ? "text-red-500 font-medium"
                                : product.inventory <= lowStockThreshold
                                ? "text-amber-500 font-medium"
                                : "text-gray-700"
                            }
                          >
                            {product.inventory}
                          </span>
                          {product.inventory <= lowStockThreshold &&
                            product.inventory > 0 && (
                              <span className="ml-2 text-xs text-amber-500">
                                (Low)
                              </span>
                            )}
                        </TableCell>
                        <TableCell className="text-gray-700">
                          <div className="flex flex-wrap gap-1">
                            {product.categories &&
                            product.categories.length > 0 ? (
                              product.categories.map((category) => (
                                <Badge
                                  key={category.id}
                                  variant="outline"
                                  className="bg-blue-50 text-blue-700 border-blue-200"
                                >
                                  {category.name}
                                </Badge>
                              ))
                            ) : (
                              <span className="text-gray-400 text-xs">
                                No categories
                              </span>
                            )}
                          </div>
                        </TableCell>
                        <TableCell className="text-gray-700">
                          {product._count && product._count.variants > 0 ? (
                            <Badge
                              variant="outline"
                              className="bg-purple-50 text-purple-700 border-purple-200"
                            >
                              {product._count.variants} variants
                            </Badge>
                          ) : (
                            <span className="text-gray-400 text-xs">
                              No variants
                            </span>
                          )}
                        </TableCell>
                        <TableCell className="text-gray-700">
                          <div className="text-xs">
                            {product.barcode && (
                              <div className="flex items-center">
                                <span className="text-gray-500 mr-1">
                                  Barcode:
                                </span>
                                <span className="text-gray-700">
                                  {product.barcode}
                                </span>
                              </div>
                            )}
                            {product.sku && (
                              <div className="flex items-center">
                                <span className="text-gray-500 mr-1">SKU:</span>
                                <span className="text-gray-700">
                                  {product.sku}
                                </span>
                              </div>
                            )}
                            {!product.barcode && !product.sku && (
                              <span className="text-gray-400">Not set</span>
                            )}
                          </div>
                        </TableCell>
                        <TableCell>
                          {product.discounts && product.discounts.length > 0 ? (
                            <div className="flex items-center">
                              <Tag className="h-3 w-3 text-green-600 mr-1" />
                              <span className="text-green-600 font-medium">
                                {product.discounts[0].percentage}% OFF
                              </span>
                            </div>
                          ) : (
                            <span className="text-gray-400 text-xs">
                              No discount
                            </span>
                          )}
                        </TableCell>
                        <TableCell>
                          {product._count && product._count.orderItems > 0 ? (
                            <div className="flex items-center">
                              <Link
                                href={`/admin/orders?product=${product.id}`}
                                className="flex items-center text-blue-600 hover:text-blue-800 hover:underline"
                              >
                                <ShoppingBag className="h-3 w-3 mr-1" />
                                <span>{product._count.orderItems}</span>
                              </Link>
                            </div>
                          ) : (
                            <span className="text-gray-400 text-xs">None</span>
                          )}
                        </TableCell>
                        <TableCell className="text-right">
                          <ProductListActions
                            productId={product.id}
                            onDelete={() => {
                              setProducts((prev) =>
                                prev.filter((p) => p.id !== product.id)
                              );
                            }}
                          />
                        </TableCell>
                      </TableRow>
                    ))
                  )}
                </TableBody>
              </Table>
            </div>
          )}

          {/* Grid View */}
          {viewMode === "grid" && (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
              {products.length === 0 ? (
                <div className="col-span-full bg-white border border-gray-200 rounded-lg p-6 text-center">
                  <p className="text-gray-600">
                    No products found.{" "}
                    <Link
                      href="/admin/products/new"
                      className="text-indigo-600 hover:underline"
                    >
                      Create your first product
                    </Link>
                    .
                  </p>
                </div>
              ) : (
                products.map((product) => (
                  <Card key={product.id} className="overflow-hidden">
                    <div className="h-48 bg-gray-100 relative">
                      {product.images && product.images[0] ? (
                        <div className="relative h-full w-full">
                          <Image
                            src={product.images[0]}
                            alt={product.name}
                            fill
                            className="object-cover"
                            unoptimized
                          />
                        </div>
                      ) : (
                        <div className="flex items-center justify-center h-full text-gray-400">
                          <ImageIcon className="h-12 w-12 opacity-20" />
                        </div>
                      )}

                      {/* Discount tag */}
                      {product.discounts && product.discounts.length > 0 && (
                        <div className="absolute top-2 right-2 bg-green-600 text-white px-2 py-1 rounded text-xs font-bold">
                          {product.discounts[0].percentage}% OFF
                        </div>
                      )}

                      {/* Inventory status */}
                      <div className="absolute bottom-2 right-2">
                        {product.inventory <= 0 ? (
                          <Badge variant="destructive">Out of stock</Badge>
                        ) : product.inventory <= lowStockThreshold ? (
                          <Badge
                            variant="outline"
                            className="bg-amber-100 text-amber-800 border-amber-200"
                          >
                            Low stock: {product.inventory}
                          </Badge>
                        ) : (
                          <Badge
                            variant="outline"
                            className="bg-green-100 text-green-800 border-green-200"
                          >
                            In stock: {product.inventory}
                          </Badge>
                        )}
                      </div>
                    </div>
                    <CardContent className="p-4">
                      <h3 className="font-medium text-gray-800 mb-1 truncate">
                        <Link
                          href={`/admin/products/${product.id}`}
                          className="hover:text-indigo-600 hover:underline"
                        >
                          {product.name}
                        </Link>
                      </h3>
                      <div className="flex justify-between items-center mb-2">
                        <div className="text-gray-700 font-medium">
                          {formatCurrency(product.price)}
                        </div>
                        <div className="text-xs text-gray-500">
                          {product._count &&
                            product._count.variants > 0 &&
                            `${product._count.variants} variants`}
                        </div>
                      </div>

                      {/* Categories */}
                      {product.categories && product.categories.length > 0 && (
                        <div className="flex flex-wrap gap-1 mb-2">
                          {product.categories.slice(0, 2).map((category) => (
                            <Badge
                              key={category.id}
                              variant="outline"
                              className="bg-blue-50 text-blue-700 border-blue-200 text-xs"
                            >
                              {category.name}
                            </Badge>
                          ))}
                          {product.categories.length > 2 && (
                            <Badge
                              variant="outline"
                              className="bg-gray-50 text-gray-700 border-gray-200 text-xs"
                            >
                              +{product.categories.length - 2} more
                            </Badge>
                          )}
                        </div>
                      )}

                      <div className="mt-4 flex justify-between items-center">
                        <span className="text-xs text-gray-500">
                          {product._count && product._count.orderItems > 0 ? (
                            <Link
                              href={`/admin/orders?product=${product.id}`}
                              className="flex items-center text-gray-600 hover:text-indigo-600 hover:underline"
                            >
                              <ShoppingBag className="h-3 w-3 mr-1" />
                              {product._count.orderItems} orders
                            </Link>
                          ) : (
                            "No orders"
                          )}
                        </span>
                        <ProductListActions
                          productId={product.id}
                          onDelete={() => {
                            setProducts((prev) =>
                              prev.filter((p) => p.id !== product.id)
                            );
                          }}
                        />
                      </div>
                    </CardContent>
                  </Card>
                ))
              )}
            </div>
          )}

          <ProductPagination
            currentPage={page}
            totalPages={totalPages}
            totalItems={totalProducts}
          />
        </>
      )}
    </div>
  );
}

File: ./src/app/admin/categories/page.tsx
"use client";
import React, { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { useSession } from "next-auth/react";
import { useToast } from "@/components/ui/use-toast";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import CategoryForm from "@/components/admin/category-form";
import { formatDate } from "@/lib/utils";
import {
  Layers,
  Search,
  X,
  ChevronRight,
  FolderTree,
  Plus,
  Folder,
  Edit,
  Trash,
  ChevronDown,
} from "lucide-react";

interface Category {
  id: string;
  name: string;
  slug: string;
  description?: string;
  image?: string;
  parentId: string | null;
  level: number;
  createdAt: string;
  updatedAt: string;
  _count?: {
    products: number;
    children: number;
  };
  totalProducts?: number;
}

interface HierarchicalCategory extends Category {
  children: HierarchicalCategory[];
}

export default function CategoriesPage() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const searchParams = useSearchParams();
  const { toast } = useToast();
  const [categories, setCategories] = useState<Category[]>([]);
  const [hierarchicalCategories, setHierarchicalCategories] = useState<
    HierarchicalCategory[]
  >([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  const [categoryToDelete, setCategoryToDelete] = useState<Category | null>(
    null
  );
  const [isDeleting, setIsDeleting] = useState(false);
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(
    new Set()
  );

  useEffect(() => {
    if (status === "loading") {
      return;
    }
    if (!session?.user?.shopId) {
      router.push("/login?callbackUrl=/admin/categories");
      return;
    }
    fetchCategories();
  }, [session, status, router]);

  // Fetch categories from API
  const fetchCategories = async () => {
    setIsLoading(true);
    try {
      const response = await fetch(`/api/categories?withProductCount=true`);
      if (!response.ok) {
        throw new Error("Failed to fetch categories");
      }
      const data = await response.json();
      setCategories(data);

      // Organize categories into hierarchical structure
      const hierarchical = organizeCategoriesHierarchically(data);
      setHierarchicalCategories(hierarchical);

      const allCategoryIds = new Set<string>(
        data.map((category: Category) => category.id)
      );

      setExpandedCategories(allCategoryIds);
    } catch (error) {
      console.error("Error fetching categories:", error);
      toast({
        title: "Error",
        description: "Failed to load categories",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Convert flat categories array to hierarchical structure
  const organizeCategoriesHierarchically = (
    flatCategories: Category[]
  ): HierarchicalCategory[] => {
    // Create a map to quickly look up categories by ID
    const categoryMap = new Map<string, HierarchicalCategory>();

    // Initialize hierarchical categories with empty children arrays
    flatCategories.forEach((category) => {
      categoryMap.set(category.id, { ...category, children: [] });
    });

    // Build the hierarchy by assigning children to their parents
    const rootCategories: HierarchicalCategory[] = [];

    // First pass: assign children to parents
    flatCategories.forEach((category) => {
      if (category.parentId && categoryMap.has(category.parentId)) {
        // This is a child - add it to its parent's children array
        const parent = categoryMap.get(category.parentId)!;
        const child = categoryMap.get(category.id)!;
        parent.children.push(child);
      } else if (!category.parentId) {
        // This is a root category
        rootCategories.push(categoryMap.get(category.id)!);
      }
    });

    // Sort root categories by name
    rootCategories.sort((a, b) => a.name.localeCompare(b.name));

    // Sort each parent's children by name
    const sortChildrenRecursively = (categories: HierarchicalCategory[]) => {
      categories.forEach((category) => {
        if (category.children.length > 0) {
          category.children.sort((a, b) => a.name.localeCompare(b.name));
          sortChildrenRecursively(category.children);
        }
      });
    };

    sortChildrenRecursively(rootCategories);

    return rootCategories;
  };

  // Toggle category expansion
  const toggleCategoryExpansion = (categoryId: string) => {
    const newExpanded = new Set(expandedCategories);
    if (expandedCategories.has(categoryId)) {
      newExpanded.delete(categoryId);
    } else {
      newExpanded.add(categoryId);
    }
    setExpandedCategories(newExpanded);
  };

  const handleEditCategory = (category: Category) => {
    setEditingCategory(category);
    setIsFormOpen(true);
  };

  const handleDeleteCategory = async () => {
    if (!categoryToDelete) return;
    setIsDeleting(true);
    try {
      const response = await fetch(`/api/categories/${categoryToDelete.id}`, {
        method: "DELETE",
      });
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Failed to delete category");
      }
      // Show success message
      toast({
        title: "Success",
        description: "Category deleted successfully",
      });
      // Refresh categories list
      fetchCategories();
    } catch (error: any) {
      toast({
        title: "Error",
        description: error.message || "Failed to delete category",
        variant: "destructive",
      });
    } finally {
      setIsDeleting(false);
      setCategoryToDelete(null);
    }
  };

  const handleFormClose = (refreshData = false) => {
    setIsFormOpen(false);
    setEditingCategory(null);
    if (refreshData) {
      fetchCategories();
    }
  };

  const handleAddCategory = () => {
    setEditingCategory(null);
    setIsFormOpen(true);
  };

  // Filter hierarchical categories based on search term
  const filterHierarchicalCategories = (
    categories: HierarchicalCategory[],
    searchTerm: string
  ): HierarchicalCategory[] => {
    if (!searchTerm) return categories;

    return categories
      .filter((category) => {
        // Check if this category matches the search term
        const nameMatches = category.name
          .toLowerCase()
          .includes(searchTerm.toLowerCase());

        // Filter this category's children
        const filteredChildren = filterHierarchicalCategories(
          category.children,
          searchTerm
        );

        // Keep this category if its name matches or if any child matches
        return nameMatches || filteredChildren.length > 0;
      })
      .map((category) => {
        // Return a new object with filtered children
        if (category.children.length === 0) {
          return category;
        }

        return {
          ...category,
          children: filterHierarchicalCategories(category.children, searchTerm),
        };
      });
  };

  const filteredCategories = filterHierarchicalCategories(
    hierarchicalCategories,
    searchTerm
  );

  // Recursively render categories with proper hierarchy
  const renderCategoryRow = (category: HierarchicalCategory, index: number) => {
    const hasChildren = category.children.length > 0;
    const isExpanded = expandedCategories.has(category.id);
    const rowKey = `category-${category.id}-${index}`;

    return (
      <React.Fragment key={rowKey}>
        <TableRow className="hover:bg-gray-50">
          <TableCell className="py-2">
            <div className="flex items-center relative">
              {/* Indentation and hierarchy indicators */}
              <div
                className="flex items-center"
                style={{
                  marginLeft: `${category.level * 24}px`,
                  position: "relative",
                }}
              >
                {category.level > 0 && (
                  <div className="relative flex items-center h-full">
                    {/* Horizontal line to category */}
                    <div
                      className="absolute w-6 h-0 border-t-2 border-gray-200"
                      style={{ left: "-12px", top: "50%" }}
                    ></div>
                  </div>
                )}

                <div className="flex items-center z-10 bg-white">
                  {/* Always reserve space for the expand/collapse control for consistent alignment */}
                  {hasChildren ? (
                    <button
                      onClick={() => toggleCategoryExpansion(category.id)}
                      className="mr-1 p-1 rounded hover:bg-gray-100 text-gray-700 focus:outline-none"
                    >
                      {isExpanded ? (
                        <ChevronDown className="h-4 w-4" />
                      ) : (
                        <ChevronRight className="h-4 w-4" />
                      )}
                    </button>
                  ) : (
                    <span className="mr-1 p-1 w-6 text-center text-gray-400">
                      --
                    </span>
                  )}

                  {/* Category icon and name */}
                  <Folder
                    className={`h-4 w-4 mr-2 ${
                      hasChildren ? "text-indigo-500" : "text-gray-500"
                    }`}
                  />
                  <span className="font-medium text-gray-800">
                    {category.name}
                  </span>
                </div>
              </div>
            </div>
          </TableCell>
          <TableCell className="text-gray-600 truncate max-w-[200px]">
            {category.description || "—"}
          </TableCell>
          <TableCell>
            {category._count?.products || 0}/{category.totalProducts || 0}
          </TableCell>
          <TableCell>{category._count?.children || 0}</TableCell>
          <TableCell>{formatDate(category.createdAt)}</TableCell>
          <TableCell>
            <div className="flex gap-2 justify-end">
              <Button
                variant="ghost"
                size="sm"
                onClick={() => handleEditCategory(category)}
                className="text-gray-500 hover:text-blue-600"
              >
                <Edit className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setCategoryToDelete(category)}
                className="text-gray-500 hover:text-red-600"
                disabled={
                  (category._count?.children || 0) > 0 ||
                  (category._count?.products || 0) > 0
                }
                title={
                  (category._count?.children || 0) > 0
                    ? "Cannot delete category with subcategories"
                    : (category._count?.products || 0) > 0
                    ? "Cannot delete category with products"
                    : "Delete category"
                }
              >
                <Trash className="h-4 w-4" />
              </Button>
            </div>
          </TableCell>
        </TableRow>

        {/* Render child categories if expanded */}
        {isExpanded &&
          hasChildren &&
          category.children.map((child, childIndex) =>
            renderCategoryRow(child, childIndex)
          )}
      </React.Fragment>
    );
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            Categories
          </h1>
          <p className="text-gray-500 mt-1">
            Manage your product categories and subcategories
          </p>
        </div>
        <Button onClick={handleAddCategory}>
          <Plus className="mr-2 h-4 w-4" />
          Add Category
        </Button>
      </div>
      <div className="bg-white p-4 rounded-lg shadow border border-gray-200">
        <div className="flex justify-between items-center mb-4">
          <div className="relative w-64">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <Input
              placeholder="Search categories..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10"
            />
            {searchTerm && (
              <button
                onClick={() => setSearchTerm("")}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
              >
                <X className="h-4 w-4" />
              </button>
            )}
          </div>
          <div className="flex items-center gap-2">
            <FolderTree className="h-5 w-5 text-gray-500" />
            <span className="text-gray-600">
              {categories.length} categories in total
            </span>
          </div>
        </div>
        <div className="rounded-md border">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-56">Name</TableHead>
                <TableHead>Description</TableHead>
                <TableHead className="w-32">
                  <div title="Direct/Total">Products</div>
                </TableHead>
                <TableHead className="w-32">Subcategories</TableHead>
                <TableHead className="w-32">Created</TableHead>
                <TableHead className="text-right w-24">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {isLoading ? (
                <TableRow>
                  <TableCell colSpan={6} className="h-24 text-center">
                    <div className="flex justify-center items-center">
                      <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-indigo-500"></div>
                      <span className="ml-2 text-gray-500">
                        Loading categories...
                      </span>
                    </div>
                  </TableCell>
                </TableRow>
              ) : filteredCategories.length === 0 ? (
                <TableRow>
                  <TableCell
                    colSpan={6}
                    className="h-24 text-center text-gray-500"
                  >
                    {categories.length === 0
                      ? "No categories found. Create your first category to get started."
                      : "No categories match your search criteria."}
                  </TableCell>
                </TableRow>
              ) : (
                filteredCategories.map((category, index) =>
                  renderCategoryRow(category, index)
                )
              )}
            </TableBody>
          </Table>
        </div>
      </div>

      {/* Category Form Dialog */}
      {isFormOpen && (
        <CategoryForm
          isOpen={isFormOpen}
          onClose={handleFormClose}
          category={editingCategory}
          categories={categories.filter(
            (c) => !editingCategory || c.id !== editingCategory.id
          )}
        />
      )}

      {/* Delete Confirmation Dialog */}
      <AlertDialog
        open={!!categoryToDelete}
        onOpenChange={(open) => !open && setCategoryToDelete(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This will permanently delete the category. This action cannot be
              undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteCategory}
              className="bg-red-600 text-white hover:bg-red-700"
              disabled={isDeleting}
            >
              {isDeleting ? "Deleting..." : "Delete"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

File: ./src/app/admin/discounts/[id]/page.tsx
// src/app/admin/discounts/[id]/page.tsx
import { getServerSession } from "next-auth/next";
import { redirect, notFound } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import DiscountForm from "@/components/admin/discount-form";

interface EditDiscountPageProps {
  params: {
    id: string;
  };
}

export default async function EditDiscountPage({
  params,
}: EditDiscountPageProps) {
  // Check authentication
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/discounts");
  }

  const shopId = session.user.shopId;
  const discountId = params.id;

  // Get the discount (with validation that it belongs to this shop)
  const discount = await db.discount.findFirst({
    where: {
      id: discountId,
      product: {
        shopId,
      },
    },
    include: {
      product: {
        select: {
          id: true,
          name: true,
          price: true,
        },
      },
    },
  });

  if (!discount) {
    notFound();
  }

  // Get all products for the shop
  const products = await db.product.findMany({
    where: { shopId },
    select: {
      id: true,
      name: true,
      price: true,
    },
    orderBy: {
      name: "asc",
    },
  });

  return (
    <div>
      <h1 className="text-2xl font-bold tracking-tight text-gray-800 mb-6">
        Edit Discount for {discount.product.name}
      </h1>

      <DiscountForm
        discount={discount}
        products={products}
        shopId={shopId}
        isEditing
      />
    </div>
  );
}

File: ./src/app/admin/discounts/new/page.tsx
// src/app/admin/discounts/new/page.tsx
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import DiscountForm from "@/components/admin/discount-form";

export default async function NewDiscountPage() {
  // Check authentication
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/discounts/new");
  }

  const shopId = session.user.shopId;

  // Get all products for the shop (for the product dropdown)
  const products = await db.product.findMany({
    where: { shopId },
    select: {
      id: true,
      name: true,
      price: true,
    },
    orderBy: {
      name: "asc",
    },
  });

  return (
    <div>
      <h1 className="text-2xl font-bold tracking-tight text-gray-800 mb-6">
        Create New Discount
      </h1>

      <DiscountForm products={products} shopId={shopId} />
    </div>
  );
}

File: ./src/app/admin/discounts/page.tsx
// src/app/admin/discounts/page.tsx
import { getServerSession } from "next-auth/next";
import Link from "next/link";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableHeader,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@/components/ui/table";
import { Plus } from "lucide-react";
import DiscountListActions from "@/components/admin/discount-list-actions";
import Pagination from "@/components/admin/pagination";

interface DiscountsPageProps {
  searchParams: {
    [key: string]: string | string[] | undefined;
  };
}

export default async function DiscountsPage({
  searchParams,
}: DiscountsPageProps) {
  // Check authentication
  const session = await getServerSession(authOptions);
  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/discounts");
  }
  const shopId = session.user.shopId;

  // Parse pagination params safely
  const page = parseInt(String(searchParams.page) || "1");
  const perPage = parseInt(String(searchParams.perPage) || "10");
  const productId = searchParams.product
    ? String(searchParams.product)
    : undefined;

  // Build where clause for filtering
  const where: any = {
    product: {
      shopId,
    },
  };

  // Filter by specific product if requested
  if (productId) {
    where.productId = productId;
  }

  // Count total discounts for pagination
  const totalDiscounts = await db.discount.count({
    where,
  });

  // Calculate total pages
  const totalPages = Math.ceil(totalDiscounts / perPage);

  // Get discounts with pagination
  const discounts = await db.discount.findMany({
    where,
    include: {
      product: {
        select: {
          id: true,
          name: true,
          price: true,
        },
      },
    },
    orderBy: {
      createdAt: "desc",
    },
    skip: (page - 1) * perPage,
    take: perPage,
  });

  // Get product info if filtering by product
  let productInfo = null;
  if (productId) {
    productInfo = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
      select: {
        id: true,
        name: true,
      },
    });
  }

  // Format dates for display
  const formatDate = (date: Date | string) => {
    return new Date(date).toLocaleDateString();
  };

  // Calculate the price after discount
  const getDiscountedPrice = (price: number, discountPercentage: number) => {
    const discount = (price * discountPercentage) / 100;
    return (price - discount).toFixed(2);
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold tracking-tight text-gray-800">
            {productInfo
              ? `Discounts for ${productInfo.name}`
              : "All Discounts"}
          </h1>
          {productInfo && (
            <p className="text-gray-500">
              <Link
                href="/admin/discounts"
                className="text-indigo-600 hover:underline"
              >
                Back to all discounts
              </Link>
            </p>
          )}
        </div>
        <Link href="/admin/discounts/new">
          <Button>
            <Plus className="mr-2 h-4 w-4" />
            Add Discount
          </Button>
        </Link>
      </div>

      <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
        <Table>
          <TableHeader className="bg-gray-50">
            <TableRow>
              <TableHead className="text-gray-700">Product</TableHead>
              <TableHead className="text-gray-700">Percentage</TableHead>
              <TableHead className="text-gray-700">Original Price</TableHead>
              <TableHead className="text-gray-700">Discounted Price</TableHead>
              <TableHead className="text-gray-700">Valid Period</TableHead>
              <TableHead className="text-gray-700">Status</TableHead>
              <TableHead className="text-right text-gray-700">
                Actions
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {discounts.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={7}
                  className="text-center py-8 text-gray-600"
                >
                  No discounts found.{" "}
                  <Link
                    href="/admin/discounts/new"
                    className="text-indigo-600 hover:underline"
                  >
                    Add your first discount
                  </Link>
                  .
                </TableCell>
              </TableRow>
            ) : (
              discounts.map((discount) => (
                <TableRow key={discount.id}>
                  <TableCell>
                    <Link
                      href={`/admin/products/${discount.product.id}`}
                      className="font-medium text-indigo-600 hover:underline"
                    >
                      {discount.product.name}
                    </Link>
                  </TableCell>
                  <TableCell className="font-medium">
                    {discount.percentage}%
                  </TableCell>
                  <TableCell>${discount.product.price.toFixed(2)}</TableCell>
                  <TableCell className="text-green-600">
                    $
                    {getDiscountedPrice(
                      discount.product.price,
                      discount.percentage
                    )}
                  </TableCell>
                  <TableCell>
                    {formatDate(discount.startDate)} to{" "}
                    {formatDate(discount.endDate)}
                  </TableCell>
                  <TableCell>
                    <span
                      className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                        discount.enabled
                          ? "bg-green-100 text-green-800"
                          : "bg-gray-100 text-gray-800"
                      }`}
                    >
                      {discount.enabled ? "Active" : "Inactive"}
                    </span>
                  </TableCell>
                  <TableCell className="text-right">
                    <DiscountListActions discountId={discount.id} />
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      <Pagination
        currentPage={page}
        totalPages={totalPages}
        totalItems={totalDiscounts}
      />
    </div>
  );
}

File: ./src/app/admin/custom-fields/page.tsx
// src/app/admin/custom-fields/page.tsx (with improved contrast)
import { getServerSession } from "next-auth/next";
import { redirect } from "next/navigation";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import CustomFieldsTable from "@/components/admin/custom-fields-table";
import AddCustomFieldForm from "@/components/admin/add-custom-field-form";
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
} from "@/components/ui/card";

export default async function CustomFieldsPage() {
  // Check authentication and authorization
  const session = await getServerSession(authOptions);

  if (!session?.user?.shopId) {
    redirect("/login?callbackUrl=/admin/custom-fields");
  }

  const shopId = session.user.shopId;

  // Fetch all custom fields for this shop
  const customFields = await db.customField.findMany({
    where: { shopId },
    orderBy: { name: "asc" },
  });

  // Count products using each custom field
  const fieldsWithUsage = await Promise.all(
    customFields.map(async (field) => {
      const usageCount = await db.customFieldValue.count({
        where: { customFieldId: field.id },
      });

      return {
        ...field,
        usageCount,
      };
    })
  );

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold tracking-tight text-gray-800">
          Custom Fields
        </h1>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="md:col-span-2">
          <Card className="border-indigo-200 shadow-sm">
            <CardHeader className="bg-indigo-50 border-b border-indigo-200">
              <CardTitle className="text-indigo-800 font-semibold">
                Custom Fields List
              </CardTitle>
              <CardDescription className="text-indigo-700">
                Manage custom fields for your products
              </CardDescription>
            </CardHeader>
            <CardContent className="p-0 bg-white">
              <CustomFieldsTable customFields={fieldsWithUsage} />
            </CardContent>
          </Card>
        </div>

        <div>
          <Card className="border-indigo-200 shadow-sm">
            <CardHeader className="bg-indigo-50 border-b border-indigo-200">
              <CardTitle className="text-indigo-800 font-semibold">
                Add Custom Field
              </CardTitle>
              <CardDescription className="text-indigo-700">
                Create a new custom field for your products
              </CardDescription>
            </CardHeader>
            <CardContent className="pt-6 bg-white">
              <AddCustomFieldForm />
            </CardContent>
          </Card>

          <div className="mt-6">
            <Card className="border-blue-300 shadow-sm">
              <CardHeader className="bg-blue-100 border-b border-blue-200">
                <CardTitle className="text-blue-800 text-lg font-semibold">
                  About Custom Fields
                </CardTitle>
              </CardHeader>
              <CardContent className="pt-4 bg-white">
                <p className="text-blue-800 text-sm">
                  Custom fields allow you to add additional information to your
                  products beyond the standard fields. This is useful for:
                </p>
                <ul className="list-disc list-inside mt-2 text-blue-800 text-sm space-y-1">
                  <li>Product specifications (material, dimensions, etc.)</li>
                  <li>
                    Technical information (compatibility, system requirements)
                  </li>
                  <li>Additional product details (origin, certification)</li>
                  <li>And any other product-specific information</li>
                </ul>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
}

File: ./src/app/api/auth/register/route.ts
// src/app/api/auth/register/route.ts
import { NextRequest, NextResponse } from "next/server";
import bcrypt from "bcrypt";
import { db } from "@/lib/prisma";
import { z } from "zod";

// Validation schema
const registerSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  shopId: z.string().optional(),
});

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    // Validate input
    const validation = registerSchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.errors[0].message },
        { status: 400 }
      );
    }

    const { name, email, password, shopId } = validation.data;

    // Check if user already exists
    const existingUser = await db.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return NextResponse.json(
        { error: "Email already in use" },
        { status: 400 }
      );
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Determine role based on context
    // For subdomain shops, create a customer account by default
    let role = "CUSTOMER";

    // Create user
    const user = await db.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
        role,
        shopId: shopId || null, // Associate with shop if provided
      },
    });

    // Don't send password back
    const { password: _, ...userWithoutPassword } = user;

    return NextResponse.json(userWithoutPassword, { status: 201 });
  } catch (error) {
    console.error("Registration error:", error);
    return NextResponse.json({ error: "Registration failed" }, { status: 500 });
  }
}

File: ./src/app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

File: ./src/app/api/discount-codes/[id]/route.ts
// src/app/api/discount-codes/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET a specific discount code
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountCodeId = params.id;

    // Get the discount code
    const discountCode = await db.discountCode.findFirst({
      where: {
        id: discountCodeId,
        shopId,
      },
      include: {
        product: {
          select: {
            name: true,
          },
        },
        user: {
          select: {
            name: true,
            email: true,
          },
        },
      },
    });

    if (!discountCode) {
      return NextResponse.json(
        { error: "Discount code not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(discountCode);
  } catch (error) {
    console.error("Error fetching discount code:", error);
    return NextResponse.json(
      { error: "Failed to fetch discount code" },
      { status: 500 }
    );
  }
}

// UPDATE a discount code
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountCodeId = params.id;
    const body = await req.json();
    const {
      code,
      percentage,
      startDate,
      endDate,
      productId,
      userId,
      isActive,
    } = body;

    // Verify the discount code exists and belongs to this shop
    const existingCode = await db.discountCode.findFirst({
      where: {
        id: discountCodeId,
        shopId,
      },
    });

    if (!existingCode) {
      return NextResponse.json(
        { error: "Discount code not found" },
        { status: 404 }
      );
    }

    // Check if updated code already exists (if it's being changed)
    if (code && code !== existingCode.code) {
      const duplicateCode = await db.discountCode.findFirst({
        where: {
          shopId,
          code: {
            equals: code,
            mode: "insensitive",
          },
          id: {
            not: discountCodeId,
          },
        },
      });

      if (duplicateCode) {
        return NextResponse.json(
          { error: "A discount code with this code already exists" },
          { status: 400 }
        );
      }
    }

    // Verify the product belongs to this shop if it's being changed
    if (productId && productId !== existingCode.productId) {
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: "Product not found" },
          { status: 404 }
        );
      }
    }

    // Verify the user belongs to this shop if it's being changed
    if (userId && userId !== existingCode.userId) {
      const user = await db.user.findUnique({
        where: {
          id: userId,
          shopId,
        },
      });

      if (!user) {
        return NextResponse.json({ error: "User not found" }, { status: 404 });
      }
    }

    // Update the discount code
    const updatedDiscountCode = await db.discountCode.update({
      where: { id: discountCodeId },
      data: {
        code: code ? code.toUpperCase() : undefined,
        percentage: percentage !== undefined ? parseInt(percentage) : undefined,
        startDate: startDate ? new Date(startDate) : undefined,
        endDate: endDate ? new Date(endDate) : undefined,
        productId: productId === undefined ? undefined : productId || null,
        userId: userId === undefined ? undefined : userId || null,
        isActive: isActive !== undefined ? isActive === true : undefined,
      },
    });

    return NextResponse.json(updatedDiscountCode);
  } catch (error) {
    console.error("Error updating discount code:", error);
    return NextResponse.json(
      { error: "Failed to update discount code" },
      { status: 500 }
    );
  }
}

// DELETE a discount code
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountCodeId = params.id;

    // Verify the discount code exists and belongs to this shop
    const discountCode = await db.discountCode.findFirst({
      where: {
        id: discountCodeId,
        shopId,
      },
    });

    if (!discountCode) {
      return NextResponse.json(
        { error: "Discount code not found" },
        { status: 404 }
      );
    }

    // Delete the discount code
    await db.discountCode.delete({
      where: { id: discountCodeId },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting discount code:", error);
    return NextResponse.json(
      { error: "Failed to delete discount code" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/discount-codes/route.ts
// src/app/api/discount-codes/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET: List discount codes
export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const { searchParams } = new URL(req.url);
    const productId = searchParams.get("productId");

    // Build the where clause
    const where: any = { shopId };

    // Add product filter if provided
    if (productId) {
      where.productId = productId;

      // Verify the product belongs to this shop
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: "Product not found" },
          { status: 404 }
        );
      }
    }

    // Get discount codes
    const discountCodes = await db.discountCode.findMany({
      where,
      include: {
        product: {
          select: {
            name: true,
          },
        },
        user: {
          select: {
            name: true,
            email: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json(discountCodes);
  } catch (error) {
    console.error("Error fetching discount codes:", error);
    return NextResponse.json(
      { error: "Failed to fetch discount codes" },
      { status: 500 }
    );
  }
}

// POST: Create a new discount code
export async function POST(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const body = await req.json();
    const {
      code,
      percentage,
      startDate,
      endDate,
      productId,
      userId,
      isActive,
    } = body;

    // Validate required fields
    if (!code || !percentage || !startDate || !endDate) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Check if code already exists for this shop
    const existingCode = await db.discountCode.findFirst({
      where: {
        shopId,
        code: {
          equals: code,
          mode: "insensitive", // Case insensitive
        },
      },
    });

    if (existingCode) {
      return NextResponse.json(
        { error: "A discount code with this code already exists" },
        { status: 400 }
      );
    }

    // Verify the product belongs to this shop if provided
    if (productId) {
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: "Product not found" },
          { status: 404 }
        );
      }
    }

    // Verify the user belongs to this shop if provided
    if (userId) {
      const user = await db.user.findUnique({
        where: {
          id: userId,
          shopId,
        },
      });

      if (!user) {
        return NextResponse.json({ error: "User not found" }, { status: 404 });
      }
    }

    // Create the discount code
    const discountCode = await db.discountCode.create({
      data: {
        code: code.toUpperCase(), // Store in uppercase
        percentage: parseInt(percentage),
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        shopId,
        productId: productId || null,
        userId: userId || null,
        isActive: isActive === true,
      },
    });

    return NextResponse.json(discountCode, { status: 201 });
  } catch (error) {
    console.error("Error creating discount code:", error);
    return NextResponse.json(
      { error: "Failed to create discount code" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/orders/[id]/route.ts
// src/app/api/orders/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET a specific order
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const orderId = params.id;

    // Get the order with all details
    const order = await db.order.findUnique({
      where: {
        id: orderId,
        shopId, // Ensure it belongs to this shop
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        address: true,
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                slug: true,
                images: true,
              },
            },
            variant: {
              select: {
                id: true,
                name: true,
                options: true,
              },
            },
          },
        },
        invoice: true,
      },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    return NextResponse.json(order);
  } catch (error) {
    console.error("Error fetching order:", error);
    return NextResponse.json(
      { error: "Failed to fetch order" },
      { status: 500 }
    );
  }
}

// UPDATE an order's status
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user?.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const orderId = params.id;
    const body = await req.json();

    // Extract update fields
    const { status, paymentStatus, shippingStatus, notes } = body;

    // Validate order belongs to this shop
    const order = await db.order.findUnique({
      where: {
        id: orderId,
        shopId,
      },
      select: { id: true },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // Update the order
    const updatedOrder = await db.order.update({
      where: { id: orderId },
      data: {
        status: status || undefined,
        paymentStatus: paymentStatus || undefined,
        shippingStatus: shippingStatus || undefined,
        notes: notes !== undefined ? notes : undefined,
        updatedAt: new Date(),
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        address: true,
        items: true,
        invoice: true,
      },
    });

    // Generate automatic notification if status changed
    if (status && status !== order.status) {
      await db.notification.create({
        data: {
          title: `Order ${updatedOrder.orderNumber} Updated`,
          message: `Your order status has been updated to ${status}`,
          type: "ORDER_UPDATE",
          userId: updatedOrder.userId,
          shopId,
        },
      });
    }

    return NextResponse.json(updatedOrder);
  } catch (error) {
    console.error("Error updating order:", error);
    return NextResponse.json(
      { error: "Failed to update order" },
      { status: 500 }
    );
  }
}

// DELETE an order (soft delete or cancellation)
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session?.user?.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const orderId = params.id;

    // Validate order belongs to this shop
    const order = await db.order.findUnique({
      where: {
        id: orderId,
        shopId,
      },
      include: {
        items: {
          select: {
            productId: true,
            variantId: true,
            quantity: true,
          },
        },
      },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // For safety, we don't actually delete the order, but cancel it
    // This is to preserve order history
    const cancelledOrder = await db.order.update({
      where: { id: orderId },
      data: {
        status: "CANCELLED",
        paymentStatus: "CANCELLED",
        shippingStatus: "CANCELLED",
        updatedAt: new Date(),
      },
    });

    // Restore inventory for cancelled orders
    if (order.items.length > 0) {
      for (const item of order.items) {
        if (item.variantId) {
          // Restore variant inventory
          await db.productVariant.update({
            where: { id: item.variantId },
            data: {
              inventory: {
                increment: item.quantity,
              },
            },
          });
        } else if (item.productId) {
          // Restore product inventory
          await db.product.update({
            where: { id: item.productId },
            data: {
              inventory: {
                increment: item.quantity,
              },
            },
          });
        }
      }
    }

    // Create notification
    await db.notification.create({
      data: {
        title: `Order ${order.orderNumber} Cancelled`,
        message: `Your order has been cancelled.`,
        type: "ORDER_CANCELLED",
        userId: order.userId,
        shopId,
      },
    });

    return NextResponse.json({
      success: true,
      message: "Order has been cancelled",
    });
  } catch (error) {
    console.error("Error cancelling order:", error);
    return NextResponse.json(
      { error: "Failed to cancel order" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/orders/[id]/invoice/route.ts
// src/app/api/orders/[id]/invoice/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { formatCurrency } from "@/lib/utils";
import { hasFeatureAccess, Feature } from "@/lib/feature-authorization";

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Check if user has the invoice generation feature
    if (!hasFeatureAccess(session.user, Feature.INVOICE_GENERATION)) {
      return NextResponse.json(
        {
          error:
            "Access denied. Your plan does not include invoice generation.",
        },
        { status: 403 }
      );
    }

    const shopId = session.user.shopId;
    const orderId = params.id;

    // Get order with all necessary information
    const order = await db.order.findUnique({
      where: {
        id: orderId,
        shopId, // Ensure it belongs to this shop
      },
      include: {
        user: {
          select: {
            name: true,
            email: true,
          },
        },
        address: true,
        items: true, // This includes all stored product information
        invoice: true, // Check if invoice already exists
      },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // Get shop information for invoice
    const shop = await db.shop.findUnique({
      where: { id: shopId },
      include: {
        settings: true,
      },
    });

    if (!shop) {
      return NextResponse.json({ error: "Shop not found" }, { status: 404 });
    }

    // Check if invoice already exists
    if (order.invoice) {
      // Return existing invoice information
      return NextResponse.json({
        invoiceNumber: order.invoice.invoiceNumber,
        pdfUrl: order.invoice.pdfUrl,
        orderId: order.id,
        orderNumber: order.orderNumber,
        date: order.createdAt,
        // Include a link to download the existing invoice
        downloadUrl: `/api/invoices/${order.invoice.id}/download`,
      });
    }

    // Generate invoice number
    const invoiceNumber = `INV-${order.orderNumber.slice(4)}`;

    // Generate PDF content (simplified - in real implementation this would use a PDF library)
    const invoiceData = {
      invoiceNumber,
      orderNumber: order.orderNumber,
      date: order.createdAt,
      dueDate: order.createdAt, // Due immediately for simplicity
      customer: {
        name: order.user.name,
        email: order.user.email,
        address: order.address
          ? {
              line1: order.address.line1,
              line2: order.address.line2,
              city: order.address.city,
              state: order.address.state,
              postalCode: order.address.postalCode,
              country: order.address.country,
            }
          : null,
      },
      shop: {
        name: shop.name,
        address: shop.settings?.address,
        email: shop.settings?.contactEmail,
        phone: shop.settings?.contactPhone,
      },
      items: order.items.map((item) => ({
        // Use stored information from order time, not current product info
        name: item.productName,
        description: item.productDescription,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        originalPrice: item.originalPrice,
        discountPercentage: item.discountPercentage,
        discountAmount: item.discountAmount,
        total: item.total,
        tva: item.productTva,
        tvaTotalAmount: (item.total * item.productTva) / 100,
      })),
      subtotal: order.subtotal,
      tax: order.tax,
      shipping: order.shipping,
      discount: order.discount,
      total: order.total,
      paymentStatus: order.paymentStatus,
    };

    // In a real implementation, you would generate a PDF here
    // For this example, we'll just create the invoice record

    // Create the invoice record
    const invoice = await db.invoice.create({
      data: {
        invoiceNumber,
        orderId: order.id,
        pdfUrl: `/invoices/${invoiceNumber}.pdf`, // This would be the actual PDF URL in production
      },
    });

    // Return invoice data
    return NextResponse.json({
      invoice: {
        id: invoice.id,
        invoiceNumber: invoice.invoiceNumber,
        pdfUrl: invoice.pdfUrl,
        createdAt: invoice.createdAt,
      },
      // Include the full invoice data for rendering
      invoiceData,
    });
  } catch (error) {
    console.error("Error generating invoice:", error);
    return NextResponse.json(
      { error: "Failed to generate invoice" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/orders/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { hasFeatureAccess, Feature } from "@/lib/feature-authorization";

export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (
      !session?.user?.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const { searchParams } = new URL(req.url);

    // Pagination
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "10");
    const skip = (page - 1) * limit;

    // Filtering
    const productId = searchParams.get("productId");
    const status = searchParams.get("status");

    const whereClause = {
      shopId,
      ...(productId && { items: { some: { productId } } }),
      ...(status && { status }),
    };

    // Sorting
    const sortBy = searchParams.get("sortBy") || "createdAt";
    const sortOrder = searchParams.get("sortOrder") || "desc";

    const [orders, total] = await Promise.all([
      db.order.findMany({
        where: whereClause,
        include: {
          user: { select: { name: true, email: true } },
          items: { include: { product: { select: { name: true } } } },
        },
        orderBy: { [sortBy]: sortOrder },
        skip,
        take: limit,
      }),
      db.order.count({ where: whereClause }),
    ]);

    return NextResponse.json({ data: orders, total });
  } catch (error) {
    console.error("Error fetching orders:", error);
    return NextResponse.json(
      { error: "Failed to fetch orders" },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (
      !session?.user?.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const body = await req.json();

    const { userId, items, shippingAddressId, paymentMethod, notes } = body;

    // Validate request body
    if (!items || !Array.isArray(items) || items.length === 0) {
      return NextResponse.json(
        { error: "Order must contain at least one item" },
        { status: 400 }
      );
    }

    // Create order
    const order = await db.order.create({
      data: {
        userId,
        shopId,
        shippingAddressId,
        paymentMethod,
        notes,
        status: "PENDING",
        paymentStatus: "PENDING",
        shippingStatus: "PENDING",
        items: {
          create: items.map((item) => ({
            productId: item.productId,
            quantity: item.quantity,
          })),
        },
      },
    });

    return NextResponse.json(order, { status: 201 });
  } catch (error) {
    console.error("Error creating order:", error);
    return NextResponse.json(
      { error: "Failed to create order" },
      { status: 500 }
    );
  }
}

export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (
      !session?.user?.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const orderId = params.id;
    const body = await req.json();

    const { status, paymentStatus, shippingStatus } = body;

    // Validate order exists and belongs to the shop
    const order = await db.order.findUnique({
      where: { id: orderId, shopId },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // Update order
    const updatedOrder = await db.order.update({
      where: { id: orderId },
      data: { status, paymentStatus, shippingStatus },
    });

    return NextResponse.json(updatedOrder);
  } catch (error) {
    console.error("Error updating order:", error);
    return NextResponse.json(
      { error: "Failed to update order" },
      { status: 500 }
    );
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (
      !session?.user?.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const orderId = params.id;

    // Validate order exists and belongs to the shop
    const order = await db.order.findUnique({
      where: { id: orderId, shopId },
    });

    if (!order) {
      return NextResponse.json({ error: "Order not found" }, { status: 404 });
    }

    // Soft delete (set status to CANCELLED)
    const cancelledOrder = await db.order.update({
      where: { id: orderId },
      data: { status: "CANCELLED" },
    });

    return NextResponse.json(cancelledOrder);
  } catch (error) {
    console.error("Error deleting order:", error);
    return NextResponse.json(
      { error: "Failed to delete order" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/shop/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { getSubdomain } from "@/lib/subdomain";

export async function GET(req: NextRequest) {
  try {
    // Get subdomain from the request headers or environment variable
    const subdomain = req.headers.get("x-shop-subdomain") || getSubdomain(req);

    // If no subdomain found, check if user is authenticated to get their shop
    if (!subdomain) {
      const session = await getServerSession(authOptions);

      // If no session or no shop ID, return error
      if (!session?.user?.shopId) {
        return NextResponse.json({ error: "Shop not found" }, { status: 404 });
      }

      // Get shop by ID from session
      const shop = await db.shop.findUnique({
        where: { id: session.user.shopId },
        include: {
          settings: true,
        },
      });

      if (!shop) {
        return NextResponse.json({ error: "Shop not found" }, { status: 404 });
      }

      // Return shop data
      return NextResponse.json({
        id: shop.id,
        name: shop.name,
        subdomain: shop.subdomain,
        description: shop.description,
        logo: shop.logo,
        planType: shop.planType,
        active: shop.active,
        settings: {
          currency: shop.settings?.currency || "USD",
          language: shop.settings?.language || "en",
          timezone: shop.settings?.timezone || "UTC",
          contactEmail: shop.settings?.contactEmail,
          contactPhone: shop.settings?.contactPhone,
          address: shop.settings?.address,
          lowStockThreshold: shop.settings?.lowStockThreshold || 5,
        },
      });
    }

    // Find the shop by subdomain
    const shop = await db.shop.findUnique({
      where: { subdomain },
      include: {
        settings: true,
      },
    });

    if (!shop) {
      return NextResponse.json(
        {
          error: "Shop not found",
          redirect: "https://store.tn",
        },
        { status: 404 }
      );
    }

    // Check if shop is active
    if (!shop.active) {
      return NextResponse.json(
        {
          error: "Shop is currently inactive",
          redirect: "https://store.tn",
        },
        { status: 403 }
      );
    }

    // Return shop data
    return NextResponse.json({
      id: shop.id,
      name: shop.name,
      subdomain: shop.subdomain,
      description: shop.description,
      logo: shop.logo,
      planType: shop.planType,
      active: shop.active,
      settings: {
        currency: shop.settings?.currency || "USD",
        language: shop.settings?.language || "en",
        timezone: shop.settings?.timezone || "UTC",
        contactEmail: shop.settings?.contactEmail,
        contactPhone: shop.settings?.contactPhone,
        address: shop.settings?.address,
        lowStockThreshold: shop.settings?.lowStockThreshold || 5,
      },
    });
  } catch (error) {
    console.error("Error fetching shop data:", error);
    return NextResponse.json(
      { error: "Failed to fetch shop data" },
      { status: 500 }
    );
  }
}

// Update shop settings
export async function PUT(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    // Check if user is authenticated and is a shop admin
    if (!session?.user?.shopId || session.user.role !== "SHOP_ADMIN") {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const body = await req.json();

    // Validate the request body
    const { name, description, settings } = body;

    // Update the shop
    const updatedShop = await db.shop.update({
      where: { id: shopId },
      data: {
        name: name || undefined,
        description: description || undefined,
        // Update settings if provided
        settings: settings
          ? {
              upsert: {
                create: {
                  ...settings,
                },
                update: {
                  ...settings,
                },
              },
            }
          : undefined,
      },
      include: {
        settings: true,
      },
    });

    return NextResponse.json({
      id: updatedShop.id,
      name: updatedShop.name,
      subdomain: updatedShop.subdomain,
      description: updatedShop.description,
      logo: updatedShop.logo,
      planType: updatedShop.planType,
      settings: {
        currency: updatedShop.settings?.currency || "USD",
        language: updatedShop.settings?.language || "en",
        timezone: updatedShop.settings?.timezone || "UTC",
        contactEmail: updatedShop.settings?.contactEmail,
        contactPhone: updatedShop.settings?.contactPhone,
        address: updatedShop.settings?.address,
        lowStockThreshold: updatedShop.settings?.lowStockThreshold || 5,
      },
    });
  } catch (error) {
    console.error("Error updating shop:", error);
    return NextResponse.json(
      { error: "Failed to update shop" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/products/[id]/orders/route.ts
// src/app/api/products/[id]/orders/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const productId = params.id;

    // Verify the product exists and belongs to this shop
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Get all order items for this product, even if it has been deleted
    // We can rely on stored productId or if productId is null, match on product name
    const orderItems = await db.orderItem.findMany({
      where: {
        OR: [
          { productId: productId },
          // For items where product was deleted but originally was this product
          {
            productId: null,
            productName: product.name,
          },
        ],
        order: {
          shopId, // Ensure orders belong to this shop
        },
      },
      include: {
        order: {
          select: {
            id: true,
            orderNumber: true,
            status: true,
            createdAt: true,
            user: {
              select: {
                name: true,
                email: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json(orderItems);
  } catch (error) {
    console.error("Error fetching product order history:", error);
    return NextResponse.json(
      { error: "Failed to fetch product order history" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/products/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { slugify } from "@/lib/utils";
import { s3ImageService } from "@/lib/services/s3-image.service";

// GET a specific product
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;
    const productId = params.id;

    // Get the product
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId, // Ensure it belongs to this shop
      },
      include: {
        categories: true,
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Process S3 image URLs
    let productWithUrls = { ...product };
    if (product.images && product.images.length > 0) {
      try {
        const processedImages = await Promise.all(
          product.images.map(async (image) => {
            if (s3ImageService.isS3Key(image)) {
              try {
                return await s3ImageService.getImageUrl(image);
              } catch (error) {
                console.error(`Error getting image URL for ${image}:`, error);
                return image; // Return original key if URL generation fails
              }
            }
            return image; // Return original URL if not an S3 key
          })
        );

        productWithUrls = {
          ...product,
          images: processedImages,
          s3Keys: product.images, // Store original keys for reference
        };
      } catch (error) {
        console.error("Error processing product images:", error);
        // Continue with original product if image processing fails
      }
    }

    return NextResponse.json(productWithUrls);
  } catch (error) {
    console.error("Error fetching product:", error);
    return NextResponse.json(
      { error: "Failed to fetch product" },
      { status: 500 }
    );
  }
}

// UPDATE a product
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;
    const productId = params.id;
    const body = await req.json();

    // Verify the product exists and belongs to this shop
    const existingProduct = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!existingProduct) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Extract and prepare the data for update
    const {
      name,
      slug,
      description,
      price,
      cost,
      sku,
      barcode,
      inventory,
      tva,
      categoryIds,
      images,
      variants,
      expiryDate,
      customFieldValues,
    } = body;

    // Generate slug if changed
    const productSlug = slugify(name);

    // If slug changed, check if it's already in use
    if (productSlug !== existingProduct.slug) {
      const slugExists = await db.product.findUnique({
        where: {
          shopId_slug: {
            shopId,
            slug: productSlug,
          },
        },
      });

      if (slugExists && slugExists.id !== productId) {
        return NextResponse.json(
          { error: "A product with this slug already exists" },
          { status: 400 }
        );
      }
    }

    // Process images - handle any new base64 images and track which S3 images to delete
    const processedImages = [];
    const imagesToDelete = [];

    // Find which existing images are being removed
    if (existingProduct.images && existingProduct.images.length > 0) {
      for (const oldImage of existingProduct.images) {
        if (
          s3ImageService.isS3Key(oldImage) &&
          (!images || !images.includes(oldImage))
        ) {
          imagesToDelete.push(oldImage);
        }
      }
    }

    // Process new images
    if (images && images.length > 0) {
      for (const image of images) {
        if (image.startsWith("data:")) {
          // New base64 image to upload to S3
          try {
            const fileNameBase = `${productSlug}-${Date.now()}`;
            const uploadResult = await s3ImageService.uploadImage(
              image,
              `${fileNameBase}.jpg`,
              "products"
            );
            processedImages.push(uploadResult.key);
          } catch (uploadError) {
            console.error("Error uploading product image to S3:", uploadError);
            // Skip this image if upload fails
          }
        } else {
          // Existing image URL or S3 key
          processedImages.push(image);
        }
      }
    }

    // Delete old S3 images that are no longer used
    for (const imageToDelete of imagesToDelete) {
      try {
        await s3ImageService.deleteImage(imageToDelete);
        console.log(`Deleted old product image: ${imageToDelete}`);
      } catch (deleteError) {
        console.error(
          `Error deleting product image ${imageToDelete}:`,
          deleteError
        );
        // Continue with update even if image deletion fails
      }
    }

    // Update the product in a transaction
    const updatedProduct = await db.$transaction(async (tx) => {
      // Update the product
      const product = await tx.product.update({
        where: { id: productId },
        data: {
          name,
          slug: productSlug,
          description,
          price,
          cost,
          sku,
          barcode,
          inventory,
          tva,
          expiryDate: expiryDate ? new Date(expiryDate) : null,
          images: processedImages, // Use the processed images array
          categories: {
            set: [], // Clear existing categories
            connect: categoryIds?.map((id: string) => ({ id })) || [],
          },
        },
        include: {
          categories: true,
        },
      });

      // Handle custom field values
      if (customFieldValues && customFieldValues.length > 0) {
        // Remove existing custom field values
        await tx.customFieldValue.deleteMany({
          where: { productId },
        });

        // Add new custom field values
        for (const field of customFieldValues) {
          await tx.customFieldValue.create({
            data: {
              customFieldId: field.customFieldId,
              value: field.value,
              productId,
            },
          });
        }
      }

      // Handle variants
      if (variants && variants.length > 0) {
        // Remove existing variants that aren't in the updated list
        const variantIds = variants
          .filter((v: any) => v.id)
          .map((v: any) => v.id);
        if (variantIds.length > 0) {
          await tx.productVariant.deleteMany({
            where: {
              productId,
              id: { notIn: variantIds },
            },
          });
        } else {
          // If no existing variants were kept, delete all
          await tx.productVariant.deleteMany({
            where: { productId },
          });
        }

        // Update or create variants
        for (const variant of variants) {
          if (variant.id) {
            // Update existing variant
            await tx.productVariant.update({
              where: { id: variant.id },
              data: {
                name: variant.name,
                price: variant.price,
                inventory: variant.inventory,
                sku: variant.sku,
                options: variant.options,
              },
            });
          } else {
            // Create new variant
            await tx.productVariant.create({
              data: {
                name: variant.name,
                price: variant.price,
                inventory: variant.inventory,
                sku: variant.sku,
                options: variant.options,
                productId,
              },
            });
          }
        }
      } else {
        // If no variants provided, delete all existing variants
        await tx.productVariant.deleteMany({
          where: { productId },
        });
      }

      return product;
    });

    // Get the complete updated product
    const completeProduct = await db.product.findUnique({
      where: { id: productId },
      include: {
        categories: true,
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
      },
    });

    // Process S3 image URLs for response
    let responseProduct = completeProduct;
    if (
      completeProduct &&
      completeProduct.images &&
      completeProduct.images.length > 0
    ) {
      const imageUrls = await Promise.all(
        completeProduct.images.map(async (image) => {
          if (s3ImageService.isS3Key(image)) {
            try {
              return await s3ImageService.getImageUrl(image);
            } catch (error) {
              console.error(`Error getting image URL for ${image}:`, error);
              return image; // Return original key if URL generation fails
            }
          }
          return image; // Return original URL if not an S3 key
        })
      );

      responseProduct = {
        ...completeProduct,
        images: imageUrls,
        s3Keys: completeProduct.images, // Keep original keys for reference
      };
    }

    return NextResponse.json(responseProduct);
  } catch (error) {
    console.error("Error updating product:", error);
    return NextResponse.json(
      { error: "Failed to update product" },
      { status: 500 }
    );
  }
}

// DELETE a product
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;
    const productId = params.id;

    // Verify the product exists and belongs to this shop
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
      select: {
        id: true,
        images: true,
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Get any S3 image keys that need to be deleted
    const s3ImagesToDelete =
      product.images?.filter((image) => s3ImageService.isS3Key(image)) || [];

    // Delete in a transaction to ensure all related records are deleted properly
    await db.$transaction(async (tx) => {
      // 1. Delete custom field values associated with the product
      await tx.customFieldValue.deleteMany({
        where: { productId },
      });

      // 2. Delete variants associated with the product
      await tx.productVariant.deleteMany({
        where: { productId },
      });

      // 3. Delete discounts associated with the product
      await tx.discount.deleteMany({
        where: { productId },
      });

      // 4. Set productId to null in discount codes (since it's nullable)
      await tx.discountCode.updateMany({
        where: { productId },
        data: { productId: null },
      });

      // 5. Check for CartItems and OrderItems (this might be our blocker)
      const cartItemCount = await tx.cartItem.count({
        where: { productId },
      });
      if (cartItemCount > 0) {
        // Delete cart items that reference this product
        await tx.cartItem.deleteMany({
          where: { productId },
        });
      }

      await tx.orderItem.updateMany({
        where: { productId },
        data: { productId: null },
      });

      // 6. Disconnect product from all categories (many-to-many relation)
      await tx.product.update({
        where: { id: productId },
        data: {
          categories: {
            set: [], // Remove all category connections
          },
        },
      });

      // 7. Finally delete the product
      await tx.product.delete({
        where: { id: productId },
      });
    });

    // After successful transaction, delete images from S3
    if (s3ImagesToDelete.length > 0) {
      for (const imageKey of s3ImagesToDelete) {
        try {
          await s3ImageService.deleteImage(imageKey);
          console.log(`Deleted product image from S3: ${imageKey}`);
        } catch (error) {
          console.error(
            `Error deleting product image ${imageKey} from S3:`,
            error
          );
          // Continue even if S3 deletion fails - the product is already deleted
        }
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting product:", error);
    return NextResponse.json(
      {
        error:
          error instanceof Error ? error.message : "Failed to delete product",
      },
      { status: 500 }
    );
  }
}

File: ./src/app/api/products/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { productsService } from "@/lib/services/products.service";
import { shopService } from "@/lib/services/shop.service";
import { slugify } from "@/lib/utils";
import { db } from "@/lib/prisma";
import { serializeBigInt } from "@/lib/serializer";
import { s3ImageService } from "@/lib/services/s3-image.service";

// GET products with filtering, sorting, and pagination
export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;

    // Verify shop exists
    const shopExists = await shopService.shopExists(shopId);
    if (!shopExists) {
      return NextResponse.json({ error: "Shop not found" }, { status: 404 });
    }

    // Parse query parameters
    const { searchParams } = new URL(req.url);
    const page = parseInt(searchParams.get("page") || "1");
    const perPage = parseInt(searchParams.get("perPage") || "10");
    const sortField = searchParams.get("sort") || "createdAt";
    const sortOrder = searchParams.get("order") || "desc";
    const search = searchParams.get("search") || "";
    const categoryId = searchParams.get("category") || "";
    const inStock = searchParams.get("inStock") === "true";
    const lowStock = searchParams.get("lowStock") === "true";
    const expiringSoon = searchParams.get("expiringSoon") === "true";
    const viewMode = searchParams.get("view") || "list";

    // Get shop settings for low stock threshold
    const shopSettings = await shopService.getShopSettings(shopId);
    const lowStockThreshold = shopSettings?.lowStockThreshold || 5;

    // Prepare filters
    const filters = {
      shopId,
      search,
      categoryId: categoryId || undefined,
      inStock,
      lowStock,
      expiringSoon,
      lowStockThreshold,
    };

    // Prepare pagination
    const pagination = {
      page,
      perPage,
    };

    // Prepare sorting
    const sort = {
      sortField,
      sortOrder: sortOrder as "asc" | "desc",
    };

    // Get total products count for pagination
    const totalProducts = await productsService.getTotalProducts(filters);

    // Get products with pagination and sorting
    const products = await productsService.getProducts(
      filters,
      pagination,
      sort
    );

    // Process S3 image URLs for each product
    const productsWithImageUrls = await Promise.all(
      products.map(async (product) => {
        // Process product image URLs if they're S3 keys
        if (product.images && product.images.length > 0) {
          const processedImages = await Promise.all(
            product.images.map(async (image) => {
              if (s3ImageService.isS3Key(image)) {
                try {
                  return await s3ImageService.getImageUrl(image);
                } catch (error) {
                  console.error(`Error getting image URL for ${image}:`, error);
                  return image; // Return original key if URL generation fails
                }
              }
              return image; // Return original URL if not an S3 key
            })
          );
          return { ...product, images: processedImages };
        }
        return product;
      })
    );

    // Get product statistics
    const productStats = await productsService.getProductStats(
      shopId,
      lowStockThreshold
    );

    // Serialize data to handle BigInt values
    const responseData = serializeBigInt({
      products: productsWithImageUrls,
      pagination: {
        total: totalProducts,
        page,
        perPage,
        totalPages: Math.ceil(totalProducts / perPage),
      },
      stats: productStats,
      filter: {
        lowStockThreshold,
      },
      viewMode,
    });

    return NextResponse.json(responseData);
  } catch (error) {
    console.error("Error fetching products:", error);
    return NextResponse.json(
      { error: "Failed to fetch products" },
      { status: 500 }
    );
  }
}

// CREATE a new product
export async function POST(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;

    // Parse the request body
    const body = await req.json();
    const {
      name,
      slug,
      description,
      price,
      cost,
      sku,
      barcode,
      inventory,
      tva,
      weight,
      categoryIds,
      images,
      variants,
      expiryDate,
      customFields = [],
    } = body;

    // Validate required fields
    if (!name || price === undefined) {
      return NextResponse.json(
        { error: "Name and price are required" },
        { status: 400 }
      );
    }

    // Generate slug if not provided
    const productSlug = slug || slugify(name);

    // Check if slug is already in use
    const existingProduct = await db.product.findUnique({
      where: {
        shopId_slug: {
          shopId,
          slug: productSlug,
        },
      },
    });
    if (existingProduct) {
      return NextResponse.json(
        { error: "A product with this slug already exists" },
        { status: 400 }
      );
    }

    // Get shop settings for low stock threshold
    const shopSettings = await db.shopSettings.findUnique({
      where: { shopId },
    });
    const lowStockThreshold = shopSettings?.lowStockThreshold || 5;
    const lowStockAlert = inventory <= lowStockThreshold;

    // Process custom fields - validate they exist for this shop
    const customFieldsData = [];
    if (customFields && customFields.length > 0) {
      for (const cf of customFields) {
        // Look up the custom field in the database to ensure it exists
        let customField = await db.customField.findFirst({
          where: {
            shopId,
            name: cf.key,
          },
        });
        // If it doesn't exist, create it
        if (!customField) {
          customField = await db.customField.create({
            data: {
              name: cf.key,
              type: "TEXT", // Default type
              required: false,
              shopId,
            },
          });
        }
        customFieldsData.push({
          customFieldId: customField.id,
          value: cf.value,
        });
      }
    }

    // Process images - upload base64 data URLs to S3
    const processedImages = [];
    if (images && images.length > 0) {
      for (const image of images) {
        if (image && image.startsWith("data:")) {
          try {
            // Upload image to S3
            const fileNameBase = `${productSlug}-${Date.now()}`; // Add timestamp to avoid collisions
            const uploadResult = await s3ImageService.uploadImage(
              image,
              `${fileNameBase}.jpg`,
              "products"
            );
            processedImages.push(uploadResult.key); // Store S3 key
          } catch (uploadError) {
            console.error("Error uploading product image to S3:", uploadError);
            // Skip this image if upload fails
          }
        } else {
          // Keep existing image URLs or keys
          processedImages.push(image);
        }
      }
    }

    // Create the product in a transaction
    const product = await db.$transaction(async (tx) => {
      // Create the product
      const newProduct = await tx.product.create({
        data: {
          name,
          slug: productSlug,
          description,
          price,
          cost,
          sku,
          barcode,
          inventory,
          tva: tva || 19, // Default TVA to 19% if not provided
          lowStockAlert,
          weight,
          images: processedImages, // Use processed image array
          expiryDate: expiryDate ? new Date(expiryDate) : null,
          shopId,
          categories: {
            connect: categoryIds?.map((id: string) => ({ id })) || [],
          },
        },
      });

      // Create custom field values
      if (customFieldsData.length > 0) {
        await Promise.all(
          customFieldsData.map((cfData) =>
            tx.customFieldValue.create({
              data: {
                ...cfData,
                productId: newProduct.id,
              },
            })
          )
        );
      }

      // Create variants if provided
      if (variants && variants.length > 0) {
        await Promise.all(
          variants.map((variant: any) =>
            tx.productVariant.create({
              data: {
                name: variant.name,
                price: variant.price,
                inventory: variant.inventory,
                sku: variant.sku,
                options: variant.options,
                productId: newProduct.id,
              },
            })
          )
        );
      }

      return newProduct;
    });

    // Get the complete product with relationships
    const completeProduct = await db.product.findUnique({
      where: { id: product.id },
      include: {
        categories: true,
        variants: true,
        customFields: {
          include: {
            customField: true,
          },
        },
      },
    });

    // Generate image URLs for S3 keys in the response
    let responseProduct = completeProduct;
    if (
      completeProduct &&
      completeProduct.images &&
      completeProduct.images.length > 0
    ) {
      const imageUrls = await Promise.all(
        completeProduct.images.map(async (image) => {
          if (s3ImageService.isS3Key(image)) {
            try {
              return await s3ImageService.getImageUrl(image);
            } catch (error) {
              console.error(`Error getting image URL for ${image}:`, error);
              return image; // Return original key if URL generation fails
            }
          }
          return image; // Return original URL if not an S3 key
        })
      );

      responseProduct = {
        ...completeProduct,
        images: imageUrls,
        s3Keys: completeProduct.images, // Keep original keys for reference
      };
    }

    // Serialize the response
    return NextResponse.json(serializeBigInt(responseProduct), { status: 201 });
  } catch (error) {
    console.error("Error creating product:", error);
    return NextResponse.json(
      { error: "Failed to create product" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/categories/[id]/route.ts
// src/app/api/categories/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { categoriesService } from "@/lib/services/categories.service";
import { serializeBigInt } from "@/lib/serializer";
import { s3ImageService } from "@/lib/services/s3-image.service";
import { z } from "zod";

// Schema for updating categories
const categoryUpdateSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  slug: z.string().min(2, "Slug must be at least 2 characters").optional(),
  description: z.string().optional(),
  image: z.string().optional(),
  parentId: z.string().nullable().optional(),
});

// GET a specific category
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;
    const categoryId = params.id;

    // Get the category
    const category = await categoriesService.getCategoryById(
      categoryId,
      shopId
    );
    if (!category) {
      return NextResponse.json(
        { error: "Category not found" },
        { status: 404 }
      );
    }

    // Get total product count including subcategories
    const totalProducts = await categoriesService.getCategoryProductCount(
      categoryId,
      shopId
    );

    // If the category has an image that is an S3 key, generate a URL for it
    let categoryWithImageUrl = { ...category, totalProducts };
    if (category.image && s3ImageService.isS3Key(category.image)) {
      try {
        const imageUrl = await s3ImageService.getImageUrl(category.image);
        // Add the image URL to the response
        categoryWithImageUrl = {
          ...category,
          totalProducts,
          imageUrl, // Add the URL for frontend use
        };
      } catch (error) {
        console.error("Error generating image URL:", error);
        // Continue without the image URL if there's an error
      }
    }

    return NextResponse.json(serializeBigInt(categoryWithImageUrl));
  } catch (error) {
    console.error("Error fetching category:", error);
    return NextResponse.json(
      { error: "Failed to fetch category" },
      { status: 500 }
    );
  }
}

// UPDATE a category
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;
    const categoryId = params.id;
    const body = await req.json();

    // Validate input
    const validation = categoryUpdateSchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.format() },
        { status: 400 }
      );
    }

    // Prepare data for update
    const updateData = {
      name: body.name,
      slug: body.slug,
      description: body.description,
      parentId: body.parentId === "" ? null : body.parentId,
      image: body.image,
    };

    try {
      // Handle image changes - if old image was an S3 key and it's being replaced or removed
      const existingCategory = await categoriesService.getCategoryById(
        categoryId,
        shopId
      );

      if (
        existingCategory?.image &&
        s3ImageService.isS3Key(existingCategory.image) &&
        existingCategory.image !== body.image
      ) {
        // Try to delete the old image - don't block the update if this fails
        try {
          await s3ImageService.deleteImage(existingCategory.image);
        } catch (deleteError) {
          console.error("Error deleting old image:", deleteError);
          // Continue with update even if image delete fails
        }
      }

      // Update the category
      const category = await categoriesService.updateCategory(
        categoryId,
        shopId,
        updateData
      );

      // Get total product count including subcategories
      const totalProducts = await categoriesService.getCategoryProductCount(
        categoryId,
        shopId
      );

      // Add total product count to the response
      const responseData = { ...category, totalProducts };
      return NextResponse.json(serializeBigInt(responseData));
    } catch (error: any) {
      return NextResponse.json(
        { error: error.message || "Failed to update category" },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error("Error updating category:", error);
    return NextResponse.json(
      { error: "Failed to update category" },
      { status: 500 }
    );
  }
}

// DELETE a category
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;
    const categoryId = params.id;

    try {
      // Get the category before deletion to check for image
      const categoryToDelete = await categoriesService.getCategoryById(
        categoryId,
        shopId
      );

      // Delete the category
      await categoriesService.deleteCategory(categoryId, shopId);

      // If the category had an S3 image, delete it too
      if (
        categoryToDelete?.image &&
        s3ImageService.isS3Key(categoryToDelete.image)
      ) {
        try {
          await s3ImageService.deleteImage(categoryToDelete.image);
        } catch (deleteError) {
          console.error("Error deleting category image:", deleteError);
          // Category is already deleted, so just log the error
        }
      }

      return NextResponse.json(
        {
          success: true,
          message: "Category successfully deleted",
        },
        { status: 200 }
      );
    } catch (error: any) {
      return NextResponse.json(
        {
          error: error.message || "Failed to delete category",
        },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error("Error deleting category:", error);
    return NextResponse.json(
      { error: "Failed to delete category" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/categories/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { categoriesService } from "@/lib/services/categories.service";
import { serializeBigInt } from "@/lib/serializer";
import { slugify } from "@/lib/utils";
import { s3ImageService } from "@/lib/services/s3-image.service";
import { z } from "zod";

// Schema for creating and updating categories
const categorySchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  slug: z.string().min(2, "Slug must be at least 2 characters").optional(),
  description: z.string().optional(),
  image: z.string().optional(),
  parentId: z.string().nullable().optional(),
});

export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const parentId = searchParams.get("parentId");
    const withProductCount = searchParams.get("withProductCount") === "true";

    // If detailed data with product counts is requested
    if (withProductCount) {
      try {
        // Get all categories with counts and hierarchy information
        const categoriesWithCounts =
          await categoriesService.getCategoriesWithCounts(shopId, true);
        return NextResponse.json(serializeBigInt(categoriesWithCounts));
      } catch (error) {
        console.error("Error getting categories with product counts:", error);
        // Fallback to basic categories
        const basicCategories =
          await categoriesService.getCategoriesWithHierarchy(shopId);
        return NextResponse.json(serializeBigInt(basicCategories));
      }
    }

    // Build where clause
    const where: any = { shopId };

    // Filter by parent category if specified
    if (parentId) {
      where.parentId = parentId === "null" ? null : parentId;
    }

    // Get categories with hierarchy information and counts
    const categories = await db.category.findMany({
      where,
      include: {
        _count: {
          select: {
            products: true,
            children: true,
          },
        },
      },
      orderBy: {
        name: "asc",
      },
    });

    // Add image URLs for S3 images
    const categoriesWithUrls = await Promise.all(
      categories.map(async (category) => {
        if (category.image && s3ImageService.isS3Key(category.image)) {
          try {
            const imageUrl = await s3ImageService.getImageUrl(category.image);
            return { ...category, imageUrl };
          } catch (error) {
            console.error(
              `Error generating image URL for category ${category.id}:`,
              error
            );
            return category;
          }
        }
        return category;
      })
    );

    // Process categories to add level information
    const processedCategories = await categoriesService.addLevelsToCategories(
      categoriesWithUrls
    );

    // Serialize any BigInt values that might be in the response
    return NextResponse.json(serializeBigInt(processedCategories));
  } catch (error) {
    console.error("Error fetching categories:", error);
    return NextResponse.json(
      { error: "Failed to fetch categories" },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    // Check authentication and authorization
    const session = await getServerSession(authOptions);
    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const shopId = session.user.shopId;
    const body = await req.json();

    // Validate input
    const validation = categorySchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json(
        { error: validation.error.format() },
        { status: 400 }
      );
    }

    const { name, slug, description, image, parentId } = validation.data;

    // Process image if it's a base64 data URL
    let processedImage = image;
    if (image && image.startsWith("data:")) {
      try {
        // Upload the image to S3
        const generatedSlug = slug || slugify(name);
        const uploadResult = await s3ImageService.uploadImage(
          image,
          `${generatedSlug}-image.jpg`,
          "categories"
        );
        processedImage = uploadResult.key; // Store the S3 key
      } catch (uploadError) {
        console.error("Error uploading image to S3:", uploadError);
        // Continue with empty image if upload fails
        processedImage = "";
      }
    }

    // Create data object
    const categoryData = {
      name,
      slug: slug || slugify(name), // Use provided slug or generate from name
      description,
      image: processedImage,
      parentId,
    };

    // Create the category
    try {
      const category = await categoriesService.createCategory(
        categoryData,
        shopId
      );

      // Add image URL to response if it's an S3 key
      let responseData = category;
      if (category.image && s3ImageService.isS3Key(category.image)) {
        try {
          const imageUrl = await s3ImageService.getImageUrl(category.image);
          responseData = { ...category, imageUrl };
        } catch (error) {
          console.error("Error generating image URL:", error);
          // Continue without the image URL
        }
      }

      return NextResponse.json(responseData, { status: 201 });
    } catch (error: any) {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }
  } catch (error) {
    console.error("Error creating category:", error);
    return NextResponse.json(
      { error: "Failed to create category" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/users/search/route.ts
// src/app/api/users/search/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const { searchParams } = new URL(req.url);
    const query = searchParams.get("q");

    if (!query || query.length < 2) {
      return NextResponse.json(
        { error: "Search query must be at least 2 characters" },
        { status: 400 }
      );
    }

    // Search for users that belong to this shop
    const users = await db.user.findMany({
      where: {
        shopId,
        OR: [
          { name: { contains: query, mode: "insensitive" } },
          { email: { contains: query, mode: "insensitive" } },
        ],
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
      },
      take: 10, // Limit to 10 results
    });

    return NextResponse.json(users);
  } catch (error) {
    console.error("Error searching users:", error);
    return NextResponse.json(
      { error: "Failed to search users" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/discounts/[id]/route.ts
// src/app/api/discounts/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET a specific discount
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountId = params.id;

    // Get the discount with validation that it belongs to a product in this shop
    const discount = await db.discount.findFirst({
      where: {
        id: discountId,
        product: {
          shopId,
        },
      },
    });

    if (!discount) {
      return NextResponse.json(
        { error: "Discount not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(discount);
  } catch (error) {
    console.error("Error fetching discount:", error);
    return NextResponse.json(
      { error: "Failed to fetch discount" },
      { status: 500 }
    );
  }
}

// UPDATE a discount
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountId = params.id;
    const body = await req.json();
    const { percentage, enabled, startDate, endDate, productId } = body;

    // Verify the discount exists and belongs to a product in this shop
    const existingDiscount = await db.discount.findFirst({
      where: {
        id: discountId,
        product: {
          shopId,
        },
      },
    });

    if (!existingDiscount) {
      return NextResponse.json(
        { error: "Discount not found" },
        { status: 404 }
      );
    }

    // Verify the product belongs to this shop if it's being changed
    if (productId && productId !== existingDiscount.productId) {
      const product = await db.product.findUnique({
        where: {
          id: productId,
          shopId,
        },
      });

      if (!product) {
        return NextResponse.json(
          { error: "Product not found" },
          { status: 404 }
        );
      }
    }

    // Update the discount
    const updatedDiscount = await db.discount.update({
      where: { id: discountId },
      data: {
        percentage:
          percentage !== undefined ? parseFloat(percentage) : undefined,
        enabled: enabled !== undefined ? enabled === true : undefined,
        startDate: startDate ? new Date(startDate) : undefined,
        endDate: endDate ? new Date(endDate) : undefined,
        productId: productId || undefined,
      },
    });

    return NextResponse.json(updatedDiscount);
  } catch (error) {
    console.error("Error updating discount:", error);
    return NextResponse.json(
      { error: "Failed to update discount" },
      { status: 500 }
    );
  }
}

// DELETE a discount
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const discountId = params.id;

    // Verify the discount exists and belongs to a product in this shop
    const discount = await db.discount.findFirst({
      where: {
        id: discountId,
        product: {
          shopId,
        },
      },
    });

    if (!discount) {
      return NextResponse.json(
        { error: "Discount not found" },
        { status: 404 }
      );
    }

    // Delete the discount
    await db.discount.delete({
      where: { id: discountId },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting discount:", error);
    return NextResponse.json(
      { error: "Failed to delete discount" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/discounts/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";

// GET: List discounts for a product
export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const { searchParams } = new URL(req.url);
    const productId = searchParams.get("productId");

    if (!productId) {
      return NextResponse.json(
        { error: "Product ID is required" },
        { status: 400 }
      );
    }

    // Verify the product belongs to this shop
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Get discounts for this product
    const discounts = await db.discount.findMany({
      where: {
        productId,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json(discounts);
  } catch (error) {
    console.error("Error fetching discounts:", error);
    return NextResponse.json(
      { error: "Failed to fetch discounts" },
      { status: 500 }
    );
  }
}

// POST: Create a new discount
export async function POST(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const body = await req.json();
    const { percentage, enabled, startDate, endDate, productId } = body;

    // Validate required fields
    if (!percentage || !startDate || !endDate || !productId) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Verify the product belongs to this shop
    const product = await db.product.findUnique({
      where: {
        id: productId,
        shopId,
      },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Create the discount
    const discount = await db.discount.create({
      data: {
        percentage: parseFloat(percentage),
        enabled: enabled === true,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        productId,
      },
    });

    return NextResponse.json(discount, { status: 201 });
  } catch (error) {
    console.error("Error creating discount:", error);
    return NextResponse.json(
      { error: "Failed to create discount" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/custom-fields/[id]/route.ts
// src/app/api/custom-fields/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { z } from "zod";

// Validation schema for custom field updates
const updateCustomFieldSchema = z.object({
  name: z.string().min(2, "Field name must be at least 2 characters"),
  type: z.string().min(1, "Field type is required"),
  required: z.boolean().default(false),
});

// GET a single custom field
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const fieldId = params.id;

    // Get the custom field
    const customField = await db.customField.findUnique({
      where: {
        id: fieldId,
      },
    });

    // Check if it belongs to this shop
    if (!customField || customField.shopId !== shopId) {
      return NextResponse.json(
        { error: "Custom field not found" },
        { status: 404 }
      );
    }

    // Get usage count
    const usageCount = await db.customFieldValue.count({
      where: { customFieldId: fieldId },
    });

    return NextResponse.json({
      ...customField,
      usageCount,
    });
  } catch (error) {
    console.error("Error fetching custom field:", error);
    return NextResponse.json(
      { error: "Failed to fetch custom field" },
      { status: 500 }
    );
  }
}

// UPDATE a custom field
export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const fieldId = params.id;

    // Check if custom field exists and belongs to this shop
    const existingField = await db.customField.findUnique({
      where: {
        id: fieldId,
      },
    });

    if (!existingField || existingField.shopId !== shopId) {
      return NextResponse.json(
        { error: "Custom field not found" },
        { status: 404 }
      );
    }

    // Parse request body
    const body = await req.json();
    const validationResult = updateCustomFieldSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: validationResult.error.message },
        { status: 400 }
      );
    }

    const { name, type, required } = validationResult.data;

    // Check if name already exists (except for this field)
    if (name !== existingField.name) {
      const nameExists = await db.customField.findFirst({
        where: {
          shopId,
          name: {
            equals: name,
            mode: "insensitive",
          },
          id: {
            not: fieldId,
          },
        },
      });

      if (nameExists) {
        return NextResponse.json(
          { error: "A custom field with this name already exists" },
          { status: 400 }
        );
      }
    }

    // Update custom field
    const updatedField = await db.customField.update({
      where: { id: fieldId },
      data: {
        name,
        type,
        required: required === true,
      },
    });

    return NextResponse.json(updatedField);
  } catch (error) {
    console.error("Error updating custom field:", error);
    return NextResponse.json(
      { error: "Failed to update custom field" },
      { status: 500 }
    );
  }
}

// DELETE a custom field
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;
    const fieldId = params.id;

    // Check if custom field exists and belongs to this shop
    const existingField = await db.customField.findUnique({
      where: {
        id: fieldId,
      },
    });

    if (!existingField || existingField.shopId !== shopId) {
      return NextResponse.json(
        { error: "Custom field not found" },
        { status: 404 }
      );
    }

    // Check if the field is in use
    const inUseCount = await db.customFieldValue.count({
      where: { customFieldId: fieldId },
    });

    if (inUseCount > 0) {
      return NextResponse.json(
        {
          error: "Cannot delete a custom field that is in use",
          count: inUseCount,
        },
        { status: 400 }
      );
    }

    // Delete the custom field
    await db.customField.delete({
      where: { id: fieldId },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting custom field:", error);
    return NextResponse.json(
      { error: "Failed to delete custom field" },
      { status: 500 }
    );
  }
}

File: ./src/app/api/custom-fields/route.ts
// src/app/api/custom-fields/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/prisma";
import { z } from "zod";

// Validation schema for custom field creation
const createCustomFieldSchema = z.object({
  name: z.string().min(2, "Field name must be at least 2 characters"),
  type: z.string().min(1, "Field type is required"),
  required: z.boolean().default(false),
});

// POST: Create a new custom field
export async function POST(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (
      !session ||
      !session.user.shopId ||
      (session.user.role !== "SHOP_ADMIN" && session.user.role !== "SHOP_STAFF")
    ) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;

    // Parse and validate request body
    const body = await req.json();
    const validationResult = createCustomFieldSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: validationResult.error.message },
        { status: 400 }
      );
    }

    const { name, type, required } = validationResult.data;

    // Check if field with the same name already exists for this shop
    const existingField = await db.customField.findFirst({
      where: {
        shopId,
        name: {
          equals: name,
          mode: "insensitive", // Case insensitive comparison
        },
      },
    });

    if (existingField) {
      return NextResponse.json(
        { error: "A custom field with this name already exists" },
        { status: 400 }
      );
    }

    // Create the custom field
    const customField = await db.customField.create({
      data: {
        name,
        type,
        required,
        shopId,
      },
    });

    return NextResponse.json(customField, { status: 201 });
  } catch (error) {
    console.error("Error creating custom field:", error);
    return NextResponse.json(
      { error: "Failed to create custom field" },
      { status: 500 }
    );
  }
}

// GET: List all custom fields for the shop
export async function GET(req: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);

    if (!session || !session.user.shopId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const shopId = session.user.shopId;

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const search = searchParams.get("search") || "";
    const type = searchParams.get("type") || "";
    const sort = searchParams.get("sort") || "name";
    const order = searchParams.get("order") || "asc";

    // Build where clause
    let where: any = { shopId };

    if (search) {
      where.name = {
        contains: search,
        mode: "insensitive",
      };
    }

    if (type) {
      where.type = type;
    }

    // Get custom fields
    const customFields = await db.customField.findMany({
      where,
      orderBy: {
        [sort]: order,
      },
    });

    // Count usage for each field
    const fieldsWithUsage = await Promise.all(
      customFields.map(async (field) => {
        const usageCount = await db.customFieldValue.count({
          where: { customFieldId: field.id },
        });

        return {
          ...field,
          usageCount,
        };
      })
    );

    return NextResponse.json(fieldsWithUsage);
  } catch (error) {
    console.error("Error fetching custom fields:", error);
    return NextResponse.json(
      { error: "Failed to fetch custom fields" },
      { status: 500 }
    );
  }
}

File: ./src/types/product.ts
// src/types/product.ts

export interface Category {
  id: string;
  name: string;
  slug: string;
  level?: number;
  parentId?: string | null;
}

export interface ProductVariant {
  id?: string;
  name: string;
  price: number;
  inventory: number;
  sku?: string;
  barcode?: string;
  options: Record<string, any>;
}

export interface CustomField {
  id?: string;
  customFieldId: string;
  value: string;
  customField?: {
    id: string;
    name: string;
    type: string;
    required?: boolean;
  };
}

export interface Discount {
  id?: string;
  percentage: number;
  enabled?: boolean;
  startDate?: string | Date;
  endDate?: string | Date;
  productId?: string;
}

export interface Product {
  id: string;
  name: string;
  slug?: string;
  description?: string;
  price: number;
  cost?: number | null;
  tva?: number;
  sku?: string;
  barcode?: string;
  inventory: number;
  lowStockAlert?: boolean;
  weight?: number | null;
  dimensions?: Record<string, any> | null;
  images: string[];
  expiryDate?: string | Date | null;
  categories: Category[];
  variants: ProductVariant[];
  customFields: CustomField[];
  _count: {
    variants: number;
    orderItems: number;
  };
  discounts: Discount[];
  createdAt?: string | Date;
  updatedAt?: string | Date;
}

export interface ProductResponse {
  products: Product[];
  pagination: {
    total: number;
    page: number;
    perPage: number;
    totalPages: number;
  };
  stats: {
    totalInventory: number;
    lowStockCount: number;
    outOfStockCount: number;
  };
  filter: {
    lowStockThreshold: number;
  };
  viewMode: string;
}

export interface ProductFormValues {
  name: string;
  description?: string;
  price: number;
  cost?: number | null;
  barcode?: string;
  inventory: number;
  tva?: number;
  categoryIds: string[];
  images: string[];
  variants: ProductVariant[];
  expiryDate?: string | null;
  customFieldValues: CustomField[];
}

export interface ProductFiltersType {
  search?: string;
  category?: string;
  inStock?: string;
  lowStock?: string;
  page?: string;
  perPage?: string;
  sort?: string;
  order?: string;
}

File: ./src/hooks/useProducts.ts
// src/hooks/useProducts.ts
import { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import { useToast } from "@/components/ui/use-toast";
import { apiClient } from "@/lib/api-client";
import { Product, ProductResponse, ProductFiltersType } from "@/types/product";

export function useProducts(filters: ProductFiltersType) {
  const { data: session, status } = useSession();
  const { toast } = useToast();

  const [isLoading, setIsLoading] = useState(true);
  const [products, setProducts] = useState<Product[]>([]);
  const [totalProducts, setTotalProducts] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [lowStockThreshold, setLowStockThreshold] = useState(5);
  const [productStats, setProductStats] = useState({
    totalInventory: 0,
    lowStockCount: 0,
    outOfStockCount: 0,
  });

  // Use a ref to track the previous filters to avoid unnecessary API calls
  const prevFiltersRef = useRef<string>("");
  const currentFiltersString = JSON.stringify(filters);

  useEffect(() => {
    // Skip if session is loading or filters haven't changed
    if (
      status === "loading" ||
      !session?.user?.shopId ||
      prevFiltersRef.current === currentFiltersString
    ) {
      return;
    }

    // Update the previous filters ref
    prevFiltersRef.current = currentFiltersString;

    const fetchProducts = async () => {
      setIsLoading(true);

      try {
        // Fetch products with all params
        const response = await apiClient.products.getProducts(filters);

        setProducts(response.products);
        setTotalProducts(response.pagination.total);
        setTotalPages(response.pagination.totalPages);
        setLowStockThreshold(response.filter.lowStockThreshold);
        setProductStats(response.stats);
      } catch (error) {
        console.error("Error fetching products:", error);
        toast({
          title: "Error",
          description: "Failed to load products",
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
      }
    };

    fetchProducts();
  }, [session, status, currentFiltersString, toast]);

  return {
    isLoading,
    products,
    totalProducts,
    totalPages,
    lowStockThreshold,
    productStats,
  };
}

Directory Structure:
.
├── .git
│   ├── branches
│   ├── hooks
│   │   ├── applypatch-msg.sample
│   │   ├── commit-msg.sample
│   │   ├── fsmonitor-watchman.sample
│   │   ├── post-update.sample
│   │   ├── pre-applypatch.sample
│   │   ├── pre-commit.sample
│   │   ├── pre-merge-commit.sample
│   │   ├── prepare-commit-msg.sample
│   │   ├── pre-push.sample
│   │   ├── pre-rebase.sample
│   │   ├── pre-receive.sample
│   │   ├── push-to-checkout.sample
│   │   ├── sendemail-validate.sample
│   │   └── update.sample
│   ├── info
│   │   └── exclude
│   ├── logs
│   │   ├── refs
│   │   │   ├── heads
│   │   │   │   └── main
│   │   │   └── remotes
│   │   │       └── origin
│   │   │           └── main
│   │   └── HEAD
│   ├── objects
│   │   ├── 00
│   │   │   ├── 4145cddf3f9db91b57b9cb596683c8eb420862
│   │   │   ├── 8a674218376369688475c9aa8bdf1b6bb2782d
│   │   │   ├── b6c33160126c79770c03929eb5620c193c98a0
│   │   │   ├── c02f9e771a752db917437474029025db2d5586
│   │   │   ├── e01aa488fdbd502fab681c2758afb4d0b4339b
│   │   │   └── ff5f4c0894222d8d26b1ee1ba5ae968ebb0024
│   │   ├── 01
│   │   │   └── 854671313a66cac834e244820e8d46def1ec18
│   │   ├── 02
│   │   │   ├── 12e0648354e75c0076cce4b5fde362e1918ed4
│   │   │   ├── 38f6834d57360b11589b3aca5bc8a0fc247f39
│   │   │   ├── 3fbb2832e1c0e97902ea15a93afca243135a49
│   │   │   ├── 7b87c1473baef9d5c6b6a2b8cc86e319cba802
│   │   │   └── 884217e10bb9a1c102c612319d24aaff3c8d76
│   │   ├── 03
│   │   │   ├── 133058e0dbb883c46740662eff29c537726d32
│   │   │   └── 763ff37392dba8181b192e81b7ed80e794ddff
│   │   ├── 04
│   │   │   ├── 2b61d7be64c867fcffb67aa3ff69b3b99f018e
│   │   │   ├── 4d386c7669b977517f422ec2c6af51253bbd87
│   │   │   └── 6908dfb91f2c67356ca02598450d5a6e1a9278
│   │   ├── 05
│   │   │   ├── 1a452843da4577239a501cfeb68021f7a3301b
│   │   │   ├── 709d0762b494739d277f4161f21c36db0418a5
│   │   │   └── 8e6b2ce7f7eafb5b1debc3e32050bbfcab2dfd
│   │   ├── 06
│   │   │   ├── 1bb095a3bfc85ecad493d6a80cbcafa1b51bc2
│   │   │   └── 233398b02f0e839b5fef5359e758d53b87ae84
│   │   ├── 07
│   │   │   ├── 025d4f41a60a895ed8773a4ccd3b3603c81026
│   │   │   ├── 06f0a7f4bee2dee9ebd4c24aa624eba2376429
│   │   │   ├── 16b89921451cff616ac3a66dcb32460c6e4ae9
│   │   │   ├── 2d05a391eb38b1406f4012088bc43ed78fe4c6
│   │   │   ├── 756a43089bbb1a679e25e687e354f17d6076fe
│   │   │   ├── 75f32aa8a3010179e2db6ca5b82feb58fe241b
│   │   │   ├── 87f50918a73aaff6e80f0c2915335829b0278f
│   │   │   ├── 8f06cbe42dde6a8813a93f46818686c1fb59df
│   │   │   └── a2ab9a715de9f7c2d82353895cb0ed508827e6
│   │   ├── 08
│   │   │   └── 4b6def95e25f9a792c8f3c5eb74fa8559339ed
│   │   ├── 09
│   │   │   ├── 143b438eea83ce065aadb3f9a71a55bff605ae
│   │   │   └── fc65c716d5f54f7484d8f8c24154a339697f35
│   │   ├── 0b
│   │   │   ├── 1dcebdcf07d89eb50c5f1f9103b4256e163bb6
│   │   │   ├── 3051bf41d5009b314c9190afb727d847e03bdd
│   │   │   ├── 58c325fb8e6a14fabb14b40fbc73843acac7cc
│   │   │   ├── bd56cbef52317c6b2fc71b5f2bb537b3f3c203
│   │   │   └── d2417775817af89fb403821b464072d9538ed5
│   │   ├── 0c
│   │   │   └── 546c2d998cfcbaa1329ee6bdcf849047ea0f87
│   │   ├── 0e
│   │   │   ├── 090b503d9c859d2a24eddbab9366bd42b12e9a
│   │   │   ├── 438611d96fce1906bae2b94f7a908b6c6bbceb
│   │   │   ├── 980ecbec54d465cf9e4d55bc86f97f67e6ddca
│   │   │   ├── b996e198323e16ab4597d64b6e66ffcba35803
│   │   │   └── bd308903e53afb1d2c3a0bcd0a9a1b7eea6039
│   │   ├── 0f
│   │   │   ├── 1feb839a6ec03b5bda93d6565335bbdedef37e
│   │   │   └── 95ec44bb72fee84844c7cdf581ed4f2394c14c
│   │   ├── 12
│   │   │   └── 159baf15aa3d59bc8f074c9125ac72d845c60d
│   │   ├── 13
│   │   │   ├── 782b14a79f3f071d304e9d75974af0eadf5edb
│   │   │   ├── b978eaa10efc80206f388fe93c6f474da01413
│   │   │   └── cac151893cc51d7b84b9299a41d826d4301dd5
│   │   ├── 14
│   │   │   └── dcd77cacd5ef3f548a4c67e1e6b6f3a5eba0a3
│   │   ├── 15
│   │   │   └── ca0c8429a946ca1225bb84371eaa435420e86a
│   │   ├── 17
│   │   │   ├── 0ae26ee7fa090315e8b0169931f232b352f1fc
│   │   │   ├── 1367809f0c2f5d972f22862ee5457adcf6f248
│   │   │   └── f614c2fa895f5ea56faba5c5a6ac117a07edfa
│   │   ├── 18
│   │   │   ├── 06770c204b25b38e94ec822f198bf9b2958dde
│   │   │   ├── 4a0834f2e4fc7733e9b63e926b04f7d298cd20
│   │   │   └── a0573d9047d06b44183830c849a610cc43cea1
│   │   ├── 19
│   │   │   └── 7ab0b2ff4f0910a5e93552b6f791c543e938fc
│   │   ├── 1a
│   │   │   └── f032b459f90b4027a1e568f98ed1e59e95cbfb
│   │   ├── 1b
│   │   │   └── c8eb22e426e0bebbe90230ca64b07c51c61075
│   │   ├── 1c
│   │   │   └── 93afda239c19af5a77e3bde5e4975d86608fd3
│   │   ├── 1d
│   │   │   ├── 530a09345b608cf66645254f984c17bd704c10
│   │   │   └── 5920267c921389778680b724a6de3165d674f0
│   │   ├── 1e
│   │   │   ├── 93582a7610b42847cb2f5fd62ea95479677cd8
│   │   │   └── e6e98f7a3e06dabca24a19d63264933752a2f3
│   │   ├── 21
│   │   │   ├── 55236a647e952b03471626c772abdb81e1271f
│   │   │   └── ebf6c4a4c50384ad4b332f094253512b78bfc6
│   │   ├── 22
│   │   │   └── 960675d687b6d20e8816d9bce3d60454b62a28
│   │   ├── 23
│   │   │   ├── 459f164111b688316f2c05315be5cb640a5347
│   │   │   └── f7b6a4cbcad4321fd826c8745410c3707deff6
│   │   ├── 24
│   │   │   ├── 7cf1970c2079550d37d17b8c590bc13626aa7f
│   │   │   └── 8938419c323c12f29a407b0154a1cecec4f025
│   │   ├── 25
│   │   │   ├── b36922c17af498c7481352e37b2d50c247a5cd
│   │   │   └── f369a4c8fb6d8c75fc7cb71ac77c7a9ba1fa5d
│   │   ├── 26
│   │   │   ├── 289a6fbac92c2a77c159d7511a945da87018a9
│   │   │   └── 74edd390896b62cde77cb5544a375d88b2840c
│   │   ├── 27
│   │   │   ├── 3e39fcc80242f73c1e2bea7d25754b566cfcd6
│   │   │   ├── 9334b2bf09c825b81d11e9d7a885c48f32b822
│   │   │   └── f1fab16756135f891cc62f33e0d6261c8c7213
│   │   ├── 28
│   │   │   └── e44464a27ae5cedc54e6359236e86ad2dd9f14
│   │   ├── 29
│   │   │   └── 804883defb3d616828141f6790409337754f32
│   │   ├── 2a
│   │   │   ├── cbc4b69aa59f91b6c98f0de754152ace59ec25
│   │   │   └── e502ca4a793b15de5d7c7b9810b996cafa40ed
│   │   ├── 2b
│   │   │   ├── 73a9a9942fb45eb4fb4cf6865eceb08c4fced0
│   │   │   └── 80cad5d48c9b807e2c18ec8957d3801849f8ed
│   │   ├── 2c
│   │   │   └── 3a954cd109c823a0a7fde36dce08f9b533397b
│   │   ├── 2d
│   │   │   ├── 5868a0803e2a59ef584f869b607b3115c86a10
│   │   │   ├── e69ce6988c7dae2203b2eaa8b4f184bf2c46c3
│   │   │   └── f57f4deefa60de0229145a948671209a4c8816
│   │   ├── 2e
│   │   │   ├── c4ce37fe48fe98f43c00440a1818c9c8b14ed3
│   │   │   └── d3b2c356f72e41463c7aaf16b1c501169473d8
│   │   ├── 30
│   │   │   └── 5d20680fe77bbc9e6c80962e81fa8583ff5e1d
│   │   ├── 31
│   │   │   ├── 0f0bac4e91a2c27d8e4651fb16003e88cd69fe
│   │   │   ├── 5bca9bbe95c0c05ec4138b703c8633f59513c0
│   │   │   └── f67c99fd52eda55e87a9a81a09d0dc39e79dab
│   │   ├── 32
│   │   │   ├── 23d63b84767dd5b0572a04e907b21c418e21c5
│   │   │   ├── 4d2958cfa2b6f4af3369eebafc3bbf6021970f
│   │   │   ├── 7ceed59ac785bf09fad6c9f2137ec3b38cdff8
│   │   │   └── d360e049ce15f02bf4be927b742164d21ff6f2
│   │   ├── 33
│   │   │   └── 72f4574f1af3094510ff85187333b8bd1f60c2
│   │   ├── 34
│   │   │   ├── 0f834cfc5a7e12579b080b1d5ca97414f822b6
│   │   │   └── 4f26f3fde6228ceda7a740d169080875c5a479
│   │   ├── 35
│   │   │   └── cf9bcdfd8d9ef8fc04dfc50d2c56dee730165e
│   │   ├── 36
│   │   │   └── 6ab4a25a4aa4e61503d47bb17e7ed18b1481e9
│   │   ├── 37
│   │   │   └── 09491ccb30d272d0de09eaf0195a66d39b3580
│   │   ├── 38
│   │   │   └── db468f1af2314ac27109301994e4b27148df31
│   │   ├── 39
│   │   │   ├── 116fbd2c3c706b60aef48ce866679510603c98
│   │   │   └── e05a0834179d8bf914529a94dc233018df94c3
│   │   ├── 3a
│   │   │   ├── 08a245eb037574f22b3fc077d98ce63a5088c8
│   │   │   └── 6b94aaec98d250e773767d6b412e41321e65d7
│   │   ├── 3b
│   │   │   ├── 6cac8c6cd475322d8bf36269a5f9bbd946eafa
│   │   │   └── c1187f0b5722824459334b307d1564482bb3ae
│   │   ├── 3c
│   │   │   ├── 5318fefac25d6c4593c1d223e8d2e2e480af02
│   │   │   ├── 7d7ccb3e17a23c1c12339a893cee636fb72fff
│   │   │   └── a7283c6fcce48ac611b0f36c883980788d2222
│   │   ├── 3d
│   │   │   └── f8c2803def04b9f6dfe87f52ee52d3b89591de
│   │   ├── 3e
│   │   │   ├── 0044e71ecc5161e828b29a8bbbaa063a370fa4
│   │   │   ├── 2100765d9c7e1b9cce85c8237698c4c9e3bb9a
│   │   │   ├── 25a9a01d9c46b3e2adb69ac470a0cd42da9d25
│   │   │   └── ee0141abe634fab81de261c7133991b5a56a17
│   │   ├── 3f
│   │   │   ├── 40213fcc54a545613ba166e3653f6b615d4543
│   │   │   ├── 59794a621dd52fd341ddf23841a30bc79691d2
│   │   │   ├── 7b7eb38548621b4900affebfa4a3fd477ad376
│   │   │   └── df9bf49fe6e5fddb81de20335e9a988c6f8efb
│   │   ├── 41
│   │   │   └── 16d4e7576c8e0f5ac7fb448a59d875702066b2
│   │   ├── 42
│   │   │   └── 1e928a1f097a48f76ae031fbce228e54b5ccc1
│   │   ├── 43
│   │   │   ├── 72cadf1f6c8e25d8e7126f7ac5a73a6e159f11
│   │   │   └── 758276f7753f60b816295745f4df9fd76ad97b
│   │   ├── 45
│   │   │   └── 66f1a5725607619d17f1a326a7ff861fc64ce9
│   │   ├── 46
│   │   │   ├── 309cf00434524186c5eaf16183832cfc9cbc2c
│   │   │   ├── 8b434cd79ee70310c47a58acbf171d8dac793c
│   │   │   ├── bc2cbb76f4250b2fb2cec376da9164ffe556ba
│   │   │   └── de0484467565dff2f5d70b64b1f3eaec4afa67
│   │   ├── 47
│   │   │   ├── 78b753da9ea40dfc656230a5fe630de91c62bc
│   │   │   └── a66e57925c5d4cd8f8a8e02663bf4ac91c1f1a
│   │   ├── 48
│   │   │   ├── 480f97ad4570d69b94256aefdf6956fd11e487
│   │   │   └── 90b7bd4d5436dbab0a8e48a90cb74a954a9311
│   │   ├── 49
│   │   │   ├── 23af304c4223b6f5d6c679abf1a655732f97a4
│   │   │   ├── 98fd8ea0ab419e6f62bb05ce02660e108e38d7
│   │   │   ├── 9bf4172cd278bf3a04628ba360dec352d7cbba
│   │   │   └── df8f099f9ac61b456c73e788caf01cabdfeeb7
│   │   ├── 4a
│   │   │   └── eb91ca77f287e67967322caa661b7e3d1ce756
│   │   ├── 4b
│   │   │   └── 0e22fea4858058e324444b93402bb6997c45ee
│   │   ├── 4c
│   │   │   ├── 23a544b5094d6f455ed3b358c540a3f762cc82
│   │   │   └── 485086d3fe31b182495c4b7bb530fa65d11bd1
│   │   ├── 4d
│   │   │   └── e5a90815e453542b107d5f5d40669b3d710ff0
│   │   ├── 4e
│   │   │   ├── 6aaff233658585d963f9fe8ad71a05effaff74
│   │   │   └── 9ba5992179dc7b58f76d055448ff6e901f8533
│   │   ├── 4f
│   │   │   ├── f870a98566b9c1759d2aeedec6d40965527557
│   │   │   └── f931ac11417fb630a96415c508b990124929fc
│   │   ├── 51
│   │   │   └── 74b28c565c285e3e312ec5178be64fbeca8398
│   │   ├── 52
│   │   │   └── 8d1e59325c251ee70b63e8b076fb9829bcc916
│   │   ├── 53
│   │   │   ├── 72a5012c4bb030ec94797ce88c5824d9b39bec
│   │   │   ├── 7f63881549d58a9860909efb67cadaf17ebceb
│   │   │   ├── d7152012ac62738ea9e4d80eacfec5659b57a9
│   │   │   └── e044ce7aa85068d44f2a758b51475c96239406
│   │   ├── 54
│   │   │   └── 877ba9562729778b9e73aadc6f511f3413cd6a
│   │   ├── 55
│   │   │   └── 454efa43af6d559a500fe0999d84f324b991b8
│   │   ├── 56
│   │   │   ├── 50ed9b9d6ce9630ff338e10225d0e46993c13f
│   │   │   ├── 7f17b0d7c7fb662c16d4357dd74830caf2dccb
│   │   │   ├── 836413085afbe4b34cae46ec7e19343374a64e
│   │   │   └── 9787e3d409aff0e4826e4d147de7275d0cc62f
│   │   ├── 57
│   │   │   └── 9d0a07043cb69f92cbab54003434dd2b37179a
│   │   ├── 58
│   │   │   ├── 1090866d3ee984a665926a913686646e7a6177
│   │   │   ├── 65305f06cdc3bbcc80657ef9d289a3718ccf7f
│   │   │   └── f7b16c30e58266bb89f222bbda4e4cdaed171d
│   │   ├── 59
│   │   │   └── 960f1cad756ba0ebaee722990c488ae0416f19
│   │   ├── 5a
│   │   │   ├── 0da15f0269c8358287d378e761d52f8b5ef6fb
│   │   │   ├── 0e5d067a1c5944a6c387f00ed8d3134d2f8961
│   │   │   └── 6fa5dab8ad6e61084bdb4b3ac6cace67cf0c9a
│   │   ├── 5b
│   │   │   └── e911a45b98d29cbfaa57abf3de2efb5b9377da
│   │   ├── 5d
│   │   │   └── 2c7aaa0e02fa68f8b04e1679bad2e057749831
│   │   ├── 5e
│   │   │   └── f6a520780202a1d6addd833d800ccb1ecac0bb
│   │   ├── 5f
│   │   │   ├── 2df6b65b39a40bccacf163f5f9d081bc667ce6
│   │   │   └── 525a621014acee7a7cd721b09a7edeb8e6c0c5
│   │   ├── 61
│   │   │   ├── 51008c6ff6f2d893b3cf2b4e26c95b9b9be288
│   │   │   └── c0bd1a077a322c3fa0f69fc6abf0690b66cc93
│   │   ├── 63
│   │   │   └── caa8639fa9d39f3ed843f8c77db2a75403e193
│   │   ├── 64
│   │   │   ├── 8c57fd59d83581e928372c012c2073cc0a1158
│   │   │   ├── 8d6c4ffb3d6f1f9ea6e0e9c546a03814ae2b55
│   │   │   └── c16d657103db658128ef610b5887115067d98d
│   │   ├── 65
│   │   │   ├── 242fbdeb954c0025b98da878c9b3b51998ac9b
│   │   │   └── 6cac0938c9d044e51a60a2cf3ec18144af54a0
│   │   ├── 66
│   │   │   └── 1b05fb468d56cc97951b046eaf362eaab447e9
│   │   ├── 67
│   │   │   ├── 7a8e7ed9f084110466e40d776f274c7fba4303
│   │   │   └── 8e5fb15dd2916e49b6bfc3f0c5dd87adbae6ae
│   │   ├── 68
│   │   │   ├── 2d13cfadcb8d099daeac20c58dd1f8a46241fb
│   │   │   ├── 30ede1351feb00914d5d93cc09dcc30533565d
│   │   │   ├── 71bf08e1e4968ae08bdc4138ca71b5db721671
│   │   │   └── 794aff80dab7213199ec93e9a4d70baabb3f28
│   │   ├── 69
│   │   │   ├── 11ae342df90cf3dd1eb732850f309eda5301e4
│   │   │   └── c88766c5f8ae34c63bfe729e2e16821ead62f2
│   │   ├── 6c
│   │   │   └── 179d009677f55a8bd9381b12425718a9cf33db
│   │   ├── 6e
│   │   │   └── 8f1a24ae7e3173626484567ec01a520f8fefe1
│   │   ├── 70
│   │   │   ├── 5157400f8e02948e7e2a694a4743c3818d0a07
│   │   │   └── 9919ba0b2d8789b31069b2632834a434d73dd0
│   │   ├── 71
│   │   │   ├── 310d05fade18369073f55d963a08ba80785e6b
│   │   │   └── 8d6fea4835ec2d246af9800eddb7ffb276240c
│   │   ├── 72
│   │   │   └── bc0715293ef0d859a27841e71af87de92d8fdd
│   │   ├── 73
│   │   │   └── e429f4bdd363e62b7b8461da1acac89c1f6bea
│   │   ├── 74
│   │   │   └── 7dfd16884aab0d0d3d4d7798f55fb663fa0645
│   │   ├── 75
│   │   │   ├── 3c4786841da5cad055f73e64dd5d0686db217c
│   │   │   ├── 549ecbcc4e86b4c03c1888ec095e86fd7a8dd8
│   │   │   ├── cee1ce03d987ce4faa5d1bfd871de4ff2d3b45
│   │   │   └── d878a585d4a5a01b88007804179707e6cc59b6
│   │   ├── 76
│   │   │   └── 309f5b15e7bae57e69a98823eb43de99bc378d
│   │   ├── 77
│   │   │   ├── 053960334e2e34dc584dea8019925c3b4ccca9
│   │   │   ├── 2fe1fcb237e44abc20b8d3d7ed72a085b89a6b
│   │   │   ├── 3bd1af5b9a2f7af24caa61914b406eaee59495
│   │   │   └── 78ef8db33be65e1e97c8f044a49f86f71cdc9e
│   │   ├── 78
│   │   │   ├── 17912e0191791bbbfd7c7611791abc0bd809f2
│   │   │   ├── 79ac837dfb79bc58e15a33634ad28f88ef53f4
│   │   │   ├── b9e3440cd6566a11c2477667f05d91078e037c
│   │   │   └── e1732e36be0b4689c8876b5265c9d1ed12ba24
│   │   ├── 7a
│   │   │   └── 8a10f7f7a0aa26ea9b905ffa111c27ad73f586
│   │   ├── 7b
│   │   │   ├── 38c1bb45e38527a2c595c07df5e70d38ada7d9
│   │   │   ├── 5b540433e9b4f480076e5122fdd1c9c128b783
│   │   │   ├── cc72e8c3a11ec0ed1f9d0026856250b1d5f8eb
│   │   │   └── fe5b702337d69fd8af02c7642b5c87ac6b9eb9
│   │   ├── 7c
│   │   │   ├── 0f66fac6f9ddda85d39c3e4b74796fa2bc2391
│   │   │   ├── 714e2304f54822930f7cade6a5b4fd7ced6b7e
│   │   │   └── ba18a136bb484c9ada0eb315864be0bf713b74
│   │   ├── 7d
│   │   │   ├── 4b97eabaccc8de48362c0a499dfbd2a93446ad
│   │   │   ├── 7a8d8073360c927da4737f770d2d543bbd9fb7
│   │   │   ├── b031521883cf6f2287b9e080ee80e7ff7f8d89
│   │   │   └── c29ff8360495d37a110ef5a6984e29ca27dfce
│   │   ├── 7e
│   │   │   ├── 045bd771b8895c6d10d3279ffda773f2be08d4
│   │   │   └── 14be534ddf9f144fca5007ca868e0a03936638
│   │   ├── 7f
│   │   │   └── f6a569bb137de0ec718b5d1ed147ddc91da733
│   │   ├── 80
│   │   │   ├── a01b463e2b10482bb2ef40af8e5dfc484d7a23
│   │   │   └── ffe9dacf70144c4fcb4c91d4c3ea5e74be377d
│   │   ├── 81
│   │   │   ├── 38c30f39002fd7245102d4e357d9a33f8cb60c
│   │   │   ├── b37b820853e8b4e57efae632fd5dbb8ea7f101
│   │   │   └── bc051555d2ef318243175d6a38ad8a1f76399d
│   │   ├── 82
│   │   │   └── 1a8af32313bcaba34d7b7351f4e45115368396
│   │   ├── 83
│   │   │   ├── 52093324281d5ab36ae365d9df879ba2aef425
│   │   │   └── e764e161b457b84bd03789fab8b9c1d332ed18
│   │   ├── 84
│   │   │   └── 6d32af7f67e3b655a9172651f7129e3387d9a0
│   │   ├── 85
│   │   │   └── 3d7af57a195efc63415b721e6887cebec01cb6
│   │   ├── 86
│   │   │   └── 4a2b1992ce86a377adc802df502add97b2db5c
│   │   ├── 87
│   │   │   ├── 0896d573f963a88d44b9704a1896e328a5d58a
│   │   │   ├── 4ab31d99fa253443a85307b33f90a44468df9a
│   │   │   └── b6ae4233084d661366d96a920252d01cebbafc
│   │   ├── 88
│   │   │   ├── 8d8af88e126016fd32090013ab3c33896156b5
│   │   │   ├── ae5d1cb01f271a89b31be6dd02a2e102cdb19c
│   │   │   └── fd861a75dfe0ea8529e29b4fa62e3559976ac6
│   │   ├── 89
│   │   │   ├── a31c459a65a671ff742de7a187c4d550e50892
│   │   │   └── e47cdca36b02f8c510edba2080321ae7624cbf
│   │   ├── 8b
│   │   │   ├── 111a230d73512d0a33efb64a60a55718bb0d7d
│   │   │   ├── 34281451d849a62b85b4c33db3e8fe210165e1
│   │   │   └── 3e381b323bde3e7fa9a51dd7d85a778d8f0e41
│   │   ├── 8c
│   │   │   ├── e12f0ae631195446801c69e4a79ab94903ff34
│   │   │   └── f4a00143ad6a1ca7617e23cd103b0741dc58c9
│   │   ├── 8d
│   │   │   └── d3629876d73e85e00bf74e843d36dcaba2e650
│   │   ├── 8e
│   │   │   └── fea7a87798f4dcc5af924541d7d2145c8e6369
│   │   ├── 8f
│   │   │   └── 95e3832857f0a0f6fd2d47e6afc66b719ef3b3
│   │   ├── 90
│   │   │   └── 4e28de69aae8c7c2a75b609e5f8abf5a6b4b3e
│   │   ├── 92
│   │   │   ├── 914d359369869411b64d9abe37db53ddc2bd37
│   │   │   └── aa7dc7d9b753c59ab705deef07b470a31f01a1
│   │   ├── 93
│   │   │   ├── 11ff3c674dbc092d56d3bd41447a2946915850
│   │   │   ├── 22ae618b5a6cc80a25189892bdf51e65146a45
│   │   │   ├── 944db0663b741f5190ad604b4ffb159bac1514
│   │   │   ├── a2d7355c992da2ea1b485de68521ca3e94ce5e
│   │   │   ├── a6cd9c1a7bf162ffab5eb18e40a8ecba5a6412
│   │   │   └── d758919823ffc0e8f5d4c9b82928aebbe3e9df
│   │   ├── 94
│   │   │   ├── 3abd37eaa1d569bcbb621e131932f4eacd6208
│   │   │   └── 80dbf49d4d1447ba7d561fb20febedfbb728db
│   │   ├── 96
│   │   │   └── bbb9973651b4ff44af08200dd275abff0110c8
│   │   ├── 97
│   │   │   └── 3940fc748e2f6238ca8ee43bd4c69039dc2a33
│   │   ├── 98
│   │   │   ├── 682b0de78ce8d88bb92de9ff2f1a098272cf25
│   │   │   └── 75e0089841f167076934b05dd3279d67ab46d0
│   │   ├── 99
│   │   │   ├── 458d4ed5b9788796a045c4411b68ab6940cfde
│   │   │   ├── 6ef769d49ed7526b934c5f773cfae4027b25fa
│   │   │   ├── 7c07ca42582916ddc8d66df1365ea05d362712
│   │   │   └── b8821d5686dd02655294c927d55910b2453b6c
│   │   ├── 9a
│   │   │   ├── 0d8252a555a16addfe4edddab3775f4da06316
│   │   │   ├── 41d3146ae98499cdfa7fa88277c9b3c5583ed8
│   │   │   └── 8255cdb3558bfa6f0b500ef935c8e709b28163
│   │   ├── 9b
│   │   │   ├── 203449c1d410a88a9882b5e1ebfe51147a3a2b
│   │   │   ├── 2d444c38cad7a8afe23efca00a912d2193569a
│   │   │   └── 8abfcc8226db01e26609988eb36b4d2224bbdf
│   │   ├── 9c
│   │   │   ├── 6281c0159cd70b51727798e56c86cfd2e5d13c
│   │   │   └── 9b034093a34ad9aa8150dd32f43ee0a9a45321
│   │   ├── 9e
│   │   │   └── 44e58362c13f6a802dec38627f5030a80ff914
│   │   ├── 9f
│   │   │   ├── 133fdea6cb1c76320b67f336e954cea48cda77
│   │   │   ├── 1c0356820ad91955b7ca16aedd86e3d59d7fc3
│   │   │   └── 5bd081298b2e094b9bf6e5c1c3a0a9f99a50d5
│   │   ├── a0
│   │   │   ├── 205e56e94354479fe53a366409391a3274b964
│   │   │   └── dc396f14b79703b4521286fb08b57f99cc5eeb
│   │   ├── a1
│   │   │   ├── 7e3c043989830c4dc7a58d8500ccb376f72dd7
│   │   │   ├── 88d985744b3ef7379e190c8701710f0089e372
│   │   │   └── b7d7cdde347f863a92f55bc856c0ca40eed25a
│   │   ├── a2
│   │   │   ├── 2f2731175686c442ffcfd90d0da913582c17b2
│   │   │   ├── 3c1f5fc9a84099ec9fd3307e799e8e177c2984
│   │   │   ├── 67d18c5ddf5eeb6b183ede3375c616e681c928
│   │   │   ├── dc41ecee5ec435200fe7cba2bde4107f823774
│   │   │   └── fe9a68ae4c6e433ee9f442c068261f92d6464f
│   │   ├── a3
│   │   │   ├── 2e20e0339debeb04d7872327d5d7053fd47a1f
│   │   │   ├── b9e744e8ec4a36dc4bdf83dc308f7e406ef452
│   │   │   ├── be882f5e46873e74a7245cb5d44a1c7955cab7
│   │   │   ├── ce48e4f9f324c0cd7773149fb1dee96ad79470
│   │   │   └── cf2f0e4af8a99673d09924cecabc645a4184f3
│   │   ├── a5
│   │   │   ├── 530d890c03a323e770d03efbe9257c034b3058
│   │   │   └── 77a87d3a562afb2a0f067857a449f9bfc804b3
│   │   ├── a7
│   │   │   └── 8cd69844cb29c310e20173022ae081708b002a
│   │   ├── a8
│   │   │   └── 0211cac5f29bcc23942421f11d2dbba19cb172
│   │   ├── a9
│   │   │   ├── 513a51fffb0593f1cd2f0f1535392fd7806f3d
│   │   │   ├── 5ca75d8ca8d7f1b9d95485d153417f5de2c862
│   │   │   ├── 92cff1c567f25bb58ea654b4e8509d89f74db4
│   │   │   └── d7c22c3d8bb9f86a0b90f31cb3b7f4e7922da1
│   │   ├── aa
│   │   │   ├── 07d4bf2c6228344b0beb2d4e02638e275e8a29
│   │   │   └── 96ac3bf39e737db63e37db9f81f86117e5ca7c
│   │   ├── ab
│   │   │   ├── 45b4de64c35f14e05f5908df5902fcd583a485
│   │   │   └── a9efa0c22bc66d967b6cb749dabe84bfb68fdd
│   │   ├── ac
│   │   │   ├── 81f792f1d912121fdb32da821a9893891faebc
│   │   │   └── b478ce511d3df2e8ad048cf7d9cc9d34dbda77
│   │   ├── ad
│   │   │   ├── 1874447fa36e8b92172f36251e6fc31d165423
│   │   │   ├── 353fba33e15a4f10464c1f96a8b71c06603f80
│   │   │   ├── 3c5b84204b89d4348ea3b7220f6efe6dda508d
│   │   │   ├── 72a591a31eb3d65e31547416fe861f2b94fe65
│   │   │   ├── 7364f53bf4ccf7ea551b1cfcdc2b1eae5cd66a
│   │   │   ├── e1dab49f734e75e07efd45e1c5d97377c60345
│   │   │   ├── e71340dce11b6a5d239b602fd25531e9496466
│   │   │   └── f48003b58dc594427a8c871449611a07bc4ba4
│   │   ├── ae
│   │   │   ├── 53198eb67d14a5d3cf721b97e64114d707689f
│   │   │   └── db4ca7c95a8e23cb5dc7445c326a4be92516b9
│   │   ├── af
│   │   │   └── ca8ad7c770eb782ba2d790725118e12b397deb
│   │   ├── b0
│   │   │   ├── 143a996a519d91f778a5627e6157f1e7aeec5b
│   │   │   ├── a67e9b05842f21bc49d2e842a7a2071a0c2179
│   │   │   ├── cbf1f0a7dc96090520e63a5cea12e27f435eff
│   │   │   └── d9bd5eb79d065b1301a15a05d86e49f5985e84
│   │   ├── b1
│   │   │   ├── 038540a484395617cb95413c51236203e00ab6
│   │   │   ├── 3998af2ec0d9a04299b43db12f8afd450ae02f
│   │   │   └── 9cd1e79ab4f3c09dba198114a04ad88da01b53
│   │   ├── b2
│   │   │   ├── b2a44f6ebc70c450043c05a002e7a93ba5d651
│   │   │   └── dc36e9560b5df0e547a9812f01735734be522b
│   │   ├── b3
│   │   │   ├── 04c44fc81b29f421d2bfce0dcb281b62105344
│   │   │   ├── 04e47929bb87f145502d81882e67607907e74c
│   │   │   ├── 4127162a24c3ab922c7367ebcd3df603515a75
│   │   │   └── f27de71f946f5021e5ab05f844edbb154fd1ce
│   │   ├── b6
│   │   │   ├── 0f9008c0a2ee8b31f79016540e26cf770494cb
│   │   │   ├── 1df74fbf2505b4add926a6e8e638546371a7ed
│   │   │   └── cee70e2a87cb0ef55d38d1aaa02ea6e0cd8403
│   │   ├── b8
│   │   │   └── 8e9414356eab9515248802c63dbfe8012238b1
│   │   ├── b9
│   │   │   ├── 9f47a513dce18eead0c2a539fdccddfb62dbb8
│   │   │   └── f411ab6022be61349297eede1a6c5f0a5836ac
│   │   ├── ba
│   │   │   ├── 1d52f3f66b1cbde1c66f3627d00a44a9d2fbed
│   │   │   └── 3f78936e4d368ad64222d192cceea13a136732
│   │   ├── bb
│   │   │   ├── 2380280a753d87c18ac6cd7dd5fef5c3e169ab
│   │   │   ├── 42aecb8dadd80ce4e30d896bb7b112f458e174
│   │   │   └── a8bbdaa0c23f1237e39abea70f009a907b7642
│   │   ├── bc
│   │   │   ├── 9b0cdbe638a386f135f63731ccf7e6fead7598
│   │   │   └── e421322736b7ad7fbf1035217c6555c3625cd4
│   │   ├── bd
│   │   │   ├── 142898ef1bf2dd4295496553a8c4053803e652
│   │   │   ├── 2d1616077ad9ec3eae9802a98c12d6ad102447
│   │   │   ├── 3143c7325dc8af71eca3206bdf19e9ad3880a0
│   │   │   ├── e0e1a3c99288f4bee5ac901389e12130182e68
│   │   │   └── f9c09a0f94e2d75740a29a217c0e381cb83952
│   │   ├── be
│   │   │   ├── 13f49522bfe0d1c8fb59dde4e77028cfdcf232
│   │   │   └── c9af923ca4233975554ead5d552f9660b6ba65
│   │   ├── bf
│   │   │   ├── 30bf2c1910a6bf49ef8f79c876cc9c14a79d7b
│   │   │   ├── 74764d8e77ccb952597f9d14ce7fe56715fb80
│   │   │   └── ee3a269fd08fe620411ab04f20d83a4af44593
│   │   ├── c0
│   │   │   └── 731d8a7fc1beee3621320be6cdfb74bc76f482
│   │   ├── c1
│   │   │   └── 334095f876a408c10f2357faaced969ec090ab
│   │   ├── c2
│   │   │   ├── 2b88e70e0db0ce629d458dc3d920a650923f4b
│   │   │   └── 5052c34a63529c71240a0ca839d5d1e986318a
│   │   ├── c4
│   │   │   ├── 29959cd30fe3d5e2bede986f7517cfe44b8c96
│   │   │   ├── 810fea77a860a92f3251389f0a8669f1f823bb
│   │   │   └── e98ca17899abba85cedb0e6404e5dc2984b370
│   │   ├── c5
│   │   │   └── b5bacc2cb856ca6ecd2e52605821488070cb9b
│   │   ├── c7
│   │   │   └── bcb4b1ee14cd5e25078c2c934529afdd2a7df9
│   │   ├── c8
│   │   │   ├── 5fb67c463f20d1ee449b0ffee725a61dfb9259
│   │   │   ├── 8f389de09f418da376598c42e8788d4fb6d172
│   │   │   ├── 9a468c5550fdfaac61967aabcd10257caa8f53
│   │   │   └── aa8d744dbcbd7b6dd543d1b553d45deee4b5a1
│   │   ├── c9
│   │   │   └── a5d03b8f328ab70c0028acf716e3f9f9f865dc
│   │   ├── ca
│   │   │   └── 81b15477d257899b55185c0fac97c4ff45c64d
│   │   ├── cb
│   │   │   ├── 0822e83a1977a033515a0cdf54158805253091
│   │   │   └── 9bd0f9e42fb617808c3ddf22eacb212122f2c9
│   │   ├── cd
│   │   │   └── 4153e5e133086197ae387bbe808a281c8f5bfa
│   │   ├── ce
│   │   │   ├── a8a065a13032982ead328140f4d313a44c5f6d
│   │   │   └── f02ffd0b058d6c58d80e6b5896c62c68f41c74
│   │   ├── cf
│   │   │   └── 8956cb3659329f24a4020f0e03dbc314d09fe8
│   │   ├── d0
│   │   │   ├── ad410a5cf97ab15002dc6719732a00785f58f4
│   │   │   └── d668f35ede993af11de7e51502a52539f6bf7b
│   │   ├── d1
│   │   │   ├── 96b002ef14b9e5ada37ceeff65ba9760ec11a3
│   │   │   ├── b49bb181ba6b2403f40fd463084d403df92641
│   │   │   └── d2c907e9316258e4619204cf20e3707df012b0
│   │   ├── d2
│   │   │   ├── 289a0569b697e66a1f16f59f010f6a7577f990
│   │   │   ├── c2eeeaf4dd47a73907d8cde03d1cecdde655b4
│   │   │   └── f3df42f071265b1377669e8ce8ba3d9198b3c7
│   │   ├── d3
│   │   │   ├── 2ef96b9ba70ec59371a4af460798a908b89600
│   │   │   └── 9fe09b6141097c96892ca088556fa0641217e7
│   │   ├── d5
│   │   │   ├── 2387e4e252956b4bcc35133411a73605077edf
│   │   │   └── dfd05b6bf4fc11ed7c4e696437b4e2dbfd3935
│   │   ├── d6
│   │   │   └── 7af9ebe5e265b1d2cf6e6392e7a1c1cec7f9d8
│   │   ├── d7
│   │   │   └── efd1d89a4164a54c1c8b819885e880ee2f5313
│   │   ├── d9
│   │   │   └── 0dd7f679d771a0b76be28254f4612d73e09a03
│   │   ├── da
│   │   │   ├── 13cbcd09ec5324c91182ac165cb0a96786e643
│   │   │   ├── 34cad135cdaab0b0bc3353e82d6d33413d07cb
│   │   │   └── 89cf33dc49601c9950c8c1d871f5a2b47b008a
│   │   ├── dc
│   │   │   ├── 307df3b935c2ec2c835c30a090f4a0b6726398
│   │   │   └── cc88bab6f1759cb4260adf8e78dd1a4c1de872
│   │   ├── de
│   │   │   ├── 2c23cda95f891576983b05eb66ffa69bcabd1c
│   │   │   └── a0b5276ede671c998bcb5868404413e3e1f42f
│   │   ├── df
│   │   │   └── d6b784795c83fadcc61e143993304e1046aa1d
│   │   ├── e1
│   │   │   ├── 9db7d7f491089648186370f1d5fd6364f11cb7
│   │   │   ├── c49fae06d372638925e44b406b1efb22ecd18e
│   │   │   ├── ddba30d9604d8eb84d0ba16258f30dec145c70
│   │   │   └── eec94a0422fd350debd8e93dcf0cba771425ff
│   │   ├── e2
│   │   │   ├── 15bc4ccf138bbc38ad58ad57e92135484b3c0f
│   │   │   ├── 6802772e22876a5dcbd95a0e764d92239f7211
│   │   │   └── 888c43ddfa0bab5be6ec84e8bf6614c77317b7
│   │   ├── e3
│   │   │   └── fba1e75a5d99181d737a7f83373d90c7fe8818
│   │   ├── e4
│   │   │   └── aac2d8cbe3f95e1315f28d0904bd520456e504
│   │   ├── e5
│   │   │   └── 05f206818c2e4bcbcc5ff9508deaf266fc46a9
│   │   ├── e6
│   │   │   ├── 21a673b69c4d541e4152fe048c397667ec90b7
│   │   │   ├── 261040ecd66a6562a6b29f97e72feab98fc954
│   │   │   ├── 4897961ca22d23c4667b7cffcd1e058a965867
│   │   │   ├── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
│   │   │   └── a88809954cf714a6b5ae24d143689352fed0ea
│   │   ├── e7
│   │   │   └── 3d232df89e539dae5acd085faf8af27ee438e2
│   │   ├── e8
│   │   │   ├── 90059580004c31b67ab8b2ecdcb27a340d6962
│   │   │   └── cf023a1cef48a40e2db031ad4aad7bba875816
│   │   ├── e9
│   │   │   ├── 503f25e83680acf03f7f76b47a7e1fa770ca3a
│   │   │   ├── e18052a259b6f47b22668dcde03a78a1c8c01c
│   │   │   └── ffa3083ad279ecf95fd8eae59cb253e9a539c4
│   │   ├── ea
│   │   │   ├── 49409712bd95ce560898e040e03031642f4ec3
│   │   │   └── 746f2fb069be384e84cdc7c9a807ee3f99b4c4
│   │   ├── eb
│   │   │   └── 4af3f0dacf499632a7ceba8a82c259456e118c
│   │   ├── ec
│   │   │   ├── 52b5d6e85c8bbaee0351c829ff11468c5b9d92
│   │   │   ├── 6666704c56e41f63f72fde5d606247148558c7
│   │   │   └── 9569de774ff81f4b93dfe1292dba2dbd95bf5d
│   │   ├── ed
│   │   │   ├── 157d4f55c9dad76cf7ea333e00e678731c7183
│   │   │   ├── 9b36de99ec0801bfb4f057156eec282b889a8c
│   │   │   └── e9a621760c89e16e9e1a365db94667cdf4b4e5
│   │   ├── ee
│   │   │   └── bbcf713547e49ae2264593f5f6b01891c5dd75
│   │   ├── ef
│   │   │   ├── 09ef4986fab526501696645c3c75473f2c0b67
│   │   │   └── 341131ba698e508456bfed336e33c9a60556c9
│   │   ├── f0
│   │   │   ├── 31ceb50a2176a112ced2c8e5b391639cce0032
│   │   │   ├── 44d3927fcb1d54e573745b0a70a58ecead6fe6
│   │   │   └── f742f139edf9003b16d0272291c137c6b98657
│   │   ├── f1
│   │   │   ├── 05980c0367c4688ad386f349136637eb5b2534
│   │   │   ├── 60922d01347d509c2efdae72b3a244be631df2
│   │   │   └── bd00bb265d63d758bdb0ba2bd37b45b73247bc
│   │   ├── f2
│   │   │   ├── b165b761a255a6f0de9bcf0c1839a42beab3a5
│   │   │   ├── d9dc28906d836293d0a94d1b623af133d5bb75
│   │   │   └── fecd8278a6faf42842fbeafc8d3db480eb96ed
│   │   ├── f3
│   │   │   ├── 51bee196734f2c3bb4a0ef5cdad275380bbefb
│   │   │   └── 58e372022b3b642f868ee6ed0783973cf420ee
│   │   ├── f4
│   │   │   ├── 79471294b102901da5363a4399780d15db40cc
│   │   │   └── d5d4b3a5911700fcd5b691a177a6020207bacb
│   │   ├── f5
│   │   │   ├── 1ae9ebf876c6d0ebdaa3395ec663822a5fec3e
│   │   │   └── 96bef003035512101efd592c322af313356d7d
│   │   ├── f6
│   │   │   ├── 0a138702cbb0703beb8c08ff2af0c0bea7ee61
│   │   │   ├── 4bd6ffb4a20c28572e15daded66c14c750e08c
│   │   │   └── fb9f28bf7537fd8e1641597e585f7108604f23
│   │   ├── f7
│   │   │   ├── f4f38543a3ba9e128778fb15ed8b9aafd7ee9e
│   │   │   └── fa87eb875260ed98651bc419c8139b5119e554
│   │   ├── f8
│   │   │   ├── 539ed3cd5c20534f56975054ae3678b1013103
│   │   │   └── bd99a9c696232c3b787adf23f1fe94b5ff4ba5
│   │   ├── f9
│   │   │   └── d3729ac5557e625ac27a23e274e7b9279b46d3
│   │   ├── fa
│   │   │   └── e1ea128fee0e6c04c0d3426a58ea5dfe7a56e9
│   │   ├── fb
│   │   │   ├── 56569b60feebc570c9f3d3b0a1f2e826e53edc
│   │   │   └── fd544db7ff7519e9453dfb9a4336d548057be8
│   │   ├── fc
│   │   │   ├── 08633d57d821bc70eefc230fb15d8c4fc11ba3
│   │   │   ├── 1a6b2361797cef4623dbca005e39035c057714
│   │   │   ├── 4f375f28d7a89710db0fe915eed711bba0c6ac
│   │   │   └── f17524a5aab6fcc15eccaa730bb134f6d9dc17
│   │   ├── fd
│   │   │   └── 5d84135bc4ddda7cc43adda5c33da386ab50a7
│   │   ├── ff
│   │   │   ├── 5ffd80ce824887a5e33b0bece9a391d2868a00
│   │   │   └── f5db69022b55f3e64becc110c1d718d01580d2
│   │   ├── info
│   │   └── pack
│   ├── refs
│   │   ├── heads
│   │   │   └── main
│   │   ├── remotes
│   │   │   └── origin
│   │   │       └── main
│   │   └── tags
│   ├── COMMIT_EDITMSG
│   ├── config
│   ├── description
│   ├── HEAD
│   └── index
├── prisma
│   ├── fixtures
│   │   ├── advancedShop.js
│   │   ├── categories.js
│   │   ├── clear-all.js
│   │   ├── generate.js
│   │   ├── orders.js
│   │   ├── planPricing.js
│   │   ├── products.js
│   │   ├── run.js
│   │   ├── shops.js
│   │   ├── subscriptions.js
│   │   ├── users.js
│   │   └── utils.js
│   ├── migrations
│   │   ├── 20250315100735_ame
│   │   │   └── migration.sql
│   │   ├── 20250322090727_add_product_tva
│   │   │   └── migration.sql
│   │   ├── 20250417064031_ame
│   │   │   └── migration.sql
│   │   ├── 20250421003921_ame
│   │   │   └── migration.sql
│   │   └── migration_lock.toml
│   ├── schema.prisma
│   └── seed.ts
├── public
│   ├── file.svg
│   ├── globe.svg
│   ├── next.svg
│   ├── placeholder.jpg
│   ├── vercel.svg
│   └── window.svg
├── src
│   ├── app
│   │   ├── admin
│   │   │   ├── categories
│   │   │   │   └── page.tsx
│   │   │   ├── custom-fields
│   │   │   │   └── page.tsx
│   │   │   ├── discount-codes
│   │   │   │   └── page.tsx
│   │   │   ├── discounts
│   │   │   │   ├── [id]
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── new
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx
│   │   │   ├── orders
│   │   │   │   ├── [id]
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx
│   │   │   ├── products
│   │   │   │   ├── [id]
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── new
│   │   │   │   │   └── page.tsx
│   │   │   │   └── page.tsx
│   │   │   ├── layout.tsx
│   │   │   └── page.tsx
│   │   ├── api
│   │   │   ├── auth
│   │   │   │   ├── [...nextauth]
│   │   │   │   │   └── route.ts
│   │   │   │   └── register
│   │   │   │       └── route.ts
│   │   │   ├── categories
│   │   │   │   ├── [id]
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── custom-fields
│   │   │   │   ├── [id]
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── discount-codes
│   │   │   │   ├── [id]
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── discounts
│   │   │   │   ├── [id]
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── orders
│   │   │   │   ├── [id]
│   │   │   │   │   ├── invoice
│   │   │   │   │   │   └── route.ts
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── products
│   │   │   │   ├── [id]
│   │   │   │   │   ├── orders
│   │   │   │   │   │   └── route.ts
│   │   │   │   │   └── route.ts
│   │   │   │   └── route.ts
│   │   │   ├── shop
│   │   │   │   └── route.ts
│   │   │   └── users
│   │   │       └── search
│   │   │           └── route.ts
│   │   ├── login
│   │   │   └── page.tsx
│   │   ├── register
│   │   │   └── page.tsx
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components
│   │   ├── admin
│   │   │   ├── product-tabs
│   │   │   │   ├── basic-info-tab.tsx
│   │   │   │   ├── categories-tab.tsx
│   │   │   │   ├── custom-fields-tab.tsx
│   │   │   │   ├── discount-codes-tab.tsx
│   │   │   │   ├── discounts-tab.tsx
│   │   │   │   ├── images-tab.tsx
│   │   │   │   ├── pricing-tab.tsx
│   │   │   │   └── variants-tab.tsx
│   │   │   ├── add-custom-field-form.tsx
│   │   │   ├── category-form.tsx
│   │   │   ├── custom-fields-table.tsx
│   │   │   ├── discount-code-list-actions.tsx
│   │   │   ├── discount-form.tsx
│   │   │   ├── discount-list-actions.tsx
│   │   │   ├── header.tsx
│   │   │   ├── order-filters.tsx
│   │   │   ├── order-history-tab.tsx
│   │   │   ├── order-list-actions.tsx
│   │   │   ├── order-status-badge.tsx
│   │   │   ├── order-status-update-form.tsx
│   │   │   ├── pagination.tsx
│   │   │   ├── product-categories-select.tsx
│   │   │   ├── product-custom-fields.tsx
│   │   │   ├── product-filters.tsx
│   │   │   ├── product-form.tsx
│   │   │   ├── product-form-types.ts
│   │   │   ├── product-images-upload.tsx
│   │   │   ├── product-list-actions.tsx
│   │   │   ├── product-order-table.tsx
│   │   │   ├── product-pagination.tsx
│   │   │   ├── product-variants-form.tsx
│   │   │   ├── sidebar.tsx
│   │   │   └── subscription-info.tsx
│   │   ├── authorization
│   │   │   └── feature-guard.tsx
│   │   ├── providers
│   │   │   ├── session-provider.tsx
│   │   │   ├── shop-provider.tsx
│   │   │   └── toast-provider.tsx
│   │   └── ui
│   │       ├── alert-dialog.tsx
│   │       ├── alert.tsx
│   │       ├── badge.tsx
│   │       ├── button.tsx
│   │       ├── calendar.tsx
│   │       ├── card.tsx
│   │       ├── checkbox.tsx
│   │       ├── collapsible.tsx
│   │       ├── dialog.tsx
│   │       ├── dropdown-menu.tsx
│   │       ├── form.tsx
│   │       ├── input.tsx
│   │       ├── label.tsx
│   │       ├── popover.tsx
│   │       ├── select.tsx
│   │       ├── separator.tsx
│   │       ├── switch.tsx
│   │       ├── table.tsx
│   │       ├── tabs.tsx
│   │       ├── textarea.tsx
│   │       ├── toast.tsx
│   │       └── use-toast.ts
│   ├── hooks
│   │   └── useProducts.ts
│   ├── lib
│   │   ├── services
│   │   │   ├── categories.service.ts
│   │   │   ├── index.ts
│   │   │   ├── orders.service.ts
│   │   │   ├── products.service.ts
│   │   │   ├── s3-image.service.ts
│   │   │   ├── shop.service.ts
│   │   │   └── users.service.ts
│   │   ├── api-client.ts
│   │   ├── authorization.ts
│   │   ├── auth.ts
│   │   ├── feature-authorization.ts
│   │   ├── permissions.ts
│   │   ├── plan-features.ts
│   │   ├── prisma.ts
│   │   ├── serializer.ts
│   │   ├── subdomain.ts
│   │   └── utils.ts
│   ├── types
│   │   └── product.ts
│   └── middleware.ts
├── all_texts.txt
├── docker-compose.yml
├── .env
├── eslint.config.mjs
├── file_list.txt
├── .gitignore
├── makefile
├── next.config.ts
├── postcss.config.mjs
└── README.md

292 directories, 650 files
